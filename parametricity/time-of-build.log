COQC debug.v
debug.vo (real: 4.71, user: 3.92, sys: 0.64, mem: 539448 ko)
COQC de_bruijn_print.v
de_bruijn_print.vo (real: 5.04, user: 4.23, sys: 0.68, mem: 538152 ko)
COQC makeFresh.v
makeFresh.vo (real: 4.55, user: 3.87, sys: 0.59, mem: 534784 ko)
COQC translation_utils.v
translation_utils.vo (real: 6.90, user: 6.20, sys: 0.57, mem: 571264 ko)
COQC param_unary.v
param_unary.vo (real: 5.95, user: 5.14, sys: 0.70, mem: 564664 ko)
COQC param_exists.v
param_exists.vo (real: 6.15, user: 5.38, sys: 0.67, mem: 564740 ko)
COQC param_other.v
param_other.vo (real: 5.30, user: 4.57, sys: 0.64, mem: 564440 ko)
COQC param_all.v
File "./param_all.v", line 52, characters 0-105:
Warning: This notation contains Ltac expressions: it will not be used for
printing. [non-reversible-notation,parsing]
param_all.vo (real: 3.24, user: 2.66, sys: 0.50, mem: 565220 ko)
COQC param_comp.v
     = tLambda (nNamed "f") (tProd (nNamed "y") (tVar "Y") (tRel 0))
         (tProd (nNamed "y") (tVar "Y")
            (tProd (nNamed "yᵗ")
               match todo "tsl var" with
               | tEvar _ _ =>
                   if todo "tsl var" is (tApp f args0)
                   then tApp f
                          ((fix Ffix (x x0 : list term) {struct x} :
                                list term :=
                              if x is (x1 :: x2) then 
                              x1 :: Ffix x2 x0 else x0) args0 [
                             tRel 0]) else tApp (todo "tsl var") [tRel 0]
               | tLambda _ _ body =>
                   match
                     (fix Ffix
                        (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                          term :=
                        match x1 with
                        | tRel n =>
                            if
                             (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                if x2 is (S x4)
                                then if x3 is (S x5) then 
                                     Ffix0 x4 x5 else false else true) x0 n
                            then
                             if (fix Ffix0
                                   (x2 : list term) (x3 : nat) {struct x3} :
                                     option term :=
                                   if x3 is (S x4)
                                   then if x2 is (_ :: x6) then 
                                        Ffix0 x6 x4 else None
                                   else if x2 is (x4 :: _) then 
                                        Some x4 else None) x
                                  ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                        nat :=
                                      if x2 is (S x4)
                                      then if x3 is 
                                           (S x5) then 
                                           Ffix0 x4 x5 else x2 else x2) n x0)
                             is (Some x2)
                             then (fix Ffix0
                                     (x3 x4 : nat) (x5 : term) {struct x5} :
                                       term :=
                                     match x5 with
                                     | tRel n0 =>
                                         tRel
                                           (if
                                             (fix Ffix1
                                                (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                if x6 is 
                                                (S x8)
                                                then 
                                                if x7 is 
                                                (S x9) then 
                                                Ffix1 x8 x9 else false
                                                else true) x4 n0
                                            then
                                             (fix Ffix1
                                                (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                if x6 is 
                                                (S x8) then 
                                                S (Ffix1 x8 x7) else x7) x3
                                               n0
                                            else n0)
                                     | tEvar ev args =>
                                         tEvar ev
                                           ((fix Ffix1 
                                             (x6 : list term) : 
                                             list term :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               Ffix0 x3 x4 x7 :: 
                                               Ffix1 x8 else []) args)
                                     | tCast t kind v =>
                                         tCast (Ffix0 x3 x4 t) kind
                                           (Ffix0 x3 x4 v)
                                     | tProd na0 ty0 body0 =>
                                         tProd na0 
                                           (Ffix0 x3 x4 ty0)
                                           (Ffix0 x3 (S x4) body0)
                                     | tLambda na0 ty0 body0 =>
                                         tLambda na0 
                                           (Ffix0 x3 x4 ty0)
                                           (Ffix0 x3 (S x4) body0)
                                     | tLetIn na0 def def_ty body0 =>
                                         tLetIn na0 
                                           (Ffix0 x3 x4 def)
                                           (Ffix0 x3 x4 def_ty)
                                           (Ffix0 x3 (S x4) body0)
                                     | tApp f args =>
                                         tApp (Ffix0 x3 x4 f)
                                           ((fix Ffix1 
                                             (x6 : list term) : 
                                             list term :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               Ffix0 x3 x4 x7 :: 
                                               Ffix1 x8 else []) args)
                                     | tCase ind_and_nbparams type_info discr
                                       branches =>
                                         tCase ind_and_nbparams
                                           (Ffix0 x3 x4 type_info)
                                           (Ffix0 x3 x4 discr)
                                           ((fix Ffix1
                                               (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               (let (H, _) := x7 in H,
                                               Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                               :: 
                                               Ffix1 x8 else []) branches)
                                     | tProj proj t =>
                                         tProj proj (Ffix0 x3 x4 t)
                                     | tFix mfix idx =>
                                         tFix
                                           ((fix Ffix1
                                               (x6 : list (def term)) :
                                                 list (def term) :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               {|
                                               dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                               dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                               dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                               rarg := let 
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                               Ffix1 x8 else []) mfix) idx
                                     | tCoFix mfix idx =>
                                         tCoFix
                                           ((fix Ffix1
                                               (x6 : list (def term)) :
                                                 list (def term) :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               {|
                                               dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                               dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                               dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                               rarg := let 
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                               Ffix1 x8 else []) mfix) idx
                                     | _ => x5
                                     end) x0 0 x2
                             else tRel
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       ((fix Ffix0 (x2 : list term) : nat :=
                                           if x2 is 
                                           (_ :: x4) then 
                                           S (Ffix0 x4) else 0) x))
                            else tRel n
                        | tEvar ev args =>
                            tEvar ev
                              ((fix Ffix0 (x2 : list term) : list term :=
                                  if x2 is (x3 :: x4)
                                  then Ffix x x0 x3 :: Ffix0 x4 else []) args)
                        | tCast t kind v =>
                            tCast (Ffix x x0 t) kind (Ffix x x0 v)
                        | tProd na0 ty0 body0 =>
                            tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                        | tLambda na0 ty0 body0 =>
                            tLambda na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                        | tLetIn na0 def def_ty body0 =>
                            tLetIn na0 (Ffix x x0 def) 
                              (Ffix x x0 def_ty) (Ffix x (S x0) body0)
                        | tApp f args =>
                            if (fix Ffix0 (x2 : list term) : list term :=
                                  if x2 is (x3 :: x4)
                                  then Ffix x x0 x3 :: Ffix0 x4 else []) args
                            is [] then Ffix x x0 f
                            else if Ffix x x0 f is 
                                 (tApp f0 args0)
                                 then tApp f0
                                        ((fix Ffix0
                                            (x4 x5 : list term) {struct x4} :
                                              list term :=
                                            if x4 is 
                                            (x6 :: x7) then 
                                            x6 :: Ffix0 x7 x5 else x5) args0
                                           ((fix Ffix0 
                                             (x4 : list term) : 
                                             list term :=
                                               if x4 is 
                                               (x5 :: x6)
                                               then 
                                               Ffix x x0 x5 :: Ffix0 x6
                                               else []) args))
                                 else tApp (Ffix x x0 f)
                                        ((fix Ffix0 
                                          (x4 : list term) : 
                                          list term :=
                                            if x4 is 
                                            (x5 :: x6)
                                            then Ffix x x0 x5 :: Ffix0 x6
                                            else []) args)
                        | tCase ind_and_nbparams type_info discr branches =>
                            tCase ind_and_nbparams 
                              (Ffix x x0 type_info) 
                              (Ffix x x0 discr)
                              ((fix Ffix0 (x2 : list (nat × term)) :
                                    list (nat × term) :=
                                  if x2 is (x3 :: x4)
                                  then (let (H, _) := x3 in H,
                                       Ffix x x0 (let (_, H) := x3 in H))
                                       :: Ffix0 x4 else []) branches)
                        | tProj proj t => tProj proj (Ffix x x0 t)
                        | tFix mfix idx =>
                            tFix
                              ((fix Ffix0 (x2 : list (def term)) :
                                    list (def term) :=
                                  if x2 is (x3 :: x4)
                                  then {|
                                       dname := let (dname, _, _, _) := x3 in
                                                dname;
                                       dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                       dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                       rarg := let (_, _, _, rarg) := x3 in
                                               rarg |} :: 
                                       Ffix0 x4 else []) mfix) idx
                        | tCoFix mfix idx =>
                            tCoFix
                              ((fix Ffix0 (x2 : list (def term)) :
                                    list (def term) :=
                                  if x2 is (x3 :: x4)
                                  then {|
                                       dname := let (dname, _, _, _) := x3 in
                                                dname;
                                       dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                       dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                       rarg := let (_, _, _, rarg) := x3 in
                                               rarg |} :: 
                                       Ffix0 x4 else []) mfix) idx
                        | _ => x1
                        end) [tRel 0] 0 body
                   with
                   | tRel _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n0 =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0
                                 n0
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n0
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n1 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n1
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n1
                                              else n1)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2)
                                         n0
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n0
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tEvar _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev0 args0 =>
                                           tEvar ev0
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args0 =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev0 args0 =>
                              tEvar ev0
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args0 =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0 is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args1)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args1
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args0)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tCast _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t0 kind0 v0 =>
                                           tCast (Ffix0 x3 x4 t0) kind0
                                             (Ffix0 x3 x4 v0)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t0 =>
                                           tProj proj (Ffix0 x3 x4 t0)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t0 kind0 v0 =>
                              tCast (Ffix x x0 t0) kind0 (Ffix x x0 v0)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t0 => tProj proj (Ffix x x0 t0)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tProd _ _ _ | tLambda _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na1 ty1 body1 =>
                                           tProd na1 
                                             (Ffix0 x3 x4 ty1)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLambda na1 ty1 body1 =>
                                           tLambda na1 
                                             (Ffix0 x3 x4 ty1)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLetIn na1 def def_ty body1 =>
                                           tLetIn na1 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body1)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na1 ty1 body1 =>
                              tProd na1 (Ffix x x0 ty1) (Ffix x (S x0) body1)
                          | tLambda na1 ty1 body1 =>
                              tLambda na1 (Ffix x x0 ty1)
                                (Ffix x (S x0) body1)
                          | tLetIn na1 def def_ty body1 =>
                              tLetIn na1 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body1)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tLetIn _ _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na1 ty0 body1 =>
                                           tProd na1 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLambda na1 ty0 body1 =>
                                           tLambda na1 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLetIn na1 def def_ty0 body1 =>
                                           tLetIn na1 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty0)
                                             (Ffix0 x3 (S x4) body1)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na1 ty0 body1 =>
                              tProd na1 (Ffix x x0 ty0) (Ffix x (S x0) body1)
                          | tLambda na1 ty0 body1 =>
                              tLambda na1 (Ffix x x0 ty0)
                                (Ffix x (S x0) body1)
                          | tLetIn na1 def def_ty0 body1 =>
                              tLetIn na1 (Ffix x x0 def) 
                                (Ffix x x0 def_ty0) 
                                (Ffix x (S x0) body1)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tApp _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args0 =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f0 args0 =>
                                           tApp (Ffix0 x3 x4 f0)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args0 =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f0 args0 =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0 is [] then 
                              Ffix x x0 f0
                              else if Ffix x x0 f0 is 
                                   (tApp f1 args1)
                                   then tApp f1
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args1
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0))
                                   else tApp (Ffix x x0 f0)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args0)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tConstruct _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx0 =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx0
                                       | tCoFix mfix idx0 =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx0
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx0 =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx0
                          | tCoFix mfix idx0 =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx0
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tCase _ _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams0 type_info0
                                         discr0 branches0 =>
                                           tCase ind_and_nbparams0
                                             (Ffix0 x3 x4 type_info0)
                                             (Ffix0 x3 x4 discr0)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches0)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams0 type_info0 discr0
                            branches0 =>
                              tCase ind_and_nbparams0 
                                (Ffix x x0 type_info0) 
                                (Ffix x x0 discr0)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches0)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tProj _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t0 kind v =>
                                           tCast (Ffix0 x3 x4 t0) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj0 t0 =>
                                           tProj proj0 (Ffix0 x3 x4 t0)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t0 kind v =>
                              tCast (Ffix x x0 t0) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj0 t0 => tProj proj0 (Ffix x x0 t0)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tFix _ _ | tCoFix _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix0 idx0 =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix0)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix0)
                                             idx0
                                       | tCoFix mfix0 idx0 =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix0)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix0)
                                             idx0
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix0 idx0 =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix0)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix0) idx0
                          | tCoFix mfix0 idx0 =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix0)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix0) idx0
                          | _ => x1
                          end) [tRel 0] 0 body
                   | _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   end
               | tApp _ _ =>
                   if todo "tsl var" is (tApp f0 args0)
                   then tApp f0
                          ((fix Ffix (x x0 : list term) {struct x} :
                                list term :=
                              if x is (x1 :: x2) then 
                              x1 :: Ffix x2 x0 else x0) args0 [
                             tRel 0]) else tApp (todo "tsl var") [tRel 0]
               | _ =>
                   if todo "tsl var" is (tApp f args)
                   then tApp f
                          ((fix Ffix (x x0 : list term) {struct x} :
                                list term :=
                              if x is (x1 :: x2) then 
                              x1 :: Ffix x2 x0 else x0) args [
                             tRel 0]) else tApp (todo "tsl var") [tRel 0]
               end (tApp (tRel 0) [tApp (tRel 2) [tRel 1]])))
     : term
     = tLambda (nNamed "f") (tProd (nNamed "y") (tVar "Y") (tRel 1))
         (tProd (nNamed "y") (tVar "Y")
            (tProd (nNamed "yᵗ")
               match todo "tsl var" with
               | tEvar _ _ =>
                   if todo "tsl var" is (tApp f args0)
                   then tApp f
                          ((fix Ffix (x x0 : list term) {struct x} :
                                list term :=
                              if x is (x1 :: x2) then 
                              x1 :: Ffix x2 x0 else x0) args0 [
                             tRel 0]) else tApp (todo "tsl var") [tRel 0]
               | tLambda _ _ body =>
                   match
                     (fix Ffix
                        (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                          term :=
                        match x1 with
                        | tRel n =>
                            if
                             (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                if x2 is (S x4)
                                then if x3 is (S x5) then 
                                     Ffix0 x4 x5 else false else true) x0 n
                            then
                             if (fix Ffix0
                                   (x2 : list term) (x3 : nat) {struct x3} :
                                     option term :=
                                   if x3 is (S x4)
                                   then if x2 is (_ :: x6) then 
                                        Ffix0 x6 x4 else None
                                   else if x2 is (x4 :: _) then 
                                        Some x4 else None) x
                                  ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                        nat :=
                                      if x2 is (S x4)
                                      then if x3 is 
                                           (S x5) then 
                                           Ffix0 x4 x5 else x2 else x2) n x0)
                             is (Some x2)
                             then (fix Ffix0
                                     (x3 x4 : nat) (x5 : term) {struct x5} :
                                       term :=
                                     match x5 with
                                     | tRel n0 =>
                                         tRel
                                           (if
                                             (fix Ffix1
                                                (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                if x6 is 
                                                (S x8)
                                                then 
                                                if x7 is 
                                                (S x9) then 
                                                Ffix1 x8 x9 else false
                                                else true) x4 n0
                                            then
                                             (fix Ffix1
                                                (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                if x6 is 
                                                (S x8) then 
                                                S (Ffix1 x8 x7) else x7) x3
                                               n0
                                            else n0)
                                     | tEvar ev args =>
                                         tEvar ev
                                           ((fix Ffix1 
                                             (x6 : list term) : 
                                             list term :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               Ffix0 x3 x4 x7 :: 
                                               Ffix1 x8 else []) args)
                                     | tCast t kind v =>
                                         tCast (Ffix0 x3 x4 t) kind
                                           (Ffix0 x3 x4 v)
                                     | tProd na0 ty0 body0 =>
                                         tProd na0 
                                           (Ffix0 x3 x4 ty0)
                                           (Ffix0 x3 (S x4) body0)
                                     | tLambda na0 ty0 body0 =>
                                         tLambda na0 
                                           (Ffix0 x3 x4 ty0)
                                           (Ffix0 x3 (S x4) body0)
                                     | tLetIn na0 def def_ty body0 =>
                                         tLetIn na0 
                                           (Ffix0 x3 x4 def)
                                           (Ffix0 x3 x4 def_ty)
                                           (Ffix0 x3 (S x4) body0)
                                     | tApp f args =>
                                         tApp (Ffix0 x3 x4 f)
                                           ((fix Ffix1 
                                             (x6 : list term) : 
                                             list term :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               Ffix0 x3 x4 x7 :: 
                                               Ffix1 x8 else []) args)
                                     | tCase ind_and_nbparams type_info discr
                                       branches =>
                                         tCase ind_and_nbparams
                                           (Ffix0 x3 x4 type_info)
                                           (Ffix0 x3 x4 discr)
                                           ((fix Ffix1
                                               (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               (let (H, _) := x7 in H,
                                               Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                               :: 
                                               Ffix1 x8 else []) branches)
                                     | tProj proj t =>
                                         tProj proj (Ffix0 x3 x4 t)
                                     | tFix mfix idx =>
                                         tFix
                                           ((fix Ffix1
                                               (x6 : list (def term)) :
                                                 list (def term) :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               {|
                                               dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                               dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                               dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                               rarg := let 
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                               Ffix1 x8 else []) mfix) idx
                                     | tCoFix mfix idx =>
                                         tCoFix
                                           ((fix Ffix1
                                               (x6 : list (def term)) :
                                                 list (def term) :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               {|
                                               dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                               dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                               dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                               rarg := let 
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                               Ffix1 x8 else []) mfix) idx
                                     | _ => x5
                                     end) x0 0 x2
                             else tRel
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       ((fix Ffix0 (x2 : list term) : nat :=
                                           if x2 is 
                                           (_ :: x4) then 
                                           S (Ffix0 x4) else 0) x))
                            else tRel n
                        | tEvar ev args =>
                            tEvar ev
                              ((fix Ffix0 (x2 : list term) : list term :=
                                  if x2 is (x3 :: x4)
                                  then Ffix x x0 x3 :: Ffix0 x4 else []) args)
                        | tCast t kind v =>
                            tCast (Ffix x x0 t) kind (Ffix x x0 v)
                        | tProd na0 ty0 body0 =>
                            tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                        | tLambda na0 ty0 body0 =>
                            tLambda na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                        | tLetIn na0 def def_ty body0 =>
                            tLetIn na0 (Ffix x x0 def) 
                              (Ffix x x0 def_ty) (Ffix x (S x0) body0)
                        | tApp f args =>
                            if (fix Ffix0 (x2 : list term) : list term :=
                                  if x2 is (x3 :: x4)
                                  then Ffix x x0 x3 :: Ffix0 x4 else []) args
                            is [] then Ffix x x0 f
                            else if Ffix x x0 f is 
                                 (tApp f0 args0)
                                 then tApp f0
                                        ((fix Ffix0
                                            (x4 x5 : list term) {struct x4} :
                                              list term :=
                                            if x4 is 
                                            (x6 :: x7) then 
                                            x6 :: Ffix0 x7 x5 else x5) args0
                                           ((fix Ffix0 
                                             (x4 : list term) : 
                                             list term :=
                                               if x4 is 
                                               (x5 :: x6)
                                               then 
                                               Ffix x x0 x5 :: Ffix0 x6
                                               else []) args))
                                 else tApp (Ffix x x0 f)
                                        ((fix Ffix0 
                                          (x4 : list term) : 
                                          list term :=
                                            if x4 is 
                                            (x5 :: x6)
                                            then Ffix x x0 x5 :: Ffix0 x6
                                            else []) args)
                        | tCase ind_and_nbparams type_info discr branches =>
                            tCase ind_and_nbparams 
                              (Ffix x x0 type_info) 
                              (Ffix x x0 discr)
                              ((fix Ffix0 (x2 : list (nat × term)) :
                                    list (nat × term) :=
                                  if x2 is (x3 :: x4)
                                  then (let (H, _) := x3 in H,
                                       Ffix x x0 (let (_, H) := x3 in H))
                                       :: Ffix0 x4 else []) branches)
                        | tProj proj t => tProj proj (Ffix x x0 t)
                        | tFix mfix idx =>
                            tFix
                              ((fix Ffix0 (x2 : list (def term)) :
                                    list (def term) :=
                                  if x2 is (x3 :: x4)
                                  then {|
                                       dname := let (dname, _, _, _) := x3 in
                                                dname;
                                       dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                       dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                       rarg := let (_, _, _, rarg) := x3 in
                                               rarg |} :: 
                                       Ffix0 x4 else []) mfix) idx
                        | tCoFix mfix idx =>
                            tCoFix
                              ((fix Ffix0 (x2 : list (def term)) :
                                    list (def term) :=
                                  if x2 is (x3 :: x4)
                                  then {|
                                       dname := let (dname, _, _, _) := x3 in
                                                dname;
                                       dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                       dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                       rarg := let (_, _, _, rarg) := x3 in
                                               rarg |} :: 
                                       Ffix0 x4 else []) mfix) idx
                        | _ => x1
                        end) [tRel 0] 0 body
                   with
                   | tRel _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n0 =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0
                                 n0
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n0
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n1 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n1
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n1
                                              else n1)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2)
                                         n0
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n0
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tEvar _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev0 args0 =>
                                           tEvar ev0
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args0 =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev0 args0 =>
                              tEvar ev0
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args0 =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0 is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args1)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args1
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args0)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tCast _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t0 kind0 v0 =>
                                           tCast (Ffix0 x3 x4 t0) kind0
                                             (Ffix0 x3 x4 v0)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t0 =>
                                           tProj proj (Ffix0 x3 x4 t0)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t0 kind0 v0 =>
                              tCast (Ffix x x0 t0) kind0 (Ffix x x0 v0)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t0 => tProj proj (Ffix x x0 t0)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tProd _ _ _ | tLambda _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na1 ty1 body1 =>
                                           tProd na1 
                                             (Ffix0 x3 x4 ty1)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLambda na1 ty1 body1 =>
                                           tLambda na1 
                                             (Ffix0 x3 x4 ty1)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLetIn na1 def def_ty body1 =>
                                           tLetIn na1 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body1)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na1 ty1 body1 =>
                              tProd na1 (Ffix x x0 ty1) (Ffix x (S x0) body1)
                          | tLambda na1 ty1 body1 =>
                              tLambda na1 (Ffix x x0 ty1)
                                (Ffix x (S x0) body1)
                          | tLetIn na1 def def_ty body1 =>
                              tLetIn na1 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body1)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tLetIn _ _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na1 ty0 body1 =>
                                           tProd na1 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLambda na1 ty0 body1 =>
                                           tLambda na1 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLetIn na1 def def_ty0 body1 =>
                                           tLetIn na1 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty0)
                                             (Ffix0 x3 (S x4) body1)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na1 ty0 body1 =>
                              tProd na1 (Ffix x x0 ty0) (Ffix x (S x0) body1)
                          | tLambda na1 ty0 body1 =>
                              tLambda na1 (Ffix x x0 ty0)
                                (Ffix x (S x0) body1)
                          | tLetIn na1 def def_ty0 body1 =>
                              tLetIn na1 (Ffix x x0 def) 
                                (Ffix x x0 def_ty0) 
                                (Ffix x (S x0) body1)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tApp _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args0 =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f0 args0 =>
                                           tApp (Ffix0 x3 x4 f0)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args0 =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f0 args0 =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0 is [] then 
                              Ffix x x0 f0
                              else if Ffix x x0 f0 is 
                                   (tApp f1 args1)
                                   then tApp f1
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args1
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0))
                                   else tApp (Ffix x x0 f0)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args0)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tConstruct _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx0 =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx0
                                       | tCoFix mfix idx0 =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx0
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx0 =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx0
                          | tCoFix mfix idx0 =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx0
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tCase _ _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams0 type_info0
                                         discr0 branches0 =>
                                           tCase ind_and_nbparams0
                                             (Ffix0 x3 x4 type_info0)
                                             (Ffix0 x3 x4 discr0)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches0)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams0 type_info0 discr0
                            branches0 =>
                              tCase ind_and_nbparams0 
                                (Ffix x x0 type_info0) 
                                (Ffix x x0 discr0)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches0)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tProj _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t0 kind v =>
                                           tCast (Ffix0 x3 x4 t0) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj0 t0 =>
                                           tProj proj0 (Ffix0 x3 x4 t0)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t0 kind v =>
                              tCast (Ffix x x0 t0) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj0 t0 => tProj proj0 (Ffix x x0 t0)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tFix _ _ | tCoFix _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix0 idx0 =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix0)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix0)
                                             idx0
                                       | tCoFix mfix0 idx0 =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix0)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix0)
                                             idx0
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix0 idx0 =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix0)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix0) idx0
                          | tCoFix mfix0 idx0 =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix0)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix0) idx0
                          | _ => x1
                          end) [tRel 0] 0 body
                   | _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   end
               | tApp _ _ =>
                   if todo "tsl var" is (tApp f0 args0)
                   then tApp f0
                          ((fix Ffix (x x0 : list term) {struct x} :
                                list term :=
                              if x is (x1 :: x2) then 
                              x1 :: Ffix x2 x0 else x0) args0 [
                             tRel 0]) else tApp (todo "tsl var") [tRel 0]
               | _ =>
                   if todo "tsl var" is (tApp f args)
                   then tApp f
                          ((fix Ffix (x x0 : list term) {struct x} :
                                list term :=
                              if x is (x1 :: x2) then 
                              x1 :: Ffix x2 x0 else x0) args [
                             tRel 0]) else tApp (todo "tsl var") [tRel 0]
               end (tApp (tRel 3) [tApp (tRel 2) [tRel 1]])))
     : term
     = tLambda (nNamed "f")
         (tProd (nNamed "x") (tRel 0) (tProd (nNamed "y") (tRel 1) (tRel 0)))
         (tProd (nNamed "x") (tRel 1)
            (tProd (nNamed "xᵗ") (tApp (tRel 2) [tRel 0])
               (tProd (nNamed "y") (tRel 3)
                  (tProd (nNamed "yᵗ") (tApp (tRel 4) [tRel 0])
                     (tApp (tRel 0) [tApp (tRel 4) [tRel 3; tRel 1]])))))
     : term
     = tLambda (nNamed "f")
         (tProd (nNamed "x") (tRel 0) (tProd (nNamed "y") (tRel 1) (tRel 1)))
         (tProd (nNamed "x") (tRel 1)
            (tProd (nNamed "xᵗ") (tApp (tRel 2) [tRel 0])
               (tProd (nNamed "y") (tRel 3)
                  (tProd (nNamed "yᵗ") (tApp (tRel 4) [tRel 0])
                     (tApp (tRel 2) [tApp (tRel 4) [tRel 3; tRel 1]])))))
     : term
     = tLambda (nNamed "f")
         (tProd (nNamed "x") (tVar "X")
            (tProd (nNamed "y") (tVar "Y") (tRel 0)))
         (tProd (nNamed "x") (tVar "X")
            (tProd (nNamed "xᵗ")
               match todo "tsl var" with
               | tEvar _ _ =>
                   if todo "tsl var" is (tApp f args0)
                   then tApp f
                          ((fix Ffix (x x0 : list term) {struct x} :
                                list term :=
                              if x is (x1 :: x2) then 
                              x1 :: Ffix x2 x0 else x0) args0 [
                             tRel 0]) else tApp (todo "tsl var") [tRel 0]
               | tLambda _ _ body =>
                   match
                     (fix Ffix
                        (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                          term :=
                        match x1 with
                        | tRel n =>
                            if
                             (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                if x2 is (S x4)
                                then if x3 is (S x5) then 
                                     Ffix0 x4 x5 else false else true) x0 n
                            then
                             if (fix Ffix0
                                   (x2 : list term) (x3 : nat) {struct x3} :
                                     option term :=
                                   if x3 is (S x4)
                                   then if x2 is (_ :: x6) then 
                                        Ffix0 x6 x4 else None
                                   else if x2 is (x4 :: _) then 
                                        Some x4 else None) x
                                  ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                        nat :=
                                      if x2 is (S x4)
                                      then if x3 is 
                                           (S x5) then 
                                           Ffix0 x4 x5 else x2 else x2) n x0)
                             is (Some x2)
                             then (fix Ffix0
                                     (x3 x4 : nat) (x5 : term) {struct x5} :
                                       term :=
                                     match x5 with
                                     | tRel n0 =>
                                         tRel
                                           (if
                                             (fix Ffix1
                                                (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                if x6 is 
                                                (S x8)
                                                then 
                                                if x7 is 
                                                (S x9) then 
                                                Ffix1 x8 x9 else false
                                                else true) x4 n0
                                            then
                                             (fix Ffix1
                                                (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                if x6 is 
                                                (S x8) then 
                                                S (Ffix1 x8 x7) else x7) x3
                                               n0
                                            else n0)
                                     | tEvar ev args =>
                                         tEvar ev
                                           ((fix Ffix1 
                                             (x6 : list term) : 
                                             list term :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               Ffix0 x3 x4 x7 :: 
                                               Ffix1 x8 else []) args)
                                     | tCast t kind v =>
                                         tCast (Ffix0 x3 x4 t) kind
                                           (Ffix0 x3 x4 v)
                                     | tProd na0 ty0 body0 =>
                                         tProd na0 
                                           (Ffix0 x3 x4 ty0)
                                           (Ffix0 x3 (S x4) body0)
                                     | tLambda na0 ty0 body0 =>
                                         tLambda na0 
                                           (Ffix0 x3 x4 ty0)
                                           (Ffix0 x3 (S x4) body0)
                                     | tLetIn na0 def def_ty body0 =>
                                         tLetIn na0 
                                           (Ffix0 x3 x4 def)
                                           (Ffix0 x3 x4 def_ty)
                                           (Ffix0 x3 (S x4) body0)
                                     | tApp f args =>
                                         tApp (Ffix0 x3 x4 f)
                                           ((fix Ffix1 
                                             (x6 : list term) : 
                                             list term :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               Ffix0 x3 x4 x7 :: 
                                               Ffix1 x8 else []) args)
                                     | tCase ind_and_nbparams type_info discr
                                       branches =>
                                         tCase ind_and_nbparams
                                           (Ffix0 x3 x4 type_info)
                                           (Ffix0 x3 x4 discr)
                                           ((fix Ffix1
                                               (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               (let (H, _) := x7 in H,
                                               Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                               :: 
                                               Ffix1 x8 else []) branches)
                                     | tProj proj t =>
                                         tProj proj (Ffix0 x3 x4 t)
                                     | tFix mfix idx =>
                                         tFix
                                           ((fix Ffix1
                                               (x6 : list (def term)) :
                                                 list (def term) :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               {|
                                               dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                               dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                               dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                               rarg := let 
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                               Ffix1 x8 else []) mfix) idx
                                     | tCoFix mfix idx =>
                                         tCoFix
                                           ((fix Ffix1
                                               (x6 : list (def term)) :
                                                 list (def term) :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               {|
                                               dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                               dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                               dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                               rarg := let 
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                               Ffix1 x8 else []) mfix) idx
                                     | _ => x5
                                     end) x0 0 x2
                             else tRel
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       ((fix Ffix0 (x2 : list term) : nat :=
                                           if x2 is 
                                           (_ :: x4) then 
                                           S (Ffix0 x4) else 0) x))
                            else tRel n
                        | tEvar ev args =>
                            tEvar ev
                              ((fix Ffix0 (x2 : list term) : list term :=
                                  if x2 is (x3 :: x4)
                                  then Ffix x x0 x3 :: Ffix0 x4 else []) args)
                        | tCast t kind v =>
                            tCast (Ffix x x0 t) kind (Ffix x x0 v)
                        | tProd na0 ty0 body0 =>
                            tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                        | tLambda na0 ty0 body0 =>
                            tLambda na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                        | tLetIn na0 def def_ty body0 =>
                            tLetIn na0 (Ffix x x0 def) 
                              (Ffix x x0 def_ty) (Ffix x (S x0) body0)
                        | tApp f args =>
                            if (fix Ffix0 (x2 : list term) : list term :=
                                  if x2 is (x3 :: x4)
                                  then Ffix x x0 x3 :: Ffix0 x4 else []) args
                            is [] then Ffix x x0 f
                            else if Ffix x x0 f is 
                                 (tApp f0 args0)
                                 then tApp f0
                                        ((fix Ffix0
                                            (x4 x5 : list term) {struct x4} :
                                              list term :=
                                            if x4 is 
                                            (x6 :: x7) then 
                                            x6 :: Ffix0 x7 x5 else x5) args0
                                           ((fix Ffix0 
                                             (x4 : list term) : 
                                             list term :=
                                               if x4 is 
                                               (x5 :: x6)
                                               then 
                                               Ffix x x0 x5 :: Ffix0 x6
                                               else []) args))
                                 else tApp (Ffix x x0 f)
                                        ((fix Ffix0 
                                          (x4 : list term) : 
                                          list term :=
                                            if x4 is 
                                            (x5 :: x6)
                                            then Ffix x x0 x5 :: Ffix0 x6
                                            else []) args)
                        | tCase ind_and_nbparams type_info discr branches =>
                            tCase ind_and_nbparams 
                              (Ffix x x0 type_info) 
                              (Ffix x x0 discr)
                              ((fix Ffix0 (x2 : list (nat × term)) :
                                    list (nat × term) :=
                                  if x2 is (x3 :: x4)
                                  then (let (H, _) := x3 in H,
                                       Ffix x x0 (let (_, H) := x3 in H))
                                       :: Ffix0 x4 else []) branches)
                        | tProj proj t => tProj proj (Ffix x x0 t)
                        | tFix mfix idx =>
                            tFix
                              ((fix Ffix0 (x2 : list (def term)) :
                                    list (def term) :=
                                  if x2 is (x3 :: x4)
                                  then {|
                                       dname := let (dname, _, _, _) := x3 in
                                                dname;
                                       dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                       dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                       rarg := let (_, _, _, rarg) := x3 in
                                               rarg |} :: 
                                       Ffix0 x4 else []) mfix) idx
                        | tCoFix mfix idx =>
                            tCoFix
                              ((fix Ffix0 (x2 : list (def term)) :
                                    list (def term) :=
                                  if x2 is (x3 :: x4)
                                  then {|
                                       dname := let (dname, _, _, _) := x3 in
                                                dname;
                                       dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                       dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                       rarg := let (_, _, _, rarg) := x3 in
                                               rarg |} :: 
                                       Ffix0 x4 else []) mfix) idx
                        | _ => x1
                        end) [tRel 0] 0 body
                   with
                   | tRel _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n0 =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0
                                 n0
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n0
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n1 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n1
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n1
                                              else n1)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2)
                                         n0
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n0
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tEvar _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev0 args0 =>
                                           tEvar ev0
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args0 =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev0 args0 =>
                              tEvar ev0
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args0 =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0 is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args1)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args1
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args0)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tCast _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t0 kind0 v0 =>
                                           tCast (Ffix0 x3 x4 t0) kind0
                                             (Ffix0 x3 x4 v0)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t0 =>
                                           tProj proj (Ffix0 x3 x4 t0)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t0 kind0 v0 =>
                              tCast (Ffix x x0 t0) kind0 (Ffix x x0 v0)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t0 => tProj proj (Ffix x x0 t0)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tProd _ _ _ | tLambda _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na1 ty1 body1 =>
                                           tProd na1 
                                             (Ffix0 x3 x4 ty1)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLambda na1 ty1 body1 =>
                                           tLambda na1 
                                             (Ffix0 x3 x4 ty1)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLetIn na1 def def_ty body1 =>
                                           tLetIn na1 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body1)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na1 ty1 body1 =>
                              tProd na1 (Ffix x x0 ty1) (Ffix x (S x0) body1)
                          | tLambda na1 ty1 body1 =>
                              tLambda na1 (Ffix x x0 ty1)
                                (Ffix x (S x0) body1)
                          | tLetIn na1 def def_ty body1 =>
                              tLetIn na1 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body1)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tLetIn _ _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na1 ty0 body1 =>
                                           tProd na1 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLambda na1 ty0 body1 =>
                                           tLambda na1 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLetIn na1 def def_ty0 body1 =>
                                           tLetIn na1 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty0)
                                             (Ffix0 x3 (S x4) body1)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na1 ty0 body1 =>
                              tProd na1 (Ffix x x0 ty0) (Ffix x (S x0) body1)
                          | tLambda na1 ty0 body1 =>
                              tLambda na1 (Ffix x x0 ty0)
                                (Ffix x (S x0) body1)
                          | tLetIn na1 def def_ty0 body1 =>
                              tLetIn na1 (Ffix x x0 def) 
                                (Ffix x x0 def_ty0) 
                                (Ffix x (S x0) body1)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tApp _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args0 =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f0 args0 =>
                                           tApp (Ffix0 x3 x4 f0)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args0 =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f0 args0 =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0 is [] then 
                              Ffix x x0 f0
                              else if Ffix x x0 f0 is 
                                   (tApp f1 args1)
                                   then tApp f1
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args1
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0))
                                   else tApp (Ffix x x0 f0)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args0)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tConstruct _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx0 =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx0
                                       | tCoFix mfix idx0 =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx0
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx0 =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx0
                          | tCoFix mfix idx0 =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx0
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tCase _ _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams0 type_info0
                                         discr0 branches0 =>
                                           tCase ind_and_nbparams0
                                             (Ffix0 x3 x4 type_info0)
                                             (Ffix0 x3 x4 discr0)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches0)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams0 type_info0 discr0
                            branches0 =>
                              tCase ind_and_nbparams0 
                                (Ffix x x0 type_info0) 
                                (Ffix x x0 discr0)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches0)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tProj _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t0 kind v =>
                                           tCast (Ffix0 x3 x4 t0) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj0 t0 =>
                                           tProj proj0 (Ffix0 x3 x4 t0)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t0 kind v =>
                              tCast (Ffix x x0 t0) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj0 t0 => tProj proj0 (Ffix x x0 t0)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tFix _ _ | tCoFix _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix0 idx0 =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix0)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix0)
                                             idx0
                                       | tCoFix mfix0 idx0 =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix0)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix0)
                                             idx0
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix0 idx0 =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix0)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix0) idx0
                          | tCoFix mfix0 idx0 =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix0)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix0) idx0
                          | _ => x1
                          end) [tRel 0] 0 body
                   | _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   end
               | tApp _ _ =>
                   if todo "tsl var" is (tApp f0 args0)
                   then tApp f0
                          ((fix Ffix (x x0 : list term) {struct x} :
                                list term :=
                              if x is (x1 :: x2) then 
                              x1 :: Ffix x2 x0 else x0) args0 [
                             tRel 0]) else tApp (todo "tsl var") [tRel 0]
               | _ =>
                   if todo "tsl var" is (tApp f args)
                   then tApp f
                          ((fix Ffix (x x0 : list term) {struct x} :
                                list term :=
                              if x is (x1 :: x2) then 
                              x1 :: Ffix x2 x0 else x0) args [
                             tRel 0]) else tApp (todo "tsl var") [tRel 0]
               end
               (tProd (nNamed "y") (tVar "Y")
                  (tProd (nNamed "yᵗ")
                     ((fix Ffix
                         (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                           term :=
                         match x1 with
                         | tRel n =>
                             if
                              (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                 if x2 is (S x4)
                                 then if x3 is (S x5) then 
                                      Ffix0 x4 x5 else false else true) x0 n
                             then
                              if (fix Ffix0
                                    (x2 : list term) (x3 : nat) {struct x3} :
                                      option term :=
                                    if x3 is (S x4)
                                    then if x2 is 
                                         (_ :: x6) then 
                                         Ffix0 x6 x4 else None
                                    else if x2 is 
                                         (x4 :: _) then 
                                         Some x4 else None) x
                                   ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                         nat :=
                                       if x2 is (S x4)
                                       then if x3 is 
                                            (S x5) then 
                                            Ffix0 x4 x5 else x2 else x2) n x0)
                              is (Some x2)
                              then (fix Ffix0
                                      (x3 x4 : nat) (x5 : term) {struct x5} :
                                        term :=
                                      match x5 with
                                      | tRel n0 =>
                                          tRel
                                            (if
                                              (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                             then
                                              (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                n0
                                             else n0)
                                      | tEvar ev args =>
                                          tEvar ev
                                            ((fix Ffix1 
                                              (x6 : list term) : 
                                              list term :=
                                                if x6 is 
                                                (x7 :: x8)
                                                then 
                                                Ffix0 x3 x4 x7 :: 
                                                Ffix1 x8 else []) args)
                                      | tCast t kind v =>
                                          tCast (Ffix0 x3 x4 t) kind
                                            (Ffix0 x3 x4 v)
                                      | tProd na ty body =>
                                          tProd na 
                                            (Ffix0 x3 x4 ty)
                                            (Ffix0 x3 (S x4) body)
                                      | tLambda na ty body =>
                                          tLambda na 
                                            (Ffix0 x3 x4 ty)
                                            (Ffix0 x3 (S x4) body)
                                      | tLetIn na def def_ty body =>
                                          tLetIn na 
                                            (Ffix0 x3 x4 def)
                                            (Ffix0 x3 x4 def_ty)
                                            (Ffix0 x3 (S x4) body)
                                      | tApp f args =>
                                          tApp (Ffix0 x3 x4 f)
                                            ((fix Ffix1 
                                              (x6 : list term) : 
                                              list term :=
                                                if x6 is 
                                                (x7 :: x8)
                                                then 
                                                Ffix0 x3 x4 x7 :: 
                                                Ffix1 x8 else []) args)
                                      | tCase ind_and_nbparams type_info
                                        discr branches =>
                                          tCase ind_and_nbparams
                                            (Ffix0 x3 x4 type_info)
                                            (Ffix0 x3 x4 discr)
                                            ((fix Ffix1
                                                (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                if x6 is 
                                                (x7 :: x8)
                                                then 
                                                (let (H, _) := x7 in H,
                                                Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                :: 
                                                Ffix1 x8 else []) branches)
                                      | tProj proj t =>
                                          tProj proj (Ffix0 x3 x4 t)
                                      | tFix mfix idx =>
                                          tFix
                                            ((fix Ffix1
                                                (x6 : list (def term)) :
                                                 list (def term) :=
                                                if x6 is 
                                                (x7 :: x8)
                                                then 
                                                {|
                                                dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                Ffix1 x8 else []) mfix) idx
                                      | tCoFix mfix idx =>
                                          tCoFix
                                            ((fix Ffix1
                                                (x6 : list (def term)) :
                                                 list (def term) :=
                                                if x6 is 
                                                (x7 :: x8)
                                                then 
                                                {|
                                                dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                Ffix1 x8 else []) mfix) idx
                                      | _ => x5
                                      end) x0 0 x2
                              else tRel
                                     ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                           nat :=
                                         if x2 is 
                                         (S x4)
                                         then if x3 is 
                                              (S x5) then 
                                              Ffix0 x4 x5 else x2 else x2) n
                                        ((fix Ffix0 (x2 : list term) : nat :=
                                            if x2 is 
                                            (_ :: x4) then 
                                            S (Ffix0 x4) else 0) x))
                             else tRel n
                         | tEvar ev args =>
                             tEvar ev
                               ((fix Ffix0 (x2 : list term) : list term :=
                                   if x2 is (x3 :: x4)
                                   then Ffix x x0 x3 :: Ffix0 x4 else [])
                                  args)
                         | tCast t kind v =>
                             tCast (Ffix x x0 t) kind (Ffix x x0 v)
                         | tProd na ty body =>
                             tProd na (Ffix x x0 ty) (Ffix x (S x0) body)
                         | tLambda na ty body =>
                             tLambda na (Ffix x x0 ty) (Ffix x (S x0) body)
                         | tLetIn na def def_ty body =>
                             tLetIn na (Ffix x x0 def) 
                               (Ffix x x0 def_ty) 
                               (Ffix x (S x0) body)
                         | tApp f args =>
                             if (fix Ffix0 (x2 : list term) : list term :=
                                   if x2 is (x3 :: x4)
                                   then Ffix x x0 x3 :: Ffix0 x4 else [])
                                  args is [] then 
                             Ffix x x0 f
                             else if Ffix x x0 f is 
                                  (tApp f0 args0)
                                  then tApp f0
                                         ((fix Ffix0
                                             (x4 x5 : list term) {struct x4} :
                                               list term :=
                                             if x4 is 
                                             (x6 :: x7)
                                             then 
                                             x6 :: Ffix0 x7 x5 else x5) args0
                                            ((fix Ffix0 
                                              (x4 : list term) : 
                                              list term :=
                                                if x4 is 
                                                (x5 :: x6)
                                                then 
                                                Ffix x x0 x5 :: Ffix0 x6
                                                else []) args))
                                  else tApp (Ffix x x0 f)
                                         ((fix Ffix0 
                                           (x4 : list term) : 
                                           list term :=
                                             if x4 is 
                                             (x5 :: x6)
                                             then 
                                             Ffix x x0 x5 :: Ffix0 x6 else [])
                                            args)
                         | tCase ind_and_nbparams type_info discr branches =>
                             tCase ind_and_nbparams 
                               (Ffix x x0 type_info) 
                               (Ffix x x0 discr)
                               ((fix Ffix0 (x2 : list (nat × term)) :
                                     list (nat × term) :=
                                   if x2 is (x3 :: x4)
                                   then (let (H, _) := x3 in H,
                                        Ffix x x0 (let (_, H) := x3 in H))
                                        :: Ffix0 x4 else []) branches)
                         | tProj proj t => tProj proj (Ffix x x0 t)
                         | tFix mfix idx =>
                             tFix
                               ((fix Ffix0 (x2 : list (def term)) :
                                     list (def term) :=
                                   if x2 is (x3 :: x4)
                                   then {|
                                        dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                        dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                        dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                        rarg := let (_, _, _, rarg) := x3 in
                                                rarg |} :: 
                                        Ffix0 x4 else []) mfix) idx
                         | tCoFix mfix idx =>
                             tCoFix
                               ((fix Ffix0 (x2 : list (def term)) :
                                     list (def term) :=
                                   if x2 is (x3 :: x4)
                                   then {|
                                        dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                        dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                        dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                        rarg := let (_, _, _, rarg) := x3 in
                                                rarg |} :: 
                                        Ffix0 x4 else []) mfix) idx
                         | _ => x1
                         end) [tApp (tRel 2) [tRel 1]] 1
                        match todo "tsl var" with
                        | tEvar _ _ =>
                            if todo "tsl var" is (tApp f args0)
                            then tApp f
                                   ((fix Ffix (x x0 : list term) {struct x} :
                                         list term :=
                                       if x is (x1 :: x2)
                                       then x1 :: Ffix x2 x0 else x0) args0
                                      [tRel 0])
                            else tApp (todo "tsl var") [tRel 0]
                        | tLambda _ _ body =>
                            match
                              (fix Ffix
                                 (x : list term) (x0 : nat) 
                                 (x1 : term) {struct x1} : term :=
                                 match x1 with
                                 | tRel n =>
                                     if
                                      (fix Ffix0 (x2 x3 : nat) {struct x2} :
                                           bool :=
                                         if x2 is 
                                         (S x4)
                                         then if x3 is 
                                              (S x5) then 
                                              Ffix0 x4 x5 else false
                                         else true) x0 n
                                     then
                                      if (fix Ffix0
                                            (x2 : list term) 
                                            (x3 : nat) {struct x3} :
                                              option term :=
                                            if x3 is 
                                            (S x4)
                                            then if x2 is 
                                                 (_ :: x6) then 
                                                 Ffix0 x6 x4 else None
                                            else if x2 is 
                                                 (x4 :: _) then 
                                                 Some x4 else None) x
                                           ((fix Ffix0
                                               (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                               if x2 is 
                                               (S x4)
                                               then 
                                               if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                              x0) is 
                                      (Some x2)
                                      then (fix Ffix0
                                              (x3 x4 : nat) 
                                              (x5 : term) {struct x5} :
                                                term :=
                                              match x5 with
                                              | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                              | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                              | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                              | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                              | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                              | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                              | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                              | tCase ind_and_nbparams
                                                type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                              | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                              | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11) then 
                                                 S (...) else x10)
                                                 ((fix Ffix2 ... : nat :=
                                                 if x9 is ... then ... else 0)
                                                 mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                              | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11) then 
                                                 S (...) else x10)
                                                 ((fix Ffix2 ... : nat :=
                                                 if x9 is ... then ... else 0)
                                                 mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                              | _ => x5
                                              end) x0 0 x2
                                      else tRel
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n
                                                ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                     else tRel n
                                 | tEvar ev args =>
                                     tEvar ev
                                       ((fix Ffix0 
                                         (x2 : list term) : 
                                         list term :=
                                           if x2 is 
                                           (x3 :: x4)
                                           then Ffix x x0 x3 :: Ffix0 x4
                                           else []) args)
                                 | tCast t kind v =>
                                     tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                 | tProd na0 ty0 body0 =>
                                     tProd na0 (Ffix x x0 ty0)
                                       (Ffix x (S x0) body0)
                                 | tLambda na0 ty0 body0 =>
                                     tLambda na0 (Ffix x x0 ty0)
                                       (Ffix x (S x0) body0)
                                 | tLetIn na0 def def_ty body0 =>
                                     tLetIn na0 (Ffix x x0 def)
                                       (Ffix x x0 def_ty)
                                       (Ffix x (S x0) body0)
                                 | tApp f args =>
                                     if (fix Ffix0 
                                         (x2 : list term) : 
                                         list term :=
                                           if x2 is 
                                           (x3 :: x4)
                                           then Ffix x x0 x3 :: Ffix0 x4
                                           else []) args is []
                                     then Ffix x x0 f
                                     else if Ffix x x0 f is 
                                          (tApp f0 args0)
                                          then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                          else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                 | tCase ind_and_nbparams type_info discr
                                   branches =>
                                     tCase ind_and_nbparams
                                       (Ffix x x0 type_info)
                                       (Ffix x x0 discr)
                                       ((fix Ffix0 
                                         (x2 : list (nat × term)) :
                                             list (nat × term) :=
                                           if x2 is 
                                           (x3 :: x4)
                                           then (let (H, _) := x3 in H,
                                                Ffix x x0
                                                 (let (_, H) := x3 in H))
                                                :: 
                                                Ffix0 x4 else []) branches)
                                 | tProj proj t => tProj proj (Ffix x x0 t)
                                 | tFix mfix idx =>
                                     tFix
                                       ((fix Ffix0 
                                         (x2 : list (def term)) :
                                             list (def term) :=
                                           if x2 is 
                                           (x3 :: x4)
                                           then {|
                                                dname := let
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                                dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                                dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                                rarg := let
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                                Ffix0 x4 else []) mfix) idx
                                 | tCoFix mfix idx =>
                                     tCoFix
                                       ((fix Ffix0 
                                         (x2 : list (def term)) :
                                             list (def term) :=
                                           if x2 is 
                                           (x3 :: x4)
                                           then {|
                                                dname := let
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                                dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                                dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                                rarg := let
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                                Ffix0 x4 else []) mfix) idx
                                 | _ => x1
                                 end) [tRel 0] 0 body
                            with
                            | tRel _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n0 =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n0
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n0 x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n1 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n1
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n1
                                                 else n1)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n0
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n0
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tEvar _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev0 args0 =>
                                                 tEvar ev0
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args0 =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev0 args0 =>
                                       tEvar ev0
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args0)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args0 =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args0 is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args1)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args1
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tCast _ _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t0 kind0 v0 =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t0) kind0
                                                 (Ffix0 x3 x4 v0)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t0 =>
                                                 tProj proj (Ffix0 x3 x4 t0)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t0 kind0 v0 =>
                                       tCast (Ffix x x0 t0) kind0
                                         (Ffix x x0 v0)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t0 =>
                                       tProj proj (Ffix x x0 t0)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tProd _ _ _ | tLambda _ _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na1 ty1 body1 =>
                                                 tProd na1 
                                                 (Ffix0 x3 x4 ty1)
                                                 (Ffix0 x3 (S x4) body1)
                                                | tLambda na1 ty1 body1 =>
                                                 tLambda na1
                                                 (Ffix0 x3 x4 ty1)
                                                 (Ffix0 x3 (S x4) body1)
                                                | tLetIn na1 def def_ty body1 =>
                                                 tLetIn na1 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body1)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na1 ty1 body1 =>
                                       tProd na1 (Ffix x x0 ty1)
                                         (Ffix x (S x0) body1)
                                   | tLambda na1 ty1 body1 =>
                                       tLambda na1 
                                         (Ffix x x0 ty1)
                                         (Ffix x (S x0) body1)
                                   | tLetIn na1 def def_ty body1 =>
                                       tLetIn na1 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body1)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tLetIn _ _ _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na1 ty0 body1 =>
                                                 tProd na1 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body1)
                                                | tLambda na1 ty0 body1 =>
                                                 tLambda na1
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body1)
                                                | tLetIn na1 def def_ty0
                                                 body1 =>
                                                 tLetIn na1 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty0)
                                                 (Ffix0 x3 (S x4) body1)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na1 ty0 body1 =>
                                       tProd na1 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body1)
                                   | tLambda na1 ty0 body1 =>
                                       tLambda na1 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body1)
                                   | tLetIn na1 def def_ty0 body1 =>
                                       tLetIn na1 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty0)
                                         (Ffix x (S x0) body1)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tApp _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args0 =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f0 args0 =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f0)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args0 =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args0)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f0 args0 =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args0 is [] then 
                                       Ffix x x0 f0
                                       else if Ffix x x0 f0
                                            is (tApp f1 args1)
                                            then tApp f1
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args1
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0))
                                            else tApp 
                                                 (Ffix x x0 f0)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tConstruct _ _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx0 =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx0
                                                | tCoFix mfix idx0 =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx0
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx0 =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx0
                                   | tCoFix mfix idx0 =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx0
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tCase _ _ _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams0
                                                 type_info0 discr0 branches0 =>
                                                 tCase ind_and_nbparams0
                                                 (Ffix0 x3 x4 type_info0)
                                                 (Ffix0 x3 x4 discr0)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches0)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams0 type_info0
                                     discr0 branches0 =>
                                       tCase ind_and_nbparams0
                                         (Ffix x x0 type_info0)
                                         (Ffix x x0 discr0)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches0)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tProj _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t0 kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t0) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj0 t0 =>
                                                 tProj proj0 (Ffix0 x3 x4 t0)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t0 kind v =>
                                       tCast (Ffix x x0 t0) kind
                                         (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj0 t0 =>
                                       tProj proj0 (Ffix x x0 t0)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tFix _ _ | tCoFix _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix0 idx0 =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix0) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix0)
                                                 idx0
                                                | tCoFix mfix0 idx0 =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix0) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix0)
                                                 idx0
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix0 idx0 =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix0)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix0) idx0
                                   | tCoFix mfix0 idx0 =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix0)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix0) idx0
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            end
                        | tApp _ _ =>
                            if todo "tsl var" is (tApp f0 args0)
                            then tApp f0
                                   ((fix Ffix (x x0 : list term) {struct x} :
                                         list term :=
                                       if x is (x1 :: x2)
                                       then x1 :: Ffix x2 x0 else x0) args0
                                      [tRel 0])
                            else tApp (todo "tsl var") [tRel 0]
                        | _ =>
                            if todo "tsl var" is (tApp f args)
                            then tApp f
                                   ((fix Ffix (x x0 : list term) {struct x} :
                                         list term :=
                                       if x is (x1 :: x2)
                                       then x1 :: Ffix x2 x0 else x0) args
                                      [tRel 0])
                            else tApp (todo "tsl var") [tRel 0]
                        end) (tApp (tRel 0) [tApp (tRel 4) [tRel 3; tRel 1]])))))
     : term
     = tLambda (nNamed "f")
         (tProd (nNamed "x") (tVar "X")
            (tProd (nNamed "y") (tVar "Y") (tRel 1)))
         (tProd (nNamed "x") (tVar "X")
            (tProd (nNamed "xᵗ")
               match todo "tsl var" with
               | tEvar _ _ =>
                   if todo "tsl var" is (tApp f args0)
                   then tApp f
                          ((fix Ffix (x x0 : list term) {struct x} :
                                list term :=
                              if x is (x1 :: x2) then 
                              x1 :: Ffix x2 x0 else x0) args0 [
                             tRel 0]) else tApp (todo "tsl var") [tRel 0]
               | tLambda _ _ body =>
                   match
                     (fix Ffix
                        (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                          term :=
                        match x1 with
                        | tRel n =>
                            if
                             (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                if x2 is (S x4)
                                then if x3 is (S x5) then 
                                     Ffix0 x4 x5 else false else true) x0 n
                            then
                             if (fix Ffix0
                                   (x2 : list term) (x3 : nat) {struct x3} :
                                     option term :=
                                   if x3 is (S x4)
                                   then if x2 is (_ :: x6) then 
                                        Ffix0 x6 x4 else None
                                   else if x2 is (x4 :: _) then 
                                        Some x4 else None) x
                                  ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                        nat :=
                                      if x2 is (S x4)
                                      then if x3 is 
                                           (S x5) then 
                                           Ffix0 x4 x5 else x2 else x2) n x0)
                             is (Some x2)
                             then (fix Ffix0
                                     (x3 x4 : nat) (x5 : term) {struct x5} :
                                       term :=
                                     match x5 with
                                     | tRel n0 =>
                                         tRel
                                           (if
                                             (fix Ffix1
                                                (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                if x6 is 
                                                (S x8)
                                                then 
                                                if x7 is 
                                                (S x9) then 
                                                Ffix1 x8 x9 else false
                                                else true) x4 n0
                                            then
                                             (fix Ffix1
                                                (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                if x6 is 
                                                (S x8) then 
                                                S (Ffix1 x8 x7) else x7) x3
                                               n0
                                            else n0)
                                     | tEvar ev args =>
                                         tEvar ev
                                           ((fix Ffix1 
                                             (x6 : list term) : 
                                             list term :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               Ffix0 x3 x4 x7 :: 
                                               Ffix1 x8 else []) args)
                                     | tCast t kind v =>
                                         tCast (Ffix0 x3 x4 t) kind
                                           (Ffix0 x3 x4 v)
                                     | tProd na0 ty0 body0 =>
                                         tProd na0 
                                           (Ffix0 x3 x4 ty0)
                                           (Ffix0 x3 (S x4) body0)
                                     | tLambda na0 ty0 body0 =>
                                         tLambda na0 
                                           (Ffix0 x3 x4 ty0)
                                           (Ffix0 x3 (S x4) body0)
                                     | tLetIn na0 def def_ty body0 =>
                                         tLetIn na0 
                                           (Ffix0 x3 x4 def)
                                           (Ffix0 x3 x4 def_ty)
                                           (Ffix0 x3 (S x4) body0)
                                     | tApp f args =>
                                         tApp (Ffix0 x3 x4 f)
                                           ((fix Ffix1 
                                             (x6 : list term) : 
                                             list term :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               Ffix0 x3 x4 x7 :: 
                                               Ffix1 x8 else []) args)
                                     | tCase ind_and_nbparams type_info discr
                                       branches =>
                                         tCase ind_and_nbparams
                                           (Ffix0 x3 x4 type_info)
                                           (Ffix0 x3 x4 discr)
                                           ((fix Ffix1
                                               (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               (let (H, _) := x7 in H,
                                               Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                               :: 
                                               Ffix1 x8 else []) branches)
                                     | tProj proj t =>
                                         tProj proj (Ffix0 x3 x4 t)
                                     | tFix mfix idx =>
                                         tFix
                                           ((fix Ffix1
                                               (x6 : list (def term)) :
                                                 list (def term) :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               {|
                                               dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                               dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                               dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                               rarg := let 
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                               Ffix1 x8 else []) mfix) idx
                                     | tCoFix mfix idx =>
                                         tCoFix
                                           ((fix Ffix1
                                               (x6 : list (def term)) :
                                                 list (def term) :=
                                               if x6 is 
                                               (x7 :: x8)
                                               then 
                                               {|
                                               dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                               dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                               dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                               rarg := let 
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                               Ffix1 x8 else []) mfix) idx
                                     | _ => x5
                                     end) x0 0 x2
                             else tRel
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       ((fix Ffix0 (x2 : list term) : nat :=
                                           if x2 is 
                                           (_ :: x4) then 
                                           S (Ffix0 x4) else 0) x))
                            else tRel n
                        | tEvar ev args =>
                            tEvar ev
                              ((fix Ffix0 (x2 : list term) : list term :=
                                  if x2 is (x3 :: x4)
                                  then Ffix x x0 x3 :: Ffix0 x4 else []) args)
                        | tCast t kind v =>
                            tCast (Ffix x x0 t) kind (Ffix x x0 v)
                        | tProd na0 ty0 body0 =>
                            tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                        | tLambda na0 ty0 body0 =>
                            tLambda na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                        | tLetIn na0 def def_ty body0 =>
                            tLetIn na0 (Ffix x x0 def) 
                              (Ffix x x0 def_ty) (Ffix x (S x0) body0)
                        | tApp f args =>
                            if (fix Ffix0 (x2 : list term) : list term :=
                                  if x2 is (x3 :: x4)
                                  then Ffix x x0 x3 :: Ffix0 x4 else []) args
                            is [] then Ffix x x0 f
                            else if Ffix x x0 f is 
                                 (tApp f0 args0)
                                 then tApp f0
                                        ((fix Ffix0
                                            (x4 x5 : list term) {struct x4} :
                                              list term :=
                                            if x4 is 
                                            (x6 :: x7) then 
                                            x6 :: Ffix0 x7 x5 else x5) args0
                                           ((fix Ffix0 
                                             (x4 : list term) : 
                                             list term :=
                                               if x4 is 
                                               (x5 :: x6)
                                               then 
                                               Ffix x x0 x5 :: Ffix0 x6
                                               else []) args))
                                 else tApp (Ffix x x0 f)
                                        ((fix Ffix0 
                                          (x4 : list term) : 
                                          list term :=
                                            if x4 is 
                                            (x5 :: x6)
                                            then Ffix x x0 x5 :: Ffix0 x6
                                            else []) args)
                        | tCase ind_and_nbparams type_info discr branches =>
                            tCase ind_and_nbparams 
                              (Ffix x x0 type_info) 
                              (Ffix x x0 discr)
                              ((fix Ffix0 (x2 : list (nat × term)) :
                                    list (nat × term) :=
                                  if x2 is (x3 :: x4)
                                  then (let (H, _) := x3 in H,
                                       Ffix x x0 (let (_, H) := x3 in H))
                                       :: Ffix0 x4 else []) branches)
                        | tProj proj t => tProj proj (Ffix x x0 t)
                        | tFix mfix idx =>
                            tFix
                              ((fix Ffix0 (x2 : list (def term)) :
                                    list (def term) :=
                                  if x2 is (x3 :: x4)
                                  then {|
                                       dname := let (dname, _, _, _) := x3 in
                                                dname;
                                       dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                       dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                       rarg := let (_, _, _, rarg) := x3 in
                                               rarg |} :: 
                                       Ffix0 x4 else []) mfix) idx
                        | tCoFix mfix idx =>
                            tCoFix
                              ((fix Ffix0 (x2 : list (def term)) :
                                    list (def term) :=
                                  if x2 is (x3 :: x4)
                                  then {|
                                       dname := let (dname, _, _, _) := x3 in
                                                dname;
                                       dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                       dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                       rarg := let (_, _, _, rarg) := x3 in
                                               rarg |} :: 
                                       Ffix0 x4 else []) mfix) idx
                        | _ => x1
                        end) [tRel 0] 0 body
                   with
                   | tRel _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n0 =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0
                                 n0
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n0
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n1 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n1
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n1
                                              else n1)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2)
                                         n0
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n0
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tEvar _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev0 args0 =>
                                           tEvar ev0
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args0 =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev0 args0 =>
                              tEvar ev0
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args0 =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0 is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args1)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args1
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args0)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tCast _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t0 kind0 v0 =>
                                           tCast (Ffix0 x3 x4 t0) kind0
                                             (Ffix0 x3 x4 v0)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t0 =>
                                           tProj proj (Ffix0 x3 x4 t0)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t0 kind0 v0 =>
                              tCast (Ffix x x0 t0) kind0 (Ffix x x0 v0)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t0 => tProj proj (Ffix x x0 t0)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tProd _ _ _ | tLambda _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na1 ty1 body1 =>
                                           tProd na1 
                                             (Ffix0 x3 x4 ty1)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLambda na1 ty1 body1 =>
                                           tLambda na1 
                                             (Ffix0 x3 x4 ty1)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLetIn na1 def def_ty body1 =>
                                           tLetIn na1 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body1)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na1 ty1 body1 =>
                              tProd na1 (Ffix x x0 ty1) (Ffix x (S x0) body1)
                          | tLambda na1 ty1 body1 =>
                              tLambda na1 (Ffix x x0 ty1)
                                (Ffix x (S x0) body1)
                          | tLetIn na1 def def_ty body1 =>
                              tLetIn na1 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body1)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tLetIn _ _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na1 ty0 body1 =>
                                           tProd na1 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLambda na1 ty0 body1 =>
                                           tLambda na1 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body1)
                                       | tLetIn na1 def def_ty0 body1 =>
                                           tLetIn na1 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty0)
                                             (Ffix0 x3 (S x4) body1)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na1 ty0 body1 =>
                              tProd na1 (Ffix x x0 ty0) (Ffix x (S x0) body1)
                          | tLambda na1 ty0 body1 =>
                              tLambda na1 (Ffix x x0 ty0)
                                (Ffix x (S x0) body1)
                          | tLetIn na1 def def_ty0 body1 =>
                              tLetIn na1 (Ffix x x0 def) 
                                (Ffix x x0 def_ty0) 
                                (Ffix x (S x0) body1)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tApp _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args0 =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f0 args0 =>
                                           tApp (Ffix0 x3 x4 f0)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args0 =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f0 args0 =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args0 is [] then 
                              Ffix x x0 f0
                              else if Ffix x x0 f0 is 
                                   (tApp f1 args1)
                                   then tApp f1
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args1
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0))
                                   else tApp (Ffix x x0 f0)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args0)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tConstruct _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx0 =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx0
                                       | tCoFix mfix idx0 =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx0
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx0 =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx0
                          | tCoFix mfix idx0 =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx0
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tCase _ _ _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams0 type_info0
                                         discr0 branches0 =>
                                           tCase ind_and_nbparams0
                                             (Ffix0 x3 x4 type_info0)
                                             (Ffix0 x3 x4 discr0)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches0)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams0 type_info0 discr0
                            branches0 =>
                              tCase ind_and_nbparams0 
                                (Ffix x x0 type_info0) 
                                (Ffix x x0 discr0)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches0)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tProj _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t0 kind v =>
                                           tCast (Ffix0 x3 x4 t0) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj0 t0 =>
                                           tProj proj0 (Ffix0 x3 x4 t0)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t0 kind v =>
                              tCast (Ffix x x0 t0) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj0 t0 => tProj proj0 (Ffix x x0 t0)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   | tFix _ _ | tCoFix _ _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix0 idx0 =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix0)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix0)
                                             idx0
                                       | tCoFix mfix0 idx0 =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix0)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix0)
                                             idx0
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix0 idx0 =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix0)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix0) idx0
                          | tCoFix mfix0 idx0 =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix0)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix0) idx0
                          | _ => x1
                          end) [tRel 0] 0 body
                   | _ =>
                       (fix Ffix
                          (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                            term :=
                          match x1 with
                          | tRel n =>
                              if
                               (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                  if x2 is (S x4)
                                  then if x3 is (S x5) then 
                                       Ffix0 x4 x5 else false else true) x0 n
                              then
                               if (fix Ffix0
                                     (x2 : list term) (x3 : nat) {struct x3} :
                                       option term :=
                                     if x3 is (S x4)
                                     then if x2 is 
                                          (_ :: x6) then 
                                          Ffix0 x6 x4 else None
                                     else if x2 is 
                                          (x4 :: _) then 
                                          Some x4 else None) x
                                    ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                          nat :=
                                        if x2 is (S x4)
                                        then if x3 is 
                                             (S x5) then 
                                             Ffix0 x4 x5 else x2 else x2) n
                                       x0) is (Some x2)
                               then (fix Ffix0
                                       (x3 x4 : nat) (x5 : term) {struct x5} :
                                         term :=
                                       match x5 with
                                       | tRel n0 =>
                                           tRel
                                             (if
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                              then
                                               (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                              else n0)
                                       | tEvar ev args =>
                                           tEvar ev
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCast t kind v =>
                                           tCast (Ffix0 x3 x4 t) kind
                                             (Ffix0 x3 x4 v)
                                       | tProd na0 ty0 body0 =>
                                           tProd na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLambda na0 ty0 body0 =>
                                           tLambda na0 
                                             (Ffix0 x3 x4 ty0)
                                             (Ffix0 x3 (S x4) body0)
                                       | tLetIn na0 def def_ty body0 =>
                                           tLetIn na0 
                                             (Ffix0 x3 x4 def)
                                             (Ffix0 x3 x4 def_ty)
                                             (Ffix0 x3 (S x4) body0)
                                       | tApp f args =>
                                           tApp (Ffix0 x3 x4 f)
                                             ((fix Ffix1 
                                               (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                       | tCase ind_and_nbparams type_info
                                         discr branches =>
                                           tCase ind_and_nbparams
                                             (Ffix0 x3 x4 type_info)
                                             (Ffix0 x3 x4 discr)
                                             ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                       | tProj proj t =>
                                           tProj proj (Ffix0 x3 x4 t)
                                       | tFix mfix idx =>
                                           tFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | tCoFix mfix idx =>
                                           tCoFix
                                             ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                       | _ => x5
                                       end) x0 0 x2
                               else tRel
                                      ((fix Ffix0 
                                        (x2 x3 : nat) {struct x2} : nat :=
                                          if x2 is 
                                          (S x4)
                                          then if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                         ((fix Ffix0 
                                           (x2 : list term) : nat :=
                                             if x2 is 
                                             (_ :: x4) then 
                                             S (Ffix0 x4) else 0) x))
                              else tRel n
                          | tEvar ev args =>
                              tEvar ev
                                ((fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args)
                          | tCast t kind v =>
                              tCast (Ffix x x0 t) kind (Ffix x x0 v)
                          | tProd na0 ty0 body0 =>
                              tProd na0 (Ffix x x0 ty0) (Ffix x (S x0) body0)
                          | tLambda na0 ty0 body0 =>
                              tLambda na0 (Ffix x x0 ty0)
                                (Ffix x (S x0) body0)
                          | tLetIn na0 def def_ty body0 =>
                              tLetIn na0 (Ffix x x0 def) 
                                (Ffix x x0 def_ty) 
                                (Ffix x (S x0) body0)
                          | tApp f args =>
                              if (fix Ffix0 (x2 : list term) : list term :=
                                    if x2 is (x3 :: x4)
                                    then Ffix x x0 x3 :: Ffix0 x4 else [])
                                   args is [] then 
                              Ffix x x0 f
                              else if Ffix x x0 f is 
                                   (tApp f0 args0)
                                   then tApp f0
                                          ((fix Ffix0
                                              (x4 x5 : list term) {struct x4} :
                                                list term :=
                                              if x4 is 
                                              (x6 :: x7)
                                              then 
                                              x6 :: Ffix0 x7 x5 else x5)
                                             args0
                                             ((fix Ffix0 
                                               (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                   else tApp (Ffix x x0 f)
                                          ((fix Ffix0 
                                            (x4 : list term) : 
                                            list term :=
                                              if x4 is 
                                              (x5 :: x6)
                                              then 
                                              Ffix x x0 x5 :: Ffix0 x6
                                              else []) args)
                          | tCase ind_and_nbparams type_info discr branches =>
                              tCase ind_and_nbparams 
                                (Ffix x x0 type_info) 
                                (Ffix x x0 discr)
                                ((fix Ffix0 (x2 : list (nat × term)) :
                                      list (nat × term) :=
                                    if x2 is (x3 :: x4)
                                    then (let (H, _) := x3 in H,
                                         Ffix x x0 (let (_, H) := x3 in H))
                                         :: Ffix0 x4 else []) branches)
                          | tProj proj t => tProj proj (Ffix x x0 t)
                          | tFix mfix idx =>
                              tFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | tCoFix mfix idx =>
                              tCoFix
                                ((fix Ffix0 (x2 : list (def term)) :
                                      list (def term) :=
                                    if x2 is (x3 :: x4)
                                    then {|
                                         dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                         dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                         dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                         rarg := let (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                         Ffix0 x4 else []) mfix) idx
                          | _ => x1
                          end) [tRel 0] 0 body
                   end
               | tApp _ _ =>
                   if todo "tsl var" is (tApp f0 args0)
                   then tApp f0
                          ((fix Ffix (x x0 : list term) {struct x} :
                                list term :=
                              if x is (x1 :: x2) then 
                              x1 :: Ffix x2 x0 else x0) args0 [
                             tRel 0]) else tApp (todo "tsl var") [tRel 0]
               | _ =>
                   if todo "tsl var" is (tApp f args)
                   then tApp f
                          ((fix Ffix (x x0 : list term) {struct x} :
                                list term :=
                              if x is (x1 :: x2) then 
                              x1 :: Ffix x2 x0 else x0) args [
                             tRel 0]) else tApp (todo "tsl var") [tRel 0]
               end
               (tProd (nNamed "y") (tVar "Y")
                  (tProd (nNamed "yᵗ")
                     ((fix Ffix
                         (x : list term) (x0 : nat) (x1 : term) {struct x1} :
                           term :=
                         match x1 with
                         | tRel n =>
                             if
                              (fix Ffix0 (x2 x3 : nat) {struct x2} : bool :=
                                 if x2 is (S x4)
                                 then if x3 is (S x5) then 
                                      Ffix0 x4 x5 else false else true) x0 n
                             then
                              if (fix Ffix0
                                    (x2 : list term) (x3 : nat) {struct x3} :
                                      option term :=
                                    if x3 is (S x4)
                                    then if x2 is 
                                         (_ :: x6) then 
                                         Ffix0 x6 x4 else None
                                    else if x2 is 
                                         (x4 :: _) then 
                                         Some x4 else None) x
                                   ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                         nat :=
                                       if x2 is (S x4)
                                       then if x3 is 
                                            (S x5) then 
                                            Ffix0 x4 x5 else x2 else x2) n x0)
                              is (Some x2)
                              then (fix Ffix0
                                      (x3 x4 : nat) (x5 : term) {struct x5} :
                                        term :=
                                      match x5 with
                                      | tRel n0 =>
                                          tRel
                                            (if
                                              (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                             then
                                              (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                n0
                                             else n0)
                                      | tEvar ev args =>
                                          tEvar ev
                                            ((fix Ffix1 
                                              (x6 : list term) : 
                                              list term :=
                                                if x6 is 
                                                (x7 :: x8)
                                                then 
                                                Ffix0 x3 x4 x7 :: 
                                                Ffix1 x8 else []) args)
                                      | tCast t kind v =>
                                          tCast (Ffix0 x3 x4 t) kind
                                            (Ffix0 x3 x4 v)
                                      | tProd na ty body =>
                                          tProd na 
                                            (Ffix0 x3 x4 ty)
                                            (Ffix0 x3 (S x4) body)
                                      | tLambda na ty body =>
                                          tLambda na 
                                            (Ffix0 x3 x4 ty)
                                            (Ffix0 x3 (S x4) body)
                                      | tLetIn na def def_ty body =>
                                          tLetIn na 
                                            (Ffix0 x3 x4 def)
                                            (Ffix0 x3 x4 def_ty)
                                            (Ffix0 x3 (S x4) body)
                                      | tApp f args =>
                                          tApp (Ffix0 x3 x4 f)
                                            ((fix Ffix1 
                                              (x6 : list term) : 
                                              list term :=
                                                if x6 is 
                                                (x7 :: x8)
                                                then 
                                                Ffix0 x3 x4 x7 :: 
                                                Ffix1 x8 else []) args)
                                      | tCase ind_and_nbparams type_info
                                        discr branches =>
                                          tCase ind_and_nbparams
                                            (Ffix0 x3 x4 type_info)
                                            (Ffix0 x3 x4 discr)
                                            ((fix Ffix1
                                                (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                if x6 is 
                                                (x7 :: x8)
                                                then 
                                                (let (H, _) := x7 in H,
                                                Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                :: 
                                                Ffix1 x8 else []) branches)
                                      | tProj proj t =>
                                          tProj proj (Ffix0 x3 x4 t)
                                      | tFix mfix idx =>
                                          tFix
                                            ((fix Ffix1
                                                (x6 : list (def term)) :
                                                 list (def term) :=
                                                if x6 is 
                                                (x7 :: x8)
                                                then 
                                                {|
                                                dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                Ffix1 x8 else []) mfix) idx
                                      | tCoFix mfix idx =>
                                          tCoFix
                                            ((fix Ffix1
                                                (x6 : list (def term)) :
                                                 list (def term) :=
                                                if x6 is 
                                                (x7 :: x8)
                                                then 
                                                {|
                                                dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2
                                                 (x9 : list (def term)) :
                                                 nat :=
                                                 if x9 is 
                                                 (_ :: x11)
                                                 then 
                                                 S (Ffix2 x11) else 0) mfix)
                                                 x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                Ffix1 x8 else []) mfix) idx
                                      | _ => x5
                                      end) x0 0 x2
                              else tRel
                                     ((fix Ffix0 (x2 x3 : nat) {struct x2} :
                                           nat :=
                                         if x2 is 
                                         (S x4)
                                         then if x3 is 
                                              (S x5) then 
                                              Ffix0 x4 x5 else x2 else x2) n
                                        ((fix Ffix0 (x2 : list term) : nat :=
                                            if x2 is 
                                            (_ :: x4) then 
                                            S (Ffix0 x4) else 0) x))
                             else tRel n
                         | tEvar ev args =>
                             tEvar ev
                               ((fix Ffix0 (x2 : list term) : list term :=
                                   if x2 is (x3 :: x4)
                                   then Ffix x x0 x3 :: Ffix0 x4 else [])
                                  args)
                         | tCast t kind v =>
                             tCast (Ffix x x0 t) kind (Ffix x x0 v)
                         | tProd na ty body =>
                             tProd na (Ffix x x0 ty) (Ffix x (S x0) body)
                         | tLambda na ty body =>
                             tLambda na (Ffix x x0 ty) (Ffix x (S x0) body)
                         | tLetIn na def def_ty body =>
                             tLetIn na (Ffix x x0 def) 
                               (Ffix x x0 def_ty) 
                               (Ffix x (S x0) body)
                         | tApp f args =>
                             if (fix Ffix0 (x2 : list term) : list term :=
                                   if x2 is (x3 :: x4)
                                   then Ffix x x0 x3 :: Ffix0 x4 else [])
                                  args is [] then 
                             Ffix x x0 f
                             else if Ffix x x0 f is 
                                  (tApp f0 args0)
                                  then tApp f0
                                         ((fix Ffix0
                                             (x4 x5 : list term) {struct x4} :
                                               list term :=
                                             if x4 is 
                                             (x6 :: x7)
                                             then 
                                             x6 :: Ffix0 x7 x5 else x5) args0
                                            ((fix Ffix0 
                                              (x4 : list term) : 
                                              list term :=
                                                if x4 is 
                                                (x5 :: x6)
                                                then 
                                                Ffix x x0 x5 :: Ffix0 x6
                                                else []) args))
                                  else tApp (Ffix x x0 f)
                                         ((fix Ffix0 
                                           (x4 : list term) : 
                                           list term :=
                                             if x4 is 
                                             (x5 :: x6)
                                             then 
                                             Ffix x x0 x5 :: Ffix0 x6 else [])
                                            args)
                         | tCase ind_and_nbparams type_info discr branches =>
                             tCase ind_and_nbparams 
                               (Ffix x x0 type_info) 
                               (Ffix x x0 discr)
                               ((fix Ffix0 (x2 : list (nat × term)) :
                                     list (nat × term) :=
                                   if x2 is (x3 :: x4)
                                   then (let (H, _) := x3 in H,
                                        Ffix x x0 (let (_, H) := x3 in H))
                                        :: Ffix0 x4 else []) branches)
                         | tProj proj t => tProj proj (Ffix x x0 t)
                         | tFix mfix idx =>
                             tFix
                               ((fix Ffix0 (x2 : list (def term)) :
                                     list (def term) :=
                                   if x2 is (x3 :: x4)
                                   then {|
                                        dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                        dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                        dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                        rarg := let (_, _, _, rarg) := x3 in
                                                rarg |} :: 
                                        Ffix0 x4 else []) mfix) idx
                         | tCoFix mfix idx =>
                             tCoFix
                               ((fix Ffix0 (x2 : list (def term)) :
                                     list (def term) :=
                                   if x2 is (x3 :: x4)
                                   then {|
                                        dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                        dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                        dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                        rarg := let (_, _, _, rarg) := x3 in
                                                rarg |} :: 
                                        Ffix0 x4 else []) mfix) idx
                         | _ => x1
                         end) [tApp (tRel 2) [tRel 1]] 1
                        match todo "tsl var" with
                        | tEvar _ _ =>
                            if todo "tsl var" is (tApp f args0)
                            then tApp f
                                   ((fix Ffix (x x0 : list term) {struct x} :
                                         list term :=
                                       if x is (x1 :: x2)
                                       then x1 :: Ffix x2 x0 else x0) args0
                                      [tRel 0])
                            else tApp (todo "tsl var") [tRel 0]
                        | tLambda _ _ body =>
                            match
                              (fix Ffix
                                 (x : list term) (x0 : nat) 
                                 (x1 : term) {struct x1} : term :=
                                 match x1 with
                                 | tRel n =>
                                     if
                                      (fix Ffix0 (x2 x3 : nat) {struct x2} :
                                           bool :=
                                         if x2 is 
                                         (S x4)
                                         then if x3 is 
                                              (S x5) then 
                                              Ffix0 x4 x5 else false
                                         else true) x0 n
                                     then
                                      if (fix Ffix0
                                            (x2 : list term) 
                                            (x3 : nat) {struct x3} :
                                              option term :=
                                            if x3 is 
                                            (S x4)
                                            then if x2 is 
                                                 (_ :: x6) then 
                                                 Ffix0 x6 x4 else None
                                            else if x2 is 
                                                 (x4 :: _) then 
                                                 Some x4 else None) x
                                           ((fix Ffix0
                                               (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                               if x2 is 
                                               (S x4)
                                               then 
                                               if x3 is 
                                               (S x5) then 
                                               Ffix0 x4 x5 else x2 else x2) n
                                              x0) is 
                                      (Some x2)
                                      then (fix Ffix0
                                              (x3 x4 : nat) 
                                              (x5 : term) {struct x5} :
                                                term :=
                                              match x5 with
                                              | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                              | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                              | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                              | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                              | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                              | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                              | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                              | tCase ind_and_nbparams
                                                type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                              | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                              | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11) then 
                                                 S (...) else x10)
                                                 ((fix Ffix2 ... : nat :=
                                                 if x9 is ... then ... else 0)
                                                 mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                              | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11) then 
                                                 S (...) else x10)
                                                 ((fix Ffix2 ... : nat :=
                                                 if x9 is ... then ... else 0)
                                                 mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                              | _ => x5
                                              end) x0 0 x2
                                      else tRel
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n
                                                ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                     else tRel n
                                 | tEvar ev args =>
                                     tEvar ev
                                       ((fix Ffix0 
                                         (x2 : list term) : 
                                         list term :=
                                           if x2 is 
                                           (x3 :: x4)
                                           then Ffix x x0 x3 :: Ffix0 x4
                                           else []) args)
                                 | tCast t kind v =>
                                     tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                 | tProd na0 ty0 body0 =>
                                     tProd na0 (Ffix x x0 ty0)
                                       (Ffix x (S x0) body0)
                                 | tLambda na0 ty0 body0 =>
                                     tLambda na0 (Ffix x x0 ty0)
                                       (Ffix x (S x0) body0)
                                 | tLetIn na0 def def_ty body0 =>
                                     tLetIn na0 (Ffix x x0 def)
                                       (Ffix x x0 def_ty)
                                       (Ffix x (S x0) body0)
                                 | tApp f args =>
                                     if (fix Ffix0 
                                         (x2 : list term) : 
                                         list term :=
                                           if x2 is 
                                           (x3 :: x4)
                                           then Ffix x x0 x3 :: Ffix0 x4
                                           else []) args is []
                                     then Ffix x x0 f
                                     else if Ffix x x0 f is 
                                          (tApp f0 args0)
                                          then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                          else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                 | tCase ind_and_nbparams type_info discr
                                   branches =>
                                     tCase ind_and_nbparams
                                       (Ffix x x0 type_info)
                                       (Ffix x x0 discr)
                                       ((fix Ffix0 
                                         (x2 : list (nat × term)) :
                                             list (nat × term) :=
                                           if x2 is 
                                           (x3 :: x4)
                                           then (let (H, _) := x3 in H,
                                                Ffix x x0
                                                 (let (_, H) := x3 in H))
                                                :: 
                                                Ffix0 x4 else []) branches)
                                 | tProj proj t => tProj proj (Ffix x x0 t)
                                 | tFix mfix idx =>
                                     tFix
                                       ((fix Ffix0 
                                         (x2 : list (def term)) :
                                             list (def term) :=
                                           if x2 is 
                                           (x3 :: x4)
                                           then {|
                                                dname := let
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                                dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                                dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                                rarg := let
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                                Ffix0 x4 else []) mfix) idx
                                 | tCoFix mfix idx =>
                                     tCoFix
                                       ((fix Ffix0 
                                         (x2 : list (def term)) :
                                             list (def term) :=
                                           if x2 is 
                                           (x3 :: x4)
                                           then {|
                                                dname := let
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                                dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                                dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                                rarg := let
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                                Ffix0 x4 else []) mfix) idx
                                 | _ => x1
                                 end) [tRel 0] 0 body
                            with
                            | tRel _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n0 =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n0
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n0 x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n1 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n1
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n1
                                                 else n1)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n0
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n0
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tEvar _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev0 args0 =>
                                                 tEvar ev0
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args0 =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev0 args0 =>
                                       tEvar ev0
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args0)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args0 =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args0 is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args1)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args1
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tCast _ _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t0 kind0 v0 =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t0) kind0
                                                 (Ffix0 x3 x4 v0)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t0 =>
                                                 tProj proj (Ffix0 x3 x4 t0)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t0 kind0 v0 =>
                                       tCast (Ffix x x0 t0) kind0
                                         (Ffix x x0 v0)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t0 =>
                                       tProj proj (Ffix x x0 t0)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tProd _ _ _ | tLambda _ _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na1 ty1 body1 =>
                                                 tProd na1 
                                                 (Ffix0 x3 x4 ty1)
                                                 (Ffix0 x3 (S x4) body1)
                                                | tLambda na1 ty1 body1 =>
                                                 tLambda na1
                                                 (Ffix0 x3 x4 ty1)
                                                 (Ffix0 x3 (S x4) body1)
                                                | tLetIn na1 def def_ty body1 =>
                                                 tLetIn na1 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body1)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na1 ty1 body1 =>
                                       tProd na1 (Ffix x x0 ty1)
                                         (Ffix x (S x0) body1)
                                   | tLambda na1 ty1 body1 =>
                                       tLambda na1 
                                         (Ffix x x0 ty1)
                                         (Ffix x (S x0) body1)
                                   | tLetIn na1 def def_ty body1 =>
                                       tLetIn na1 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body1)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tLetIn _ _ _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na1 ty0 body1 =>
                                                 tProd na1 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body1)
                                                | tLambda na1 ty0 body1 =>
                                                 tLambda na1
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body1)
                                                | tLetIn na1 def def_ty0
                                                 body1 =>
                                                 tLetIn na1 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty0)
                                                 (Ffix0 x3 (S x4) body1)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na1 ty0 body1 =>
                                       tProd na1 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body1)
                                   | tLambda na1 ty0 body1 =>
                                       tLambda na1 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body1)
                                   | tLetIn na1 def def_ty0 body1 =>
                                       tLetIn na1 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty0)
                                         (Ffix x (S x0) body1)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tApp _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args0 =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f0 args0 =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f0)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args0)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args0 =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args0)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f0 args0 =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args0 is [] then 
                                       Ffix x x0 f0
                                       else if Ffix x x0 f0
                                            is (tApp f1 args1)
                                            then tApp f1
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args1
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0))
                                            else tApp 
                                                 (Ffix x x0 f0)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args0)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tConstruct _ _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx0 =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx0
                                                | tCoFix mfix idx0 =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx0
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx0 =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx0
                                   | tCoFix mfix idx0 =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx0
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tCase _ _ _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams0
                                                 type_info0 discr0 branches0 =>
                                                 tCase ind_and_nbparams0
                                                 (Ffix0 x3 x4 type_info0)
                                                 (Ffix0 x3 x4 discr0)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches0)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams0 type_info0
                                     discr0 branches0 =>
                                       tCase ind_and_nbparams0
                                         (Ffix x x0 type_info0)
                                         (Ffix x x0 discr0)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches0)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tProj _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t0 kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t0) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj0 t0 =>
                                                 tProj proj0 (Ffix0 x3 x4 t0)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t0 kind v =>
                                       tCast (Ffix x x0 t0) kind
                                         (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj0 t0 =>
                                       tProj proj0 (Ffix x x0 t0)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | tFix _ _ | tCoFix _ _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix0 idx0 =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix0) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix0)
                                                 idx0
                                                | tCoFix mfix0 idx0 =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix0) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix0)
                                                 idx0
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix0 idx0 =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix0)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix0) idx0
                                   | tCoFix mfix0 idx0 =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix0)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix0) idx0
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            | _ =>
                                (fix Ffix
                                   (x : list term) 
                                   (x0 : nat) (x1 : term) {struct x1} :
                                     term :=
                                   match x1 with
                                   | tRel n =>
                                       if
                                        (fix Ffix0
                                           (x2 x3 : nat) {struct x2} :
                                             bool :=
                                           if x2 is 
                                           (S x4)
                                           then if x3 is 
                                                (S x5) then 
                                                Ffix0 x4 x5 else false
                                           else true) x0 n
                                       then
                                        if (fix Ffix0
                                              (x2 : list term) 
                                              (x3 : nat) {struct x3} :
                                                option term :=
                                              if x3 is 
                                              (S x4)
                                              then 
                                              if x2 is 
                                              (_ :: x6) then 
                                              Ffix0 x6 x4 else None
                                              else 
                                              if x2 is 
                                              (x4 :: _) then 
                                              Some x4 else None) x
                                             ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                n x0) is 
                                        (Some x2)
                                        then (fix Ffix0
                                                (x3 x4 : nat) 
                                                (x5 : term) {struct x5} :
                                                 term :=
                                                match x5 with
                                                | tRel n0 =>
                                                 tRel
                                                 (if
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 bool :=
                                                 if x6 is 
                                                 (S x8)
                                                 then 
                                                 if x7 is 
                                                 (S x9) then 
                                                 Ffix1 x8 x9 else false
                                                 else true) x4 n0
                                                 then
                                                 (fix Ffix1
                                                 (x6 x7 : nat) {struct x6} :
                                                 nat :=
                                                 if x6 is 
                                                 (S x8) then 
                                                 S (Ffix1 x8 x7) else x7) x3
                                                 n0
                                                 else n0)
                                                | tEvar ev args =>
                                                 tEvar ev
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCast t kind v =>
                                                 tCast 
                                                 (Ffix0 x3 x4 t) kind
                                                 (Ffix0 x3 x4 v)
                                                | tProd na0 ty0 body0 =>
                                                 tProd na0 
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLambda na0 ty0 body0 =>
                                                 tLambda na0
                                                 (Ffix0 x3 x4 ty0)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tLetIn na0 def def_ty body0 =>
                                                 tLetIn na0 
                                                 (Ffix0 x3 x4 def)
                                                 (Ffix0 x3 x4 def_ty)
                                                 (Ffix0 x3 (S x4) body0)
                                                | tApp f args =>
                                                 tApp 
                                                 (Ffix0 x3 x4 f)
                                                 ((fix Ffix1
                                                 (x6 : list term) :
                                                 list term :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 Ffix0 x3 x4 x7 :: 
                                                 Ffix1 x8 else []) args)
                                                | tCase ind_and_nbparams
                                                 type_info discr branches =>
                                                 tCase ind_and_nbparams
                                                 (Ffix0 x3 x4 type_info)
                                                 (Ffix0 x3 x4 discr)
                                                 ((fix Ffix1
                                                 (x6 : list (nat × term)) :
                                                 list (nat × term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 (
                                                 let (H, _) := x7 in H,
                                                 Ffix0 x3 x4
                                                 (let (_, H) := x7 in H))
                                                 :: 
                                                 Ffix1 x8 else []) branches)
                                                | tProj proj t =>
                                                 tProj proj (Ffix0 x3 x4 t)
                                                | tFix mfix idx =>
                                                 tFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | tCoFix mfix idx =>
                                                 tCoFix
                                                 ((fix Ffix1
                                                 (x6 : list (def term)) :
                                                 list (def term) :=
                                                 if x6 is 
                                                 (x7 :: x8)
                                                 then 
                                                 {|
                                                 dname := let
                                                 (dname, _, _, _) := x7 in
                                                 dname;
                                                 dtype := Ffix0 x3 x4
                                                 (let 
                                                 (_, dtype, _, _) := x7 in
                                                 dtype);
                                                 dbody := Ffix0 x3
                                                 ((fix Ffix2
                                                 (x9 x10 : nat) {struct x9} :
                                                 nat :=
                                                 if x9 is 
                                                 (S x11)
                                                 then 
                                                 S (Ffix2 x11 x10) else x10)
                                                 ((fix Ffix2 
                                                 (x9 : ...) : nat :=
                                                 if x9 is 
                                                 (_ :: x11) then 
                                                 S (...) else 0) mfix) x4)
                                                 (let 
                                                 (_, _, dbody, _) := x7 in
                                                 dbody);
                                                 rarg := let
                                                 (_, _, _, rarg) := x7 in
                                                 rarg |} :: 
                                                 Ffix1 x8 else []) mfix) idx
                                                | _ => x5
                                                end) x0 0 x2
                                        else tRel
                                               ((fix Ffix0
                                                 (x2 x3 : nat) {struct x2} :
                                                 nat :=
                                                 if x2 is 
                                                 (S x4)
                                                 then 
                                                 if x3 is 
                                                 (S x5) then 
                                                 Ffix0 x4 x5 else x2 else x2)
                                                 n
                                                 ((fix Ffix0
                                                 (x2 : list term) : nat :=
                                                 if x2 is 
                                                 (_ :: x4) then 
                                                 S (Ffix0 x4) else 0) x))
                                       else tRel n
                                   | tEvar ev args =>
                                       tEvar ev
                                         ((fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args)
                                   | tCast t kind v =>
                                       tCast (Ffix x x0 t) kind (Ffix x x0 v)
                                   | tProd na0 ty0 body0 =>
                                       tProd na0 (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLambda na0 ty0 body0 =>
                                       tLambda na0 
                                         (Ffix x x0 ty0)
                                         (Ffix x (S x0) body0)
                                   | tLetIn na0 def def_ty body0 =>
                                       tLetIn na0 
                                         (Ffix x x0 def) 
                                         (Ffix x x0 def_ty)
                                         (Ffix x (S x0) body0)
                                   | tApp f args =>
                                       if (fix Ffix0 
                                           (x2 : list term) : 
                                           list term :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             Ffix x x0 x3 :: Ffix0 x4 else [])
                                            args is [] then 
                                       Ffix x x0 f
                                       else if Ffix x x0 f is 
                                            (tApp f0 args0)
                                            then tApp f0
                                                 ((fix Ffix0
                                                 (x4 x5 : list term) {struct
                                                 x4} : 
                                                 list term :=
                                                 if x4 is 
                                                 (x6 :: x7)
                                                 then 
                                                 x6 :: Ffix0 x7 x5 else x5)
                                                 args0
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args))
                                            else tApp 
                                                 (Ffix x x0 f)
                                                 ((fix Ffix0
                                                 (x4 : list term) :
                                                 list term :=
                                                 if x4 is 
                                                 (x5 :: x6)
                                                 then 
                                                 Ffix x x0 x5 :: 
                                                 Ffix0 x6 else []) args)
                                   | tCase ind_and_nbparams type_info discr
                                     branches =>
                                       tCase ind_and_nbparams
                                         (Ffix x x0 type_info)
                                         (Ffix x x0 discr)
                                         ((fix Ffix0
                                             (x2 : list (nat × term)) :
                                               list (nat × term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             (let (H, _) := x3 in H,
                                             Ffix x x0
                                               (let (_, H) := x3 in H))
                                             :: Ffix0 x4 else []) branches)
                                   | tProj proj t => tProj proj (Ffix x x0 t)
                                   | tFix mfix idx =>
                                       tFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | tCoFix mfix idx =>
                                       tCoFix
                                         ((fix Ffix0 
                                           (x2 : list (def term)) :
                                               list (def term) :=
                                             if x2 is 
                                             (x3 :: x4)
                                             then 
                                             {|
                                             dname := let 
                                                 (dname, _, _, _) := x3 in
                                                 dname;
                                             dtype := Ffix x x0
                                                 (let 
                                                 (_, dtype, _, _) := x3 in
                                                 dtype);
                                             dbody := Ffix x
                                                 ((fix Ffix1
                                                 (x5 x6 : nat) {struct x5} :
                                                 nat :=
                                                 if x5 is 
                                                 (S x7) then 
                                                 S (Ffix1 x7 x6) else x6)
                                                 ((fix Ffix1
                                                 (x5 : list (def term)) :
                                                 nat :=
                                                 if x5 is 
                                                 (_ :: x7) then 
                                                 S (Ffix1 x7) else 0) mfix)
                                                 x0)
                                                 (let 
                                                 (_, _, dbody, _) := x3 in
                                                 dbody);
                                             rarg := let 
                                                 (_, _, _, rarg) := x3 in
                                                 rarg |} :: 
                                             Ffix0 x4 else []) mfix) idx
                                   | _ => x1
                                   end) [tRel 0] 0 body
                            end
                        | tApp _ _ =>
                            if todo "tsl var" is (tApp f0 args0)
                            then tApp f0
                                   ((fix Ffix (x x0 : list term) {struct x} :
                                         list term :=
                                       if x is (x1 :: x2)
                                       then x1 :: Ffix x2 x0 else x0) args0
                                      [tRel 0])
                            else tApp (todo "tsl var") [tRel 0]
                        | _ =>
                            if todo "tsl var" is (tApp f args)
                            then tApp f
                                   ((fix Ffix (x x0 : list term) {struct x} :
                                         list term :=
                                       if x is (x1 :: x2)
                                       then x1 :: Ffix x2 x0 else x0) args
                                      [tRel 0])
                            else tApp (todo "tsl var") [tRel 0]
                        end) (tApp (tRel 2) [tApp (tRel 4) [tRel 3; tRel 1]])))))
     : term
(tRel 0)
R0
R0
R0
R0

equal:  true
=====================

(tProd nAnon (tRel 0) (tRel 1))
(R0) -> R1
λ (f : (R1) -> R2). (R2) -> (((R2) [R0;])) -> ((R3) [((R2) [R1;]);])
λ (f : (R1) -> R2). (R2) -> (((R2) [R0;])) -> ((R3) [((R2) [R1;]);])
λ (f : (R1) -> R2). (R2) -> (((R2) [R0;])) -> ((R3) [((R2) [R1;]);])

equal:  true
=====================

(tProd (nNamed "A")
   (tSort
      {|
      Universe.t_set := {|
                        UnivExprSet.this := [UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1108",
                                               false)];
                        UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                               (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1108",
                                                 false)) |};
      Universe.t_ne := Logic.eq_refl |})
   (tProd (nNamed "a") (tRel 0)
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1109",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1109",
                                                 false)) |};
         Universe.t_ne := Logic.eq_refl |})))
∀ (A : tSort ?), ∀ (a : R0), tSort ?
λ (f : ∀ (A : tSort ?), ∀ (a : R0), tSort ?). ∀ (A : tSort ?), ∀ (Aᵗ : (R0) -> tSort ?), ∀ (a : R1), ∀ (aᵗ : ((R1) [R0;])), (((R4) [R3;R1;])) -> tSort ?
λ (f : ∀ (A : tSort ?), ∀ (a : R0), tSort ?). ∀ (A : tSort ?), ∀ (Aᵗ : (R0) -> tSort ?), ∀ (a : R1), ∀ (aᵗ : ((R1) [R0;])), (((R4) [R3;R1;])) -> tSort ?
λ (f : ∀ (A : tSort ?), ∀ (a : R0), tSort ?). ∀ (A : tSort ?), ∀ (Aᵗ : (R0) -> tSort ?), ∀ (a : R1), ∀ (aᵗ : ((R1) [R0;])), (((R4) [R3;R1;])) -> tSort ?

equal:  true
=====================

(tProd (nNamed "A")
   (tSort
      {|
      Universe.t_set := {|
                        UnivExprSet.this := [UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1110",
                                               false)];
                        UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                               (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1110",
                                                 false)) |};
      Universe.t_ne := Logic.eq_refl |})
   (tProd (nNamed "a")
      (tInd
         {|
         inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "nat");
         inductive_ind := 0 |} [])
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1111",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1111",
                                                 false)) |};
         Universe.t_ne := Logic.eq_refl |})))
∀ (A : tSort ?), ∀ (a : nat), tSort ?
λ (f : ∀ (A : tSort ?), ∀ (a : nat), tSort ?). ∀ (A : tSort ?), ∀ (Aᵗ : (R0) -> tSort ?), ∀ (a : nat), ∀ (aᵗ : ((debug: tsl_rec1: tInd Coq.Init.Datatypes.nat not found) [R0;])), (((R4) [R3;R1;])) -> tSort ?
λ (f : ∀ (A : tSort ?), ∀ (a : nat), tSort ?). ∀ (A : tSort ?), ∀ (Aᵗ : (R0) -> tSort ?), ∀ (a : nat), ∀ (aᵗ : ((debug: tsl_rec1: tInd Coq.Init.Datatypes.nat not found) [R0;])), (((R4) [R3;R1;])) -> tSort ?
λ (f : ∀ (A : tSort ?), ∀ (a : nat), tSort ?). ∀ (A : tSort ?), ∀ (Aᵗ : (R0) -> tSort ?), ∀ (a : nat), (((R3) [R2;R0;])) -> tSort ?

equal:  true
=====================

(tProd (nNamed "f")
   (tProd nAnon
      (tInd
         {|
         inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "nat");
         inductive_ind := 0 |} [])
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1112",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1112",
                                                 false)) |};
         Universe.t_ne := Logic.eq_refl |}))
   (tProd (nNamed "n")
      (tInd
         {|
         inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "nat");
         inductive_ind := 0 |} []) (tApp (tRel 1) [tRel 0])))
∀ (f : (nat) -> tSort ?), ∀ (n : nat), ((R1) [R0;])
λ (f : ∀ (f : (nat) -> tSort ?), ∀ (n : nat), ((R1) [R0;])). ∀ (f : (nat) -> tSort ?), ∀ (fᵗ : (nat) -> (((debug: tsl_rec1: tInd Coq.Init.Datatypes.nat not found) [R0;])) -> (((R2) [R1;])) -> tSort ?), ∀ (n : nat), ∀ (nᵗ : ((debug: tsl_rec1: tInd Coq.Init.Datatypes.nat not found) [R0;])), ((R2) [R1;R0;((R4) [R3;R1;]);])
λ (f : ∀ (f : (nat) -> tSort ?), ∀ (n : nat), ((R1) [R0;])). ∀ (f : (nat) -> tSort ?), ∀ (fᵗ : (nat) -> (((debug: tsl_rec1: tInd Coq.Init.Datatypes.nat not found) [R0;])) -> (((R2) [R1;])) -> tSort ?), ∀ (n : nat), ∀ (nᵗ : ((debug: tsl_rec1: tInd Coq.Init.Datatypes.nat not found) [R0;])), ((R2) [R1;R0;((R4) [R3;R1;]);])
λ (f : ∀ (f : (nat) -> tSort ?), ∀ (n : nat), ((R1) [R0;])). ∀ (f : (nat) -> tSort ?), ∀ (fᵗ : (nat) -> (((R1) [R0;])) -> tSort ?), ∀ (n : nat), ((R1) [R0;((R3) [R2;R0;]);])

equal:  true
=====================

(tProd (nNamed "T")
   (tSort
      {|
      Universe.t_set := {|
                        UnivExprSet.this := [UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1113",
                                               false)];
                        UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                               (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1113",
                                                 false)) |};
      Universe.t_ne := Logic.eq_refl |})
   (tSort
      {|
      Universe.t_set := {|
                        UnivExprSet.this := [UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1114",
                                               false)];
                        UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                               (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1114",
                                                 false)) |};
      Universe.t_ne := Logic.eq_refl |}))
∀ (T : tSort ?), tSort ?
λ (f : ∀ (T : tSort ?), tSort ?). ∀ (T : tSort ?), ∀ (Tᵗ : (R0) -> tSort ?), (((R2) [R1;])) -> tSort ?
λ (f : ∀ (T : tSort ?), tSort ?). ∀ (T : tSort ?), ∀ (Tᵗ : (R0) -> tSort ?), (((R2) [R1;])) -> tSort ?
λ (f : ∀ (T : tSort ?), tSort ?). ∀ (T : tSort ?), ∀ (Tᵗ : (R0) -> tSort ?), (((R2) [R1;])) -> tSort ?

equal:  true
=====================

(tLambda (nNamed "P")
   (tProd nAnon
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1115",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1115",
                                                 false)) |};
         Universe.t_ne := Logic.eq_refl |})
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1116",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1116",
                                                 false)) |};
         Universe.t_ne := Logic.eq_refl |}))
   (tLambda (nNamed "Q")
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1117",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1117",
                                                 false)) |};
         Universe.t_ne := Logic.eq_refl |}) (tApp (tRel 1) [tRel 0])))
λ (P : (tSort ?) -> tSort ?). λ (Q : tSort ?). ((R1) [R0;])
λ (P : (tSort ?) -> tSort ?). λ (Pᵗ : (tSort ?) -> ((R0) -> tSort ?) -> (((R2) [R1;])) -> tSort ?). λ (Q : tSort ?). λ (Qᵗ : (R0) -> tSort ?). ((R2) [R1;R0;])
λ (P : (tSort ?) -> tSort ?). λ (Pᵗ : (tSort ?) -> ((R0) -> tSort ?) -> (((R2) [R1;])) -> tSort ?). λ (Q : tSort ?). λ (Qᵗ : (R0) -> tSort ?). ((R2) [R1;R0;])
λ (P : (tSort ?) -> tSort ?). λ (Pᵗ : (tSort ?) -> ((R0) -> tSort ?) -> (((R2) [R1;])) -> tSort ?). λ (Q : tSort ?). λ (Qᵗ : (R0) -> tSort ?). ((R2) [R1;R0;])

equal:  true
=====================

(tLambda (nNamed "P")
   (tSort
      {|
      Universe.t_set := {|
                        UnivExprSet.this := [UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1118",
                                               false)];
                        UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                               (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1118",
                                                 false)) |};
      Universe.t_ne := Logic.eq_refl |})
   (tProd (nNamed "p") (tRel 0) (tRel 1)))
λ (P : tSort ?). ∀ (p : R0), R1
λ (P : tSort ?). λ (Pᵗ : (R0) -> tSort ?). λ (f : ∀ (p : R1), R2). ∀ (p : R2), ∀ (pᵗ : ((R2) [R0;])), ((R3) [((R2) [R1;]);])
λ (P : tSort ?). λ (Pᵗ : (R0) -> tSort ?). λ (f : ∀ (p : R1), R2). ∀ (p : R2), ∀ (pᵗ : ((R2) [R0;])), ((R3) [((R2) [R1;]);])
λ (P : tSort ?). λ (Pᵗ : (R0) -> tSort ?). λ (f : ∀ (p : R1), R2). ∀ (p : R2), ∀ (pᵗ : ((R2) [R0;])), ((R3) [((R2) [R1;]);])

equal:  true
=====================

(tLambda (nNamed "P")
   (tSort
      {|
      Universe.t_set := {|
                        UnivExprSet.this := [UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1119",
                                               false)];
                        UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                               (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1119",
                                                 false)) |};
      Universe.t_ne := Logic.eq_refl |})
   (tProd (nNamed "p") (tRel 0) (tProd (nNamed "q") (tRel 1) (tRel 2))))
λ (P : tSort ?). ∀ (p : R0), ∀ (q : R1), R2
λ (P : tSort ?). λ (Pᵗ : (R0) -> tSort ?). λ (f : ∀ (p : R1), ∀ (q : R2), R3). ∀ (p : R2), ∀ (pᵗ : ((R2) [R0;])), ∀ (q : R4), ∀ (qᵗ : ((R4) [R0;])), ((R5) [((R4) [R3;R1;]);])
λ (P : tSort ?). λ (Pᵗ : (R0) -> tSort ?). λ (f : ∀ (p : R1), ∀ (q : R2), R3). ∀ (p : R2), ∀ (pᵗ : ((R2) [R0;])), ∀ (q : R4), ∀ (qᵗ : ((R4) [R0;])), ((R5) [((R4) [R3;R1;]);])
λ (P : tSort ?). λ (Pᵗ : (R0) -> tSort ?). λ (f : ∀ (p : R1), ∀ (q : R2), R3). ∀ (p : R2), ∀ (pᵗ : ((R2) [R0;])), ∀ (q : R4), ∀ (qᵗ : ((R4) [R0;])), ((R5) [((R4) [R3;R1;]);])

equal:  true
=====================

(tLambda (nNamed "P")
   (tSort
      {|
      Universe.t_set := {|
                        UnivExprSet.this := [UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1120",
                                               false)];
                        UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                               (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1120",
                                                 false)) |};
      Universe.t_ne := Logic.eq_refl |})
   (tLambda (nNamed "Q")
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1121",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1121",
                                                 false)) |};
         Universe.t_ne := Logic.eq_refl |})
      (tProd (nNamed "p") (tRel 1) (tRel 2))))
λ (P : tSort ?). λ (Q : tSort ?). ∀ (p : R1), R2
λ (P : tSort ?). λ (Pᵗ : (R0) -> tSort ?). λ (Q : tSort ?). λ (Qᵗ : (R0) -> tSort ?). λ (f : ∀ (p : R3), R4). ∀ (p : R4), ∀ (pᵗ : ((R4) [R0;])), ((R5) [((R2) [R1;]);])
λ (P : tSort ?). λ (Pᵗ : (R0) -> tSort ?). λ (Q : tSort ?). λ (Qᵗ : (R0) -> tSort ?). λ (f : ∀ (p : R3), R4). ∀ (p : R4), ∀ (pᵗ : ((R4) [R0;])), ((R5) [((R2) [R1;]);])
λ (P : tSort ?). λ (Pᵗ : (R0) -> tSort ?). λ (Q : tSort ?). λ (Qᵗ : (R0) -> tSort ?). λ (f : ∀ (p : R3), R4). ∀ (p : R4), ∀ (pᵗ : ((R4) [R0;])), ((R5) [((R2) [R1;]);])

equal:  true
=====================

(tLambda (nNamed "P")
   (tProd nAnon
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1122",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1122",
                                                 false)) |};
         Universe.t_ne := Logic.eq_refl |})
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1123",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1123",
                                                 false)) |};
         Universe.t_ne := Logic.eq_refl |}))
   (tLambda (nNamed "Q")
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1124",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1124",
                                                 false)) |};
         Universe.t_ne := Logic.eq_refl |})
      (tProd (nNamed "X") (tApp (tRel 1) [tRel 0])
         (tProd (nNamed "q") (tRel 1) (tApp (tRel 3) [tRel 2])))))
λ (P : (tSort ?) -> tSort ?). λ (Q : tSort ?). ∀ (X : ((R1) [R0;])), ∀ (q : R1), ((R3) [R2;])
λ (P : (tSort ?) -> tSort ?). λ (Pᵗ : (tSort ?) -> ((R0) -> tSort ?) -> (((R2) [R1;])) -> tSort ?). λ (Q : tSort ?). λ (Qᵗ : (R0) -> tSort ?). λ (f : ∀ (X : ((R3) [R1;])), ∀ (q : R2), ((R5) [R3;])). ∀ (X : ((R4) [R2;])), ∀ (Xᵗ : ((R4) [R3;R2;R0;])), ∀ (q : R4), ∀ (qᵗ : ((R4) [R0;])), ((R7) [R6;R5;((R4) [R3;R1;]);])
λ (P : (tSort ?) -> tSort ?). λ (Pᵗ : (tSort ?) -> ((R0) -> tSort ?) -> (((R2) [R1;])) -> tSort ?). λ (Q : tSort ?). λ (Qᵗ : (R0) -> tSort ?). λ (f : ∀ (X : ((R3) [R1;])), ∀ (q : R2), ((R5) [R3;])). ∀ (X : ((R4) [R2;])), ∀ (Xᵗ : ((R4) [R3;R2;R0;])), ∀ (q : R4), ∀ (qᵗ : ((R4) [R0;])), ((R7) [R6;R5;((R4) [R3;R1;]);])
λ (P : (tSort ?) -> tSort ?). λ (Pᵗ : (tSort ?) -> ((R0) -> tSort ?) -> (((R2) [R1;])) -> tSort ?). λ (Q : tSort ?). λ (Qᵗ : (R0) -> tSort ?). λ (f : ∀ (X : ((R3) [R1;])), ∀ (q : R2), ((R5) [R3;])). ∀ (X : ((R4) [R2;])), ∀ (Xᵗ : ((R4) [R3;R2;R0;])), ∀ (q : R4), ∀ (qᵗ : ((R4) [R0;])), ((R7) [R6;R5;((R4) [R3;R1;]);])

equal:  true
=====================

(tLambda (nNamed "P")
   (tSort
      {|
      Universe.t_set := {|
                        UnivExprSet.this := [UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1125",
                                               false)];
                        UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                               (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1125",
                                                 false)) |};
      Universe.t_ne := Logic.eq_refl |})
   (tLetIn (nNamed "X") (tRel 0)
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1125",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1125",
                                                 false)) |};
         Universe.t_ne := Logic.eq_refl |})
      (tLetIn (nNamed "Y") (tRel 0)
         (tSort
            {|
            Universe.t_set := {|
                              UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1125",
                                                 false)];
                              UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1125",
                                                 false)) |};
            Universe.t_ne := Logic.eq_refl |})
         (tProd (nNamed "Q")
            (tProd nAnon
               (tSort
                  {|
                  Universe.t_set := {|
                                    UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1126",
                                                 false)];
                                    UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1126",
                                                 false)) |};
                  Universe.t_ne := Logic.eq_refl |})
               (tProd nAnon
                  (tSort
                     {|
                     Universe.t_set := {|
                                       UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1127",
                                                 false)];
                                       UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1127",
                                                 false)) |};
                     Universe.t_ne := Logic.eq_refl |})
                  (tSort
                     {|
                     Universe.t_set := {|
                                       UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1128",
                                                 false)];
                                       UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1128",
                                                 false)) |};
                     Universe.t_ne := Logic.eq_refl |})))
            (tApp (tRel 0) [tRel 1; tRel 2])))))
λ (P : tSort ?). let X := R0 : tSort ? in 
let Y := R0 : tSort ? in 
∀ (Q : (tSort ?) -> (tSort ?) -> tSort ?), ((R0) [R1;R2;])
λ (P : tSort ?). λ (Pᵗ : (R0) -> tSort ?). let X := R1 : tSort ? in 
let Xᵗ := R1 : (R0) -> tSort ? in 
let Y := R1 : tSort ? in 
let Yᵗ := R1 : (R0) -> tSort ? in 
λ (f : ∀ (Q : (tSort ?) -> (tSort ?) -> tSort ?), ((R0) [R2;R4;])). ∀ (Q : (tSort ?) -> (tSort ?) -> tSort ?), ∀ (Qᵗ : (tSort ?) -> ((R0) -> tSort ?) -> (tSort ?) -> ((R0) -> tSort ?) -> (((R4) [R3;R1;])) -> tSort ?), ((R0) [R4;R3;R6;R5;((R2) [R1;]);])
λ (P : tSort ?). λ (Pᵗ : (R0) -> tSort ?). let X := R1 : tSort ? in 
let Xᵗ := R1 : (R0) -> tSort ? in 
let Y := R1 : tSort ? in 
let Yᵗ := R1 : (R0) -> tSort ? in 
λ (f : ∀ (Q : (tSort ?) -> (tSort ?) -> tSort ?), ((R0) [R2;R4;])). ∀ (Q : (tSort ?) -> (tSort ?) -> tSort ?), ∀ (Qᵗ : (tSort ?) -> ((R0) -> tSort ?) -> (tSort ?) -> ((R0) -> tSort ?) -> (((R4) [R3;R1;])) -> tSort ?), ((R0) [R4;R3;R6;R5;((R2) [R1;]);])
λ (P : tSort ?). λ (Pᵗ : (R0) -> tSort ?). let X := R1 : tSort ? in 
let Xᵗ := R1 : (R0) -> tSort ? in 
let Y := R1 : tSort ? in 
let Yᵗ := R1 : (R0) -> tSort ? in 
λ (f : ∀ (Q : (tSort ?) -> (tSort ?) -> tSort ?), ((R0) [R2;R4;])). ∀ (Q : (tSort ?) -> (tSort ?) -> tSort ?), ∀ (Qᵗ : (tSort ?) -> ((R0) -> tSort ?) -> (tSort ?) -> ((R0) -> tSort ?) -> (((R4) [R3;R1;])) -> tSort ?), ((R0) [R4;R3;R6;R5;((R2) [R1;]);])

equal:  true
=====================

(tSort
   {|
   Universe.t_set := {|
                     UnivExprSet.this := [UnivExpr.npe
                                            (NoPropLevel.Level
                                               "MetaCoq.Translations.param_comp.1129",
                                            false)];
                     UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                            (UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "MetaCoq.Translations.param_comp.1129",
                                               false)) |};
   Universe.t_ne := Logic.eq_refl |})
tSort ?
λ (X : tSort ?). (R0) -> tSort ?
λ (A : tSort ?). (R0) -> tSort ?
λ (X : tSort ?). (R0) -> tSort ?

equal:  true
=====================

finished
     = ?Goal
     : ?T
param_comp.vo (real: 142.80, user: 141.00, sys: 0.44, mem: 657612 ko)
COQC param_eq.v
param_eq.vo (real: 3.94, user: 3.39, sys: 0.43, mem: 564620 ko)
COQC param_exists_test.v
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.nat"
"Looking up Coq.Init.Datatypes.bool"
"Looking up MetaCoq.Translations.param_exists_test.augTest"
Complete Identifier: MetaCoq.Translations.param_exists_test.augTest
Short Identifier: augTest
"Translate MetaCoq.Translations.param_exists_test.augTest"
(IndRef
   {|
   inductive_mind := (MPfile ["param_exists_test"; "Translations"; "MetaCoq"],
                     "augTest");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 0;
ind_params := [];
ind_bodies := [{|
               ind_name := "augTestᴱ";
               ind_type := tProd nAnon
                             (tApp
                                (tInd
                                   {|
                                   inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "augTest");
                                   inductive_ind := 0 |} []) [])
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                Universe.t_ne := eq_refl |});
               ind_kelim := InType;
               ind_ctors := [];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [];
                    LevelSet.is_ok := LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_exists_test.augTest has been translated.
Inductive augTestᴱ : augTest -> Set :=  
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.nat"
Complete Identifier: Coq.Init.Datatypes.nat
Short Identifier: nat
"Translate Coq.Init.Datatypes.nat"
(IndRef
   {|
   inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "nat");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 0;
ind_params := [];
ind_bodies := [{|
               ind_name := "natᴱ";
               ind_type := tProd nAnon
                             (tApp
                                (tInd
                                   {|
                                   inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                   inductive_ind := 0 |} []) [])
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                Universe.t_ne := eq_refl |});
               ind_kelim := InType;
               ind_ctors := [("Sᴱ0",
                             tProd nAnon
                               (tInd
                                  {|
                                  inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                  inductive_ind := 0 |} [])
                               (tProd nAnon (tApp (tRel 1) [tRel 0])
                                  (tApp (tRel 2)
                                     [tApp
                                        (tConstruct
                                           {|
                                           inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                           inductive_ind := 0 |} 1 [])
                                        [tRel 1]])), 2)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [];
                    LevelSet.is_ok := LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
Coq.Init.Datatypes.nat has been translated.
Inductive natᴱ : nat -> Set :=  Sᴱ0 : forall H : nat, natᴱ H -> natᴱ (S H)

Arguments natᴱ _%nat_scope
Arguments Sᴱ0 _%nat_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up MetaCoq.Translations.param_exists_test.Prod1"
Complete Identifier: MetaCoq.Translations.param_exists_test.Prod1
Short Identifier: Prod1
"Translate MetaCoq.Translations.param_exists_test.Prod1"
(IndRef
   {|
   inductive_mind := (MPfile ["param_exists_test"; "Translations"; "MetaCoq"],
                     "Prod1");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Xᴱ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "X";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "Prod1ᴱ";
               ind_type := tProd (nNamed "X")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Xᴱ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tApp
                                      (tInd
                                         {|
                                         inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Prod1");
                                         inductive_ind := 0 |} []) [
                                      tRel 1])
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |})));
               ind_kelim := InType;
               ind_ctors := [("Conᴱ0",
                             tProd (nNamed "X")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Xᴱ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tProd (nNamed "x1") 
                                     (tRel 1)
                                     (tProd (nNamed "x2") 
                                        (tRel 2)
                                        (tProd nAnon 
                                           (tApp (tRel 2) [tRel 1])
                                           (tApp (tRel 5)
                                              [tRel 4; 
                                              tRel 3;
                                              tApp
                                                (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Prod1");
                                                 inductive_ind := 0 |} 0 [])
                                                [tRel 4; tRel 2; tRel 1]]))))),
                             3);
                            ("Conᴱ1",
                            tProd (nNamed "X")
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |})
                              (tProd (nNamed "Xᴱ")
                                 (tProd nAnon (tRel 0)
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.4",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |}))
                                 (tProd (nNamed "x1") 
                                    (tRel 1)
                                    (tProd (nNamed "x2") 
                                       (tRel 2)
                                       (tProd nAnon 
                                          (tApp (tRel 2) [tRel 0])
                                          (tApp (tRel 5)
                                             [tRel 4; 
                                             tRel 3;
                                             tApp
                                               (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Prod1");
                                                 inductive_ind := 0 |} 0 [])
                                               [tRel 4; tRel 2; tRel 1]]))))),
                            3)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level
                                        "MetaCoq.Translations.param_exists_test.4"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok (s:=[])
                                        (Level.Level
                                           "MetaCoq.Translations.param_exists_test.4")
                                        LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_exists_test.Prod1 has been translated.
Inductive Prod1ᴱ (X : Type) (Xᴱ : X -> Type) : Prod1 X -> Type :=
    Conᴱ0 : forall x1 x2 : X, Xᴱ x1 -> Prod1ᴱ X Xᴱ (Con X x1 x2)
  | Conᴱ1 : forall x1 x2 : X, Xᴱ x2 -> Prod1ᴱ X Xᴱ (Con X x1 x2)

Arguments Prod1ᴱ _%type_scope _%function_scope
Arguments Conᴱ0 _%type_scope _%function_scope
Arguments Conᴱ1 _%type_scope _%function_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up MetaCoq.Translations.param_exists_test.Prod"
Complete Identifier: MetaCoq.Translations.param_exists_test.Prod
Short Identifier: Prod
"Translate MetaCoq.Translations.param_exists_test.Prod"
(IndRef
   {|
   inductive_mind := (MPfile ["param_exists_test"; "Translations"; "MetaCoq"],
                     "Prod");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 4;
ind_params := [{|
               decl_name := nNamed "Yᴱ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "Y";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |};
              {|
              decl_name := nNamed "Xᴱ";
              decl_body := None;
              decl_type := tProd nAnon (tRel 0)
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)) |};
                                Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "X";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "Prodᴱ";
               ind_type := tProd (nNamed "X")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Xᴱ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd (nNamed "Y")
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |})
                                   (tProd (nNamed "Yᴱ")
                                      (tProd nAnon 
                                         (tRel 0)
                                         (tSort
                                            {|
                                            Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)) |};
                                            Universe.t_ne := eq_refl |}))
                                      (tProd nAnon
                                         (tApp
                                            (tInd
                                               {|
                                               inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Prod");
                                               inductive_ind := 0 |} [])
                                            [tRel 3; tRel 1])
                                         (tSort
                                            {|
                                            Universe.t_set := {|
                                                 UnivExprSet.this := [
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false);
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.add_ok
                                                 (s:=[UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)])
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false))
                                                 (UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false))) |};
                                            Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false))
                                                 {|
                                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)) |};
                                                 Universe.t_ne := eq_refl |} |})))));
               ind_kelim := InType;
               ind_ctors := [("pairᴱ0",
                             tProd (nNamed "X")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Xᴱ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tProd (nNamed "Y")
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |})
                                     (tProd (nNamed "Yᴱ")
                                        (tProd nAnon 
                                           (tRel 0)
                                           (tSort
                                              {|
                                              Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)) |};
                                              Universe.t_ne := eq_refl |}))
                                        (tProd (nNamed "x") 
                                           (tRel 3)
                                           (tProd 
                                              (nNamed "y") 
                                              (tRel 2)
                                              (tProd nAnon
                                                 (tApp (tRel 4) [tRel 1])
                                                 (tApp 
                                                 (tRel 7)
                                                 [
                                                 tRel 6; 
                                                 tRel 5; 
                                                 tRel 4; 
                                                 tRel 3;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Prod");
                                                 inductive_ind := 0 |} 0 [])
                                                 [
                                                 tRel 6; 
                                                 tRel 4; 
                                                 tRel 2; 
                                                 tRel 1]]))))))), 3);
                            ("pairᴱ1",
                            tProd (nNamed "X")
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |})
                              (tProd (nNamed "Xᴱ")
                                 (tProd nAnon (tRel 0)
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.8",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |}))
                                 (tProd (nNamed "Y")
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |})
                                    (tProd (nNamed "Yᴱ")
                                       (tProd nAnon 
                                          (tRel 0)
                                          (tSort
                                             {|
                                             Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.9",
                                                 false)) |};
                                             Universe.t_ne := eq_refl |}))
                                       (tProd (nNamed "x") 
                                          (tRel 3)
                                          (tProd (nNamed "y") 
                                             (tRel 2)
                                             (tProd nAnon
                                                (tApp (tRel 2) [tRel 0])
                                                (tApp 
                                                 (tRel 7)
                                                 [
                                                 tRel 6; 
                                                 tRel 5; 
                                                 tRel 4; 
                                                 tRel 3;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Prod");
                                                 inductive_ind := 0 |} 0 [])
                                                 [
                                                 tRel 6; 
                                                 tRel 4; 
                                                 tRel 2; 
                                                 tRel 1]]))))))), 3)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level
                                        "MetaCoq.Translations.param_exists_test.8";
                                     Level.Level
                                       "MetaCoq.Translations.param_exists_test.9"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok
                                        (s:=[Level.Level
                                               "MetaCoq.Translations.param_exists_test.8"])
                                        (Level.Level
                                           "MetaCoq.Translations.param_exists_test.9")
                                        (LevelSet.Raw.add_ok (s:=[])
                                           (Level.Level
                                              "MetaCoq.Translations.param_exists_test.8")
                                           LevelSet.Raw.empty_ok) |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_exists_test.Prod has been translated.
Inductive
Prodᴱ (X : Type) (Xᴱ : X -> Type) (Y : Type) (Yᴱ : Y -> Type)
  : Prod X Y -> Type :=
    pairᴱ0 : forall (x : X) (y : Y), Xᴱ x -> Prodᴱ X Xᴱ Y Yᴱ (pair X Y x y)
  | pairᴱ1 : forall (x : X) (y : Y), Yᴱ y -> Prodᴱ X Xᴱ Y Yᴱ (pair X Y x y)

Arguments Prodᴱ _%type_scope _%function_scope _%type_scope _%function_scope
Arguments pairᴱ0 _%type_scope _%function_scope _%type_scope _%function_scope
Arguments pairᴱ1 _%type_scope _%function_scope _%type_scope _%function_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up MetaCoq.Translations.param_exists_test.List"
Complete Identifier: MetaCoq.Translations.param_exists_test.List
Short Identifier: List
"Translate MetaCoq.Translations.param_exists_test.List"
(IndRef
   {|
   inductive_mind := (MPfile ["param_exists_test"; "Translations"; "MetaCoq"],
                     "List");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Xᴱ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "X";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "Listᴱ";
               ind_type := tProd (nNamed "X")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Xᴱ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tApp
                                      (tInd
                                         {|
                                         inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "List");
                                         inductive_ind := 0 |} []) [
                                      tRel 1])
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                      Universe.t_ne := eq_refl |})));
               ind_kelim := InType;
               ind_ctors := [("consLᴱ0",
                             tProd (nNamed "X")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Xᴱ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tProd (nNamed "x") 
                                     (tRel 1)
                                     (tProd (nNamed "xs")
                                        (tApp
                                           (tInd
                                              {|
                                              inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "List");
                                              inductive_ind := 0 |} [])
                                           [tRel 2])
                                        (tProd nAnon 
                                           (tApp (tRel 2) [tRel 1])
                                           (tApp (tRel 5)
                                              [tRel 4; 
                                              tRel 3;
                                              tApp
                                                (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "List");
                                                 inductive_ind := 0 |} 1 [])
                                                [tRel 4; tRel 2; tRel 1]]))))),
                             3);
                            ("consLᴱ1",
                            tProd (nNamed "X")
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                 Universe.t_ne := eq_refl |})
                              (tProd (nNamed "Xᴱ")
                                 (tProd nAnon (tRel 0)
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                       Universe.t_ne := eq_refl |}))
                                 (tProd (nNamed "x") 
                                    (tRel 1)
                                    (tProd (nNamed "xs")
                                       (tApp
                                          (tInd
                                             {|
                                             inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "List");
                                             inductive_ind := 0 |} [])
                                          [tRel 2])
                                       (tProd nAnon
                                          (tApp (tRel 4)
                                             [tRel 3; tRel 2; tRel 0])
                                          (tApp (tRel 5)
                                             [tRel 4; 
                                             tRel 3;
                                             tApp
                                               (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "List");
                                                 inductive_ind := 0 |} 1 [])
                                               [tRel 4; tRel 2; tRel 1]]))))),
                            3)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [];
                    LevelSet.is_ok := LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_exists_test.List has been translated.
Inductive Listᴱ (X : Set) (Xᴱ : X -> Set) : List X -> Set :=
    consLᴱ0 : forall (x : X) (xs : List X), Xᴱ x -> Listᴱ X Xᴱ (consL X x xs)
  | consLᴱ1 : forall (x : X) (xs : List X),
              Listᴱ X Xᴱ xs -> Listᴱ X Xᴱ (consL X x xs)

Arguments Listᴱ _%type_scope _%function_scope
Arguments consLᴱ0 _%type_scope _%function_scope
Arguments consLᴱ1 _%type_scope _%function_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up MetaCoq.Translations.param_exists_test.Complex"
Complete Identifier: MetaCoq.Translations.param_exists_test.Complex
Short Identifier: Complex
"Translate MetaCoq.Translations.param_exists_test.Complex"
(IndRef
   {|
   inductive_mind := (MPfile ["param_exists_test"; "Translations"; "MetaCoq"],
                     "Complex");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 4;
ind_params := [{|
               decl_name := nNamed "Yᴱ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "Y";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |};
              {|
              decl_name := nNamed "Xᴱ";
              decl_body := None;
              decl_type := tProd nAnon (tRel 0)
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                                Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "X";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "Complexᴱ";
               ind_type := tProd (nNamed "X")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Xᴱ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd (nNamed "Y")
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |})
                                   (tProd (nNamed "Yᴱ")
                                      (tProd nAnon 
                                         (tRel 0)
                                         (tSort
                                            {|
                                            Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                                            Universe.t_ne := eq_refl |}))
                                      (tProd nAnon
                                         (tApp
                                            (tInd
                                               {|
                                               inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Complex");
                                               inductive_ind := 0 |} [])
                                            [tRel 3; tRel 1])
                                         (tSort
                                            {|
                                            Universe.t_set := {|
                                                 UnivExprSet.this := [
                                                 UnivExpr.npe
                                                 (NoPropLevel.lSet, false);
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false);
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.add_ok
                                                 (s:=[
                                                 UnivExpr.npe
                                                 (NoPropLevel.lSet, false);
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)])
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false))
                                                 (UnivExprSet.Raw.add_ok
                                                 (s:=[
                                                 UnivExpr.npe
                                                 (NoPropLevel.lSet, false)])
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false))
                                                 (UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)))) |};
                                            Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false))
                                                 {|
                                                 Universe.t_set := {|
                                                 UnivExprSet.this := [
                                                 UnivExpr.npe
                                                 (NoPropLevel.lSet, false);
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.add_ok
                                                 (s:=[UnivExpr.npe
                                                 (NoPropLevel.lSet, false)])
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false))
                                                 (UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false))) |};
                                                 Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false))
                                                 {|
                                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                                 Universe.t_ne := eq_refl |} |} |})))));
               ind_kelim := InType;
               ind_ctors := [("ACᴱ0",
                             tProd (nNamed "X")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Xᴱ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tProd (nNamed "Y")
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |})
                                     (tProd (nNamed "Yᴱ")
                                        (tProd nAnon 
                                           (tRel 0)
                                           (tSort
                                              {|
                                              Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                                              Universe.t_ne := eq_refl |}))
                                        (tProd (nNamed "x") 
                                           (tRel 3)
                                           (tProd nAnon
                                              (tApp (tRel 3) [tRel 0])
                                              (tApp 
                                                 (tRel 6)
                                                 [
                                                 tRel 5; 
                                                 tRel 4; 
                                                 tRel 3; 
                                                 tRel 2;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Complex");
                                                 inductive_ind := 0 |} 0 [])
                                                 [tRel 5; tRel 3; tRel 1]])))))),
                             2);
                            ("BCᴱ0",
                            tProd (nNamed "X")
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |})
                              (tProd (nNamed "Xᴱ")
                                 (tProd nAnon (tRel 0)
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |}))
                                 (tProd (nNamed "Y")
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |})
                                    (tProd (nNamed "Yᴱ")
                                       (tProd nAnon 
                                          (tRel 0)
                                          (tSort
                                             {|
                                             Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                                             Universe.t_ne := eq_refl |}))
                                       (tProd (nNamed "x") 
                                          (tRel 3)
                                          (tProd (nNamed "y1") 
                                             (tRel 2)
                                             (tProd 
                                                (nNamed "y2") 
                                                (tRel 3)
                                                (tProd nAnon
                                                 (tApp (tRel 5) [tRel 2])
                                                 (tApp 
                                                 (tRel 8)
                                                 [
                                                 tRel 7; 
                                                 tRel 6; 
                                                 tRel 5; 
                                                 tRel 4;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Complex");
                                                 inductive_ind := 0 |} 1 [])
                                                 [
                                                 tRel 7; 
                                                 tRel 5; 
                                                 tRel 3; 
                                                 tRel 2; 
                                                 tRel 1]])))))))), 4);
                            ("BCᴱ1",
                            tProd (nNamed "X")
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |})
                              (tProd (nNamed "Xᴱ")
                                 (tProd nAnon (tRel 0)
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |}))
                                 (tProd (nNamed "Y")
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |})
                                    (tProd (nNamed "Yᴱ")
                                       (tProd nAnon 
                                          (tRel 0)
                                          (tSort
                                             {|
                                             Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                                             Universe.t_ne := eq_refl |}))
                                       (tProd (nNamed "x") 
                                          (tRel 3)
                                          (tProd (nNamed "y1") 
                                             (tRel 2)
                                             (tProd 
                                                (nNamed "y2") 
                                                (tRel 3)
                                                (tProd nAnon
                                                 (tApp (tRel 3) [tRel 1])
                                                 (tApp 
                                                 (tRel 8)
                                                 [
                                                 tRel 7; 
                                                 tRel 6; 
                                                 tRel 5; 
                                                 tRel 4;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Complex");
                                                 inductive_ind := 0 |} 1 [])
                                                 [
                                                 tRel 7; 
                                                 tRel 5; 
                                                 tRel 3; 
                                                 tRel 2; 
                                                 tRel 1]])))))))), 4);
                            ("BCᴱ2",
                            tProd (nNamed "X")
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |})
                              (tProd (nNamed "Xᴱ")
                                 (tProd nAnon (tRel 0)
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |}))
                                 (tProd (nNamed "Y")
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |})
                                    (tProd (nNamed "Yᴱ")
                                       (tProd nAnon 
                                          (tRel 0)
                                          (tSort
                                             {|
                                             Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                                             Universe.t_ne := eq_refl |}))
                                       (tProd (nNamed "x") 
                                          (tRel 3)
                                          (tProd (nNamed "y1") 
                                             (tRel 2)
                                             (tProd 
                                                (nNamed "y2") 
                                                (tRel 3)
                                                (tProd nAnon
                                                 (tApp (tRel 3) [tRel 0])
                                                 (tApp 
                                                 (tRel 8)
                                                 [
                                                 tRel 7; 
                                                 tRel 6; 
                                                 tRel 5; 
                                                 tRel 4;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Complex");
                                                 inductive_ind := 0 |} 1 [])
                                                 [
                                                 tRel 7; 
                                                 tRel 5; 
                                                 tRel 3; 
                                                 tRel 2; 
                                                 tRel 1]])))))))), 4);
                            ("CCᴱ0",
                            tProd (nNamed "X")
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |})
                              (tProd (nNamed "Xᴱ")
                                 (tProd nAnon (tRel 0)
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |}))
                                 (tProd (nNamed "Y")
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |})
                                    (tProd (nNamed "Yᴱ")
                                       (tProd nAnon 
                                          (tRel 0)
                                          (tSort
                                             {|
                                             Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                                             Universe.t_ne := eq_refl |}))
                                       (tProd (nNamed "y") 
                                          (tRel 1)
                                          (tProd (nNamed "c")
                                             (tApp
                                                (tInd
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Complex");
                                                 inductive_ind := 0 |} [])
                                                [tRel 4; tRel 2])
                                             (tProd nAnon
                                                (tApp (tRel 2) [tRel 1])
                                                (tApp 
                                                 (tRel 7)
                                                 [
                                                 tRel 6; 
                                                 tRel 5; 
                                                 tRel 4; 
                                                 tRel 3;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Complex");
                                                 inductive_ind := 0 |} 2 [])
                                                 [
                                                 tRel 6; 
                                                 tRel 4; 
                                                 tRel 2; 
                                                 tRel 1]]))))))), 3);
                            ("CCᴱ1",
                            tProd (nNamed "X")
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |})
                              (tProd (nNamed "Xᴱ")
                                 (tProd nAnon (tRel 0)
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.16",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |}))
                                 (tProd (nNamed "Y")
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |})
                                    (tProd (nNamed "Yᴱ")
                                       (tProd nAnon 
                                          (tRel 0)
                                          (tSort
                                             {|
                                             Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.17",
                                                 false)) |};
                                             Universe.t_ne := eq_refl |}))
                                       (tProd (nNamed "y") 
                                          (tRel 1)
                                          (tProd (nNamed "c")
                                             (tApp
                                                (tInd
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Complex");
                                                 inductive_ind := 0 |} [])
                                                [tRel 4; tRel 2])
                                             (tProd nAnon
                                                (tApp 
                                                 (tRel 6)
                                                 [
                                                 tRel 5; 
                                                 tRel 4; 
                                                 tRel 3; 
                                                 tRel 2; 
                                                 tRel 0])
                                                (tApp 
                                                 (tRel 7)
                                                 [
                                                 tRel 6; 
                                                 tRel 5; 
                                                 tRel 4; 
                                                 tRel 3;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Complex");
                                                 inductive_ind := 0 |} 2 [])
                                                 [
                                                 tRel 6; 
                                                 tRel 4; 
                                                 tRel 2; 
                                                 tRel 1]]))))))), 3)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level
                                        "MetaCoq.Translations.param_exists_test.16";
                                     Level.Level
                                       "MetaCoq.Translations.param_exists_test.17"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok
                                        (s:=[Level.Level
                                               "MetaCoq.Translations.param_exists_test.16"])
                                        (Level.Level
                                           "MetaCoq.Translations.param_exists_test.17")
                                        (LevelSet.Raw.add_ok (s:=[])
                                           (Level.Level
                                              "MetaCoq.Translations.param_exists_test.16")
                                           LevelSet.Raw.empty_ok) |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_exists_test.Complex has been translated.
Inductive
Complexᴱ (X : Type) (Xᴱ : X -> Type) (Y : Type) (Yᴱ : Y -> Type)
  : Complex X Y -> Type :=
    ACᴱ0 : forall x : X, Xᴱ x -> Complexᴱ X Xᴱ Y Yᴱ (AC X Y x)
  | BCᴱ0 : forall (x : X) (y1 y2 : Y),
           Xᴱ x -> Complexᴱ X Xᴱ Y Yᴱ (BC X Y x y1 y2)
  | BCᴱ1 : forall (x : X) (y1 y2 : Y),
           Yᴱ y1 -> Complexᴱ X Xᴱ Y Yᴱ (BC X Y x y1 y2)
  | BCᴱ2 : forall (x : X) (y1 y2 : Y),
           Yᴱ y2 -> Complexᴱ X Xᴱ Y Yᴱ (BC X Y x y1 y2)
  | CCᴱ0 : forall (y : Y) (c : Complex X Y),
           Yᴱ y -> Complexᴱ X Xᴱ Y Yᴱ (CC X Y y c)
  | CCᴱ1 : forall (y : Y) (c : Complex X Y),
           Complexᴱ X Xᴱ Y Yᴱ c -> Complexᴱ X Xᴱ Y Yᴱ (CC X Y y c)

Arguments Complexᴱ _%type_scope _%function_scope _%type_scope
  _%function_scope
Arguments ACᴱ0 _%type_scope _%function_scope _%type_scope _%function_scope
Arguments BCᴱ0 _%type_scope _%function_scope _%type_scope _%function_scope
Arguments BCᴱ1 _%type_scope _%function_scope _%type_scope _%function_scope
Arguments BCᴱ2 _%type_scope _%function_scope _%type_scope _%function_scope
Arguments CCᴱ0 _%type_scope _%function_scope _%type_scope _%function_scope
Arguments CCᴱ1 _%type_scope _%function_scope _%type_scope _%function_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.nat"
"Looking up MetaCoq.Translations.param_exists_test.G"
Complete Identifier: MetaCoq.Translations.param_exists_test.G
Short Identifier: G
"Translate MetaCoq.Translations.param_exists_test.G"
(IndRef
   {|
   inductive_mind := (MPfile ["param_exists_test"; "Translations"; "MetaCoq"],
                     "G");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Xᴱ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "X";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "Gᴱ";
               ind_type := tProd (nNamed "X")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Xᴱ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tApp
                                      (tInd
                                         {|
                                         inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "G");
                                         inductive_ind := 0 |} []) [
                                      tRel 1])
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                      Universe.t_ne := eq_refl |})));
               ind_kelim := InType;
               ind_ctors := [("GIᴱ0",
                             tProd (nNamed "X")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Xᴱ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tProd (nNamed "f")
                                     (tProd nAnon
                                        (tInd
                                           {|
                                           inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                           inductive_ind := 0 |} []) 
                                        (tRel 2))
                                     (tProd nAnon
                                        (tApp
                                           (tInd
                                              {|
                                              inductive_mind := (
                                                 MPfile
                                                 ["Specif"; "Init"; "Coq"],
                                                 "sigT");
                                              inductive_ind := 0 |} [])
                                           [tInd
                                              {|
                                              inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                              inductive_ind := 0 |} [];
                                           tLambda nAnon
                                             (tInd
                                                {|
                                                inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                                inductive_ind := 0 |} [])
                                             (tApp 
                                                (tRel 2)
                                                [tApp (tRel 1) [tRel 0]])])
                                        (tApp (tRel 4)
                                           [tRel 3; 
                                           tRel 2;
                                           tApp
                                             (tConstruct
                                                {|
                                                inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "G");
                                                inductive_ind := 0 |} 0 [])
                                             [tRel 3; tRel 1]])))), 2)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [];
                    LevelSet.is_ok := LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_exists_test.G has been translated.
Inductive Gᴱ (X : Set) (Xᴱ : X -> Set) : G X -> Set :=
    GIᴱ0 : forall f : nat -> X, (∑ H : nat, Xᴱ (f H)) -> Gᴱ X Xᴱ (GI X f)

Arguments Gᴱ _%type_scope _%function_scope
Arguments GIᴱ0 _%type_scope (_ _)%function_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up MetaCoq.Translations.param_exists_test.List"
"Looking up MetaCoq.Translations.param_exists_test.R"
Complete Identifier: MetaCoq.Translations.param_exists_test.R
Short Identifier: R
"Translate MetaCoq.Translations.param_exists_test.R"
(IndRef
   {|
   inductive_mind := (MPfile ["param_exists_test"; "Translations"; "MetaCoq"],
                     "R");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Xᴱ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "X";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "Rᴱ";
               ind_type := tProd (nNamed "X")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Xᴱ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tApp
                                      (tInd
                                         {|
                                         inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "R");
                                         inductive_ind := 0 |} []) [
                                      tRel 1])
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                      Universe.t_ne := eq_refl |})));
               ind_kelim := InType;
               ind_ctors := [("Tᴱ0",
                             tProd (nNamed "X")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Xᴱ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tProd (nNamed "xs")
                                     (tApp
                                        (tInd
                                           {|
                                           inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "List");
                                           inductive_ind := 0 |} []) [
                                        tRel 1])
                                     (tProd nAnon
                                        (tApp
                                           (tInd
                                              {|
                                              inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Listᴱ");
                                              inductive_ind := 0 |} [])
                                           [tRel 2; tRel 1; tRel 0])
                                        (tApp (tRel 4)
                                           [tRel 3; 
                                           tRel 2;
                                           tApp
                                             (tConstruct
                                                {|
                                                inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "R");
                                                inductive_ind := 0 |} 0 [])
                                             [tRel 3; tRel 1]])))), 2)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [];
                    LevelSet.is_ok := LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_exists_test.R has been translated.
Inductive Rᴱ (X : Set) (Xᴱ : X -> Set) : R X -> Set :=
    Tᴱ0 : forall xs : List X, Listᴱ X Xᴱ xs -> Rᴱ X Xᴱ (T X xs)

Arguments Rᴱ _%type_scope _%function_scope
Arguments Tᴱ0 _%type_scope _%function_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.nat"
"Looking up MetaCoq.Translations.param_exists_test.F"
Complete Identifier: MetaCoq.Translations.param_exists_test.F
Short Identifier: F
"Translate MetaCoq.Translations.param_exists_test.F"
(IndRef
   {|
   inductive_mind := (MPfile ["param_exists_test"; "Translations"; "MetaCoq"],
                     "F");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "FTᴱ";
               decl_body := None;
               decl_type := tProd nAnon
                              (tInd
                                 {|
                                 inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                 inductive_ind := 0 |} [])
                              (tProd nAnon (tApp (tRel 1) [tRel 0])
                                 (tSort
                                    {|
                                    Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.29",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.29",
                                                 false)) |};
                                    Universe.t_ne := eq_refl |})) |};
              {|
              decl_name := nNamed "FT";
              decl_body := None;
              decl_type := tProd nAnon
                             (tInd
                                {|
                                inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                inductive_ind := 0 |} [])
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.29",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.29",
                                                 false)) |};
                                Universe.t_ne := eq_refl |}) |}];
ind_bodies := [{|
               ind_name := "Fᴱ";
               ind_type := tProd (nNamed "FT")
                             (tProd nAnon
                                (tInd
                                   {|
                                   inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                   inductive_ind := 0 |} [])
                                (tSort
                                   {|
                                   Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.29",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.29",
                                                 false)) |};
                                   Universe.t_ne := eq_refl |}))
                             (tProd (nNamed "FTᴱ")
                                (tProd nAnon
                                   (tInd
                                      {|
                                      inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                      inductive_ind := 0 |} [])
                                   (tProd nAnon (tApp (tRel 1) [tRel 0])
                                      (tSort
                                         {|
                                         Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.29",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.29",
                                                 false)) |};
                                         Universe.t_ne := eq_refl |})))
                                (tProd nAnon
                                   (tApp
                                      (tInd
                                         {|
                                         inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "F");
                                         inductive_ind := 0 |} []) [
                                      tRel 1])
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.29",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.29",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |})));
               ind_kelim := InType;
               ind_ctors := [("FIᴱ0",
                             tProd (nNamed "FT")
                               (tProd nAnon
                                  (tInd
                                     {|
                                     inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                     inductive_ind := 0 |} [])
                                  (tSort
                                     {|
                                     Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.29",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.29",
                                                 false)) |};
                                     Universe.t_ne := eq_refl |}))
                               (tProd (nNamed "FTᴱ")
                                  (tProd nAnon
                                     (tInd
                                        {|
                                        inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                        inductive_ind := 0 |} [])
                                     (tProd nAnon 
                                        (tApp (tRel 1) [tRel 0])
                                        (tSort
                                           {|
                                           Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.29",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.29",
                                                 false)) |};
                                           Universe.t_ne := eq_refl |})))
                                  (tProd (nNamed "x")
                                     (tApp (tRel 1)
                                        [tConstruct
                                           {|
                                           inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                           inductive_ind := 0 |} 0 []])
                                     (tProd nAnon
                                        (tApp (tRel 1)
                                           [tConstruct
                                              {|
                                              inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                              inductive_ind := 0 |} 0 [];
                                           tRel 0])
                                        (tApp (tRel 4)
                                           [tRel 3; 
                                           tRel 2;
                                           tApp
                                             (tConstruct
                                                {|
                                                inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "F");
                                                inductive_ind := 0 |} 0 [])
                                             [tRel 3; tRel 1]])))), 2)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level
                                        "MetaCoq.Translations.param_exists_test.29"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok (s:=[])
                                        (Level.Level
                                           "MetaCoq.Translations.param_exists_test.29")
                                        LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_exists_test.F has been translated.
Inductive
Fᴱ (FT : nat -> Type) (FTᴱ : forall H : nat, FT H -> Type) : F FT -> Type :=
    FIᴱ0 : forall x : FT 0, FTᴱ 0 x -> Fᴱ FT FTᴱ (FI FT x)

Arguments Fᴱ (_ _)%function_scope
Arguments FIᴱ0 (_ _)%function_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.nat"
"Looking up MetaCoq.Translations.param_exists_test.Ind"
Complete Identifier: MetaCoq.Translations.param_exists_test.Ind
Short Identifier: Ind
"Translate MetaCoq.Translations.param_exists_test.Ind"
(IndRef
   {|
   inductive_mind := (MPfile ["param_exists_test"; "Translations"; "MetaCoq"],
                     "Ind");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Xᴱ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.33",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.33",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "X";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.33",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.33",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "Indᴱ";
               ind_type := tProd (nNamed "X")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.33",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.33",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Xᴱ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.33",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.33",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tInd
                                      {|
                                      inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                      inductive_ind := 0 |} [])
                                   (tProd nAnon
                                      (tApp
                                         (tInd
                                            {|
                                            inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Ind");
                                            inductive_ind := 0 |} [])
                                         [tRel 2; tRel 0])
                                      (tSort
                                         {|
                                         Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.lProp];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 UnivExpr.lProp |};
                                         Universe.t_ne := eq_refl |}))));
               ind_kelim := InType;
               ind_ctors := [];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level
                                        "MetaCoq.Translations.param_exists_test.33"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok (s:=[])
                                        (Level.Level
                                           "MetaCoq.Translations.param_exists_test.33")
                                        LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_exists_test.Ind has been translated.
Inductive
Indᴱ (X : Type) (Xᴱ : X -> Type) : forall H : nat, Ind X H -> Prop :=
  

Arguments Indᴱ _%type_scope _%function_scope _%nat_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.nat"
"Looking up MetaCoq.Translations.param_exists_test.Ind2"
Complete Identifier: MetaCoq.Translations.param_exists_test.Ind2
Short Identifier: Ind2
"Translate MetaCoq.Translations.param_exists_test.Ind2"
(IndRef
   {|
   inductive_mind := (MPfile ["param_exists_test"; "Translations"; "MetaCoq"],
                     "Ind2");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Xᴱ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.36",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.36",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "X";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.36",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.36",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "Ind2ᴱ";
               ind_type := tProd (nNamed "X")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.36",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.36",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Xᴱ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.36",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.36",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tInd
                                      {|
                                      inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                      inductive_ind := 0 |} [])
                                   (tProd nAnon
                                      (tApp
                                         (tInd
                                            {|
                                            inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Ind2");
                                            inductive_ind := 0 |} [])
                                         [tRel 2; tRel 0])
                                      (tSort
                                         {|
                                         Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.36",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.36",
                                                 false)) |};
                                         Universe.t_ne := eq_refl |}))));
               ind_kelim := InType;
               ind_ctors := [("IndC2ᴱ0",
                             tProd (nNamed "X")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.36",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.36",
                                                 false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Xᴱ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.36",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.36",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tProd (nNamed "x") 
                                     (tRel 1)
                                     (tProd nAnon 
                                        (tApp (tRel 1) [tRel 0])
                                        (tApp (tRel 4)
                                           [tRel 3; 
                                           tRel 2;
                                           tConstruct
                                             {|
                                             inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                             inductive_ind := 0 |} 0 [];
                                           tApp
                                             (tConstruct
                                                {|
                                                inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Ind2");
                                                inductive_ind := 0 |} 0 [])
                                             [tRel 3; tRel 1]])))), 2)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level
                                        "MetaCoq.Translations.param_exists_test.36"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok (s:=[])
                                        (Level.Level
                                           "MetaCoq.Translations.param_exists_test.36")
                                        LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_exists_test.Ind2 has been translated.
Inductive
Ind2ᴱ (X : Type) (Xᴱ : X -> Type) : forall H : nat, Ind2 X H -> Type :=
    IndC2ᴱ0 : forall x : X, Xᴱ x -> Ind2ᴱ X Xᴱ 0 (IndC2 X x)

Arguments Ind2ᴱ _%type_scope _%function_scope _%nat_scope
Arguments IndC2ᴱ0 _%type_scope _%function_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.nat"
"Looking up MetaCoq.Translations.param_exists_test.IndT"
Complete Identifier: MetaCoq.Translations.param_exists_test.IndT
Short Identifier: IndT
"Translate MetaCoq.Translations.param_exists_test.IndT"
(IndRef
   {|
   inductive_mind := (MPfile ["param_exists_test"; "Translations"; "MetaCoq"],
                     "IndT");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Xᴱ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.39",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.39",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "X";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.39",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.39",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "IndTᴱ";
               ind_type := tProd (nNamed "X")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.39",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.39",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Xᴱ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.39",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.39",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd (nNamed "Y")
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.40",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.40",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |})
                                   (tProd nAnon
                                      (tApp
                                         (tInd
                                            {|
                                            inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "IndT");
                                            inductive_ind := 0 |} [])
                                         [tRel 2; tRel 0])
                                      (tSort
                                         {|
                                         Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.39",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.39",
                                                 false)) |};
                                         Universe.t_ne := eq_refl |}))));
               ind_kelim := InType;
               ind_ctors := [("IndTCᴱ0",
                             tProd (nNamed "X")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.39",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.39",
                                                 false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Xᴱ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.39",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.39",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tProd (nNamed "x") 
                                     (tRel 1)
                                     (tProd nAnon 
                                        (tApp (tRel 1) [tRel 0])
                                        (tApp (tRel 4)
                                           [tRel 3; 
                                           tRel 2;
                                           tInd
                                             {|
                                             inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                             inductive_ind := 0 |} [];
                                           tApp
                                             (tConstruct
                                                {|
                                                inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "IndT");
                                                inductive_ind := 0 |} 0 [])
                                             [tRel 3; tRel 1]])))), 2)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level
                                        "MetaCoq.Translations.param_exists_test.40";
                                     Level.Level
                                       "MetaCoq.Translations.param_exists_test.39"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok
                                        (s:=[Level.Level
                                               "MetaCoq.Translations.param_exists_test.39"])
                                        (Level.Level
                                           "MetaCoq.Translations.param_exists_test.40")
                                        (LevelSet.Raw.add_ok (s:=[])
                                           (Level.Level
                                              "MetaCoq.Translations.param_exists_test.39")
                                           LevelSet.Raw.empty_ok) |},
                   {|
                   ConstraintSet.this := [(Level.lSet, ConstraintType.Le,
                                          Level.Level
                                            "MetaCoq.Translations.param_exists_test.40")];
                   ConstraintSet.is_ok := ConstraintSet.Raw.add_ok (s:=[])
                                            (Level.lSet, ConstraintType.Le,
                                            Level.Level
                                              "MetaCoq.Translations.param_exists_test.40")
                                            ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_exists_test.IndT has been translated.
Inductive
IndTᴱ (X : Type) (Xᴱ : X -> Type) : forall Y : Type, IndT X Y -> Type :=
    IndTCᴱ0 : forall x : X, Xᴱ x -> IndTᴱ X Xᴱ nat (IndTC X x)

Arguments IndTᴱ _%type_scope _%function_scope _%type_scope
Arguments IndTCᴱ0 _%type_scope _%function_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up MetaCoq.Translations.param_exists_test.TA"
Complete Identifier: MetaCoq.Translations.param_exists_test.TA
Short Identifier: TA
"Translate MetaCoq.Translations.param_exists_test.TA"
(IndRef
   {|
   inductive_mind := (MPfile ["param_exists_test"; "Translations"; "MetaCoq"],
                     "TA");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Xᴱ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "X";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "TAᴱ";
               ind_type := tProd (nNamed "X")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Xᴱ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tApp
                                      (tInd
                                         {|
                                         inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "TA");
                                         inductive_ind := 0 |} []) [
                                      tRel 1])
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.45",
                                                 true);
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.add_ok
                                                 (s:=[UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)])
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.45",
                                                 true))
                                                 (UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false))) |};
                                      Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.45",
                                                 true))
                                                 {|
                                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)) |};
                                                 Universe.t_ne := eq_refl |} |})));
               ind_kelim := InType;
               ind_ctors := [("TACᴱ0",
                             tProd (nNamed "X")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Xᴱ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.43",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tProd (nNamed "x") 
                                     (tRel 1)
                                     (tProd (nNamed "Y")
                                        (tSort
                                           {|
                                           Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.45",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.45",
                                                 false)) |};
                                           Universe.t_ne := eq_refl |})
                                        (tProd (nNamed "y") 
                                           (tRel 0)
                                           (tProd nAnon
                                              (tApp (tRel 3) [tRel 2])
                                              (tApp 
                                                 (tRel 6)
                                                 [
                                                 tRel 5; 
                                                 tRel 4;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "TA");
                                                 inductive_ind := 0 |} 0 [])
                                                 [
                                                 tRel 5; 
                                                 tRel 3; 
                                                 tRel 2; 
                                                 tRel 1]])))))), 4)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level
                                        "MetaCoq.Translations.param_exists_test.45";
                                     Level.Level
                                       "MetaCoq.Translations.param_exists_test.43"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok
                                        (s:=[Level.Level
                                               "MetaCoq.Translations.param_exists_test.43"])
                                        (Level.Level
                                           "MetaCoq.Translations.param_exists_test.45")
                                        (LevelSet.Raw.add_ok (s:=[])
                                           (Level.Level
                                              "MetaCoq.Translations.param_exists_test.43")
                                           LevelSet.Raw.empty_ok) |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_exists_test.TA has been translated.
Inductive TAᴱ (X : Type) (Xᴱ : X -> Type) : TA X -> Type :=
    TACᴱ0 : forall (x : X) (Y : Type) (y : Y), Xᴱ x -> TAᴱ X Xᴱ (TAC X x Y y)

Arguments TAᴱ _%type_scope _%function_scope
Arguments TACᴱ0 _%type_scope _%function_scope _ _%type_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up MetaCoq.Translations.param_exists_test.TA2"
Complete Identifier: MetaCoq.Translations.param_exists_test.TA2
Short Identifier: TA2
"Translate MetaCoq.Translations.param_exists_test.TA2"
(IndRef
   {|
   inductive_mind := (MPfile ["param_exists_test"; "Translations"; "MetaCoq"],
                     "TA2");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Xᴱ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.47",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.47",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "X";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.47",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.47",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "TA2ᴱ";
               ind_type := tProd (nNamed "X")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.47",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.47",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Xᴱ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.47",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.47",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tApp
                                      (tInd
                                         {|
                                         inductive_mind := (
                                                 MPfile
                                                 ["param_exists_test";
                                                 "Translations"; "MetaCoq"],
                                                 "TA2");
                                         inductive_ind := 0 |} []) [
                                      tRel 1])
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.49",
                                                 true)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_exists_test.49",
                                                 true)) |};
                                      Universe.t_ne := eq_refl |})));
               ind_kelim := InType;
               ind_ctors := [];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level
                                        "MetaCoq.Translations.param_exists_test.49";
                                     Level.Level
                                       "MetaCoq.Translations.param_exists_test.47"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok
                                        (s:=[Level.Level
                                               "MetaCoq.Translations.param_exists_test.47"])
                                        (Level.Level
                                           "MetaCoq.Translations.param_exists_test.49")
                                        (LevelSet.Raw.add_ok (s:=[])
                                           (Level.Level
                                              "MetaCoq.Translations.param_exists_test.47")
                                           LevelSet.Raw.empty_ok) |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_exists_test.TA2 has been translated.
Inductive TA2ᴱ (X : Type) (Xᴱ : X -> Type) : TA2 X -> Type :=  

Arguments TA2ᴱ _%type_scope _%function_scope
param_exists_test.vo (real: 14.70, user: 14.11, sys: 0.42, mem: 586308 ko)
COQC param_test.v
"~~~~~~~~~~~~~~~~~~"
"Looking up MetaCoq.Translations.param_test.f"
Complete Identifier: MetaCoq.Translations.param_test.f
Short Identifier: f
"Translate MetaCoq.Translations.param_test.f"
(ConstRef (MPfile ["param_test"; "Translations"; "MetaCoq"], "f"))
(tProd nAnon
   (tSort
      {|
      Universe.t_set := {|
                        UnivExprSet.this := [UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.467",
                                               false)];
                        UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                               (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.467",
                                                 false)) |};
      Universe.t_ne := eq_refl |})
   (tSort
      {|
      Universe.t_set := {|
                        UnivExprSet.this := [UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.468",
                                               false)];
                        UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                               (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.468",
                                                 false)) |};
      Universe.t_ne := eq_refl |}))
(Success
   (tLambda (nNamed "f")
      (tProd nAnon
         (tSort
            {|
            Universe.t_set := {|
                              UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.467",
                                                 false)];
                              UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.467",
                                                 false)) |};
            Universe.t_ne := eq_refl |})
         (tSort
            {|
            Universe.t_set := {|
                              UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.468",
                                                 false)];
                              UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.468",
                                                 false)) |};
            Universe.t_ne := eq_refl |}))
      (tProd nAnon
         (tSort
            {|
            Universe.t_set := {|
                              UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.467",
                                                 false)];
                              UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.467",
                                                 false)) |};
            Universe.t_ne := eq_refl |})
         (tProd nAnon
            (tProd nAnon (tRel 0)
               (tSort
                  {|
                  Universe.t_set := {|
                                    UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.467",
                                                 false)];
                                    UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.467",
                                                 false)) |};
                  Universe.t_ne := eq_refl |}))
            (tProd nAnon (tApp (tRel 2) [tRel 1])
               (tSort
                  {|
                  Universe.t_set := {|
                                    UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.468",
                                                 false)];
                                    UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.468",
                                                 false)) |};
                  Universe.t_ne := eq_refl |}))))))
"here"
"fᵗ"
(tLambda (nNamed "f")
   (tProd nAnon
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.467",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.467",
                                                 false)) |};
         Universe.t_ne := eq_refl |})
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.468",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.468",
                                                 false)) |};
         Universe.t_ne := eq_refl |}))
   (tProd nAnon
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.467",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.467",
                                                 false)) |};
         Universe.t_ne := eq_refl |})
      (tProd nAnon
         (tProd nAnon (tRel 0)
            (tSort
               {|
               Universe.t_set := {|
                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.467",
                                                 false)];
                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.467",
                                                 false)) |};
               Universe.t_ne := eq_refl |}))
         (tProd nAnon (tApp (tRel 2) [tRel 1])
            (tSort
               {|
               Universe.t_set := {|
                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.468",
                                                 false)];
                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.468",
                                                 false)) |};
               Universe.t_ne := eq_refl |})))))
"doneu"
"MetaCoq.Translations.param_test.f has been translated as fᵗ"
fᵗ = 
fun f : Type -> Type => forall H : Type, (H -> Type) -> f H -> Type
     : (Type -> Type) -> Type

Arguments fᵗ _%function_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.nat"
Complete Identifier: Coq.Init.Datatypes.nat
Short Identifier: nat
"Translate Coq.Init.Datatypes.nat"
(IndRef
   {|
   inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "nat");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 0;
ind_params := [];
ind_bodies := [{|
               ind_name := "natᵗ";
               ind_type := tProd nAnon
                             (tInd
                                {|
                                inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                inductive_ind := 0 |} [])
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                Universe.t_ne := eq_refl |});
               ind_kelim := InType;
               ind_ctors := [("Oᵗ",
                             tApp (tRel 0)
                               [tConstruct
                                  {|
                                  inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                  inductive_ind := 0 |} 0 []], 0);
                            ("Sᵗ",
                            tProd nAnon
                              (tInd
                                 {|
                                 inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                 inductive_ind := 0 |} [])
                              (tProd nAnon (tApp (tRel 1) [tRel 0])
                                 (tApp (tRel 2)
                                    [tApp
                                       (tConstruct
                                          {|
                                          inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                          inductive_ind := 0 |} 1 [])
                                       [tRel 1]])), 2)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [];
                    LevelSet.is_ok := LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
Coq.Init.Datatypes.nat has been translated.
Inductive natᵗ : nat -> Set :=
    Oᵗ : natᵗ 0 | Sᵗ : forall H : nat, natᵗ H -> natᵗ (S H)

Arguments natᵗ _%nat_scope
Arguments Sᵗ _%nat_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.nat"
Complete Identifier: Coq.Init.Datatypes.nat
Short Identifier: nat
"Translate Coq.Init.Datatypes.nat"
(IndRef
   {|
   inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "nat");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 0;
ind_params := [];
ind_bodies := [{|
               ind_name := "natᵗ0";
               ind_type := tProd nAnon
                             (tInd
                                {|
                                inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                inductive_ind := 0 |} [])
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                Universe.t_ne := eq_refl |});
               ind_kelim := InType;
               ind_ctors := [("Oᵗ0",
                             tApp (tRel 0)
                               [tConstruct
                                  {|
                                  inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                  inductive_ind := 0 |} 0 []], 0);
                            ("Sᵗ0",
                            tProd nAnon
                              (tInd
                                 {|
                                 inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                 inductive_ind := 0 |} [])
                              (tProd nAnon (tApp (tRel 1) [tRel 0])
                                 (tApp (tRel 2)
                                    [tApp
                                       (tConstruct
                                          {|
                                          inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                          inductive_ind := 0 |} 1 [])
                                       [tRel 1]])), 2)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [];
                    LevelSet.is_ok := LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
Coq.Init.Datatypes.nat has been translated.
Inductive natᵗ0 : nat -> Set :=
    Oᵗ0 : natᵗ0 0 | Sᵗ0 : forall H : nat, natᵗ0 H -> natᵗ0 (S H)

Arguments natᵗ0 _%nat_scope
Arguments Sᵗ0 _%nat_scope
"Translate nat"
(IndRef
   {|
   inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "nat");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 0;
ind_params := [];
ind_bodies := [{|
               ind_name := "natᵗ1";
               ind_type := tProd nAnon
                             (tInd
                                {|
                                inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                inductive_ind := 0 |} [])
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                Universe.t_ne := eq_refl |});
               ind_kelim := InType;
               ind_ctors := [("Oᵗ1",
                             tApp (tRel 0)
                               [tConstruct
                                  {|
                                  inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                  inductive_ind := 0 |} 0 []], 0);
                            ("Sᵗ1",
                            tProd nAnon
                              (tInd
                                 {|
                                 inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                 inductive_ind := 0 |} [])
                              (tProd nAnon (tApp (tRel 1) [tRel 0])
                                 (tApp (tRel 2)
                                    [tApp
                                       (tConstruct
                                          {|
                                          inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                          inductive_ind := 0 |} 1 [])
                                       [tRel 1]])), 2)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [];
                    LevelSet.is_ok := LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
Coq.Init.Datatypes.nat has been translated.
"Translate VectorDef.t"
(IndRef
   {|
   inductive_mind := (MPfile ["VectorDef"; "Vectors"; "Coq"], "t");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Aᵗ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "A";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "tᵗ";
               ind_type := tProd (nNamed "A")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Aᵗ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tInd
                                      {|
                                      inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                      inductive_ind := 0 |} [])
                                   (tProd nAnon
                                      (tApp
                                         (tInd
                                            {|
                                            inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                            inductive_ind := 0 |} [])
                                         [tRel 0])
                                      (tProd nAnon
                                         (tApp
                                            (tInd
                                               {|
                                               inductive_mind := (
                                                 MPfile
                                                 ["VectorDef"; "Vectors";
                                                 "Coq"], "t");
                                               inductive_ind := 0 |} [])
                                            [tRel 3; tRel 1])
                                         (tSort
                                            {|
                                            Universe.t_set := {|
                                                 UnivExprSet.this := [
                                                 UnivExpr.npe
                                                 (NoPropLevel.lSet, false);
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.add_ok
                                                 (s:=[UnivExpr.npe
                                                 (NoPropLevel.lSet, false)])
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false))
                                                 (UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false))) |};
                                            Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false))
                                                 {|
                                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                                 Universe.t_ne := eq_refl |} |})))));
               ind_kelim := InType;
               ind_ctors := [("nilᵗ",
                             tProd (nNamed "A")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Aᵗ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tApp (tRel 2)
                                     [tRel 1; tRel 0;
                                     tConstruct
                                       {|
                                       inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                       inductive_ind := 0 |} 0 [];
                                     tConstruct
                                       {|
                                       inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                       inductive_ind := 0 |} 0 [];
                                     tApp
                                       (tConstruct
                                          {|
                                          inductive_mind := (
                                                 MPfile
                                                 ["VectorDef"; "Vectors";
                                                 "Coq"], "t");
                                          inductive_ind := 0 |} 0 [])
                                       [tRel 1]])), 2);
                            ("consᵗ",
                            tProd (nNamed "A")
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |})
                              (tProd (nNamed "Aᵗ")
                                 (tProd nAnon (tRel 0)
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |}))
                                 (tProd (nNamed "h") 
                                    (tRel 1)
                                    (tProd (nNamed "hᵗ")
                                       (tApp (tRel 1) [tRel 0])
                                       (tProd (nNamed "n")
                                          (tInd
                                             {|
                                             inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                             inductive_ind := 0 |} [])
                                          (tProd (nNamed "nᵗ")
                                             (tApp
                                                (tInd
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                                 inductive_ind := 0 |} [])
                                                [tRel 0])
                                             (tProd nAnon
                                                (tApp
                                                 (tInd
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["VectorDef"; "Vectors";
                                                 "Coq"], "t");
                                                 inductive_ind := 0 |} [])
                                                 [tRel 5; tRel 1])
                                                (tProd nAnon
                                                 (tApp 
                                                 (tRel 7)
                                                 [
                                                 tRel 6; 
                                                 tRel 5; 
                                                 tRel 2; 
                                                 tRel 1; 
                                                 tRel 0])
                                                 (tApp 
                                                 (tRel 8)
                                                 [
                                                 tRel 7; 
                                                 tRel 6;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                                 inductive_ind := 0 |} 1 [])
                                                 [tRel 3];
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                                 inductive_ind := 0 |} 1 [])
                                                 [tRel 3; tRel 2];
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["VectorDef"; "Vectors";
                                                 "Coq"], "t");
                                                 inductive_ind := 0 |} 1 [])
                                                 [
                                                 tRel 7; 
                                                 tRel 5; 
                                                 tRel 3; 
                                                 tRel 1]])))))))), 8)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level "Coq.Vectors.VectorDef.3"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok (s:=[])
                                        (Level.Level
                                           "Coq.Vectors.VectorDef.3")
                                        LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
Coq.Vectors.VectorDef.t has been translated.
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.nat"
"Looking up Coq.Vectors.VectorDef.t"
Complete Identifier: Coq.Vectors.VectorDef.t
Short Identifier: t
"Translate Coq.Vectors.VectorDef.t"
(IndRef
   {|
   inductive_mind := (MPfile ["VectorDef"; "Vectors"; "Coq"], "t");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Aᵗ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "A";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "tᵗ0";
               ind_type := tProd (nNamed "A")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Aᵗ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tInd
                                      {|
                                      inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                      inductive_ind := 0 |} [])
                                   (tProd nAnon
                                      (tApp
                                         (tInd
                                            {|
                                            inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                            inductive_ind := 0 |} [])
                                         [tRel 0])
                                      (tProd nAnon
                                         (tApp
                                            (tInd
                                               {|
                                               inductive_mind := (
                                                 MPfile
                                                 ["VectorDef"; "Vectors";
                                                 "Coq"], "t");
                                               inductive_ind := 0 |} [])
                                            [tRel 3; tRel 1])
                                         (tSort
                                            {|
                                            Universe.t_set := {|
                                                 UnivExprSet.this := [
                                                 UnivExpr.npe
                                                 (NoPropLevel.lSet, false);
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.add_ok
                                                 (s:=[UnivExpr.npe
                                                 (NoPropLevel.lSet, false)])
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false))
                                                 (UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false))) |};
                                            Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false))
                                                 {|
                                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                                 Universe.t_ne := eq_refl |} |})))));
               ind_kelim := InType;
               ind_ctors := [("nilᵗ0",
                             tProd (nNamed "A")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Aᵗ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tApp (tRel 2)
                                     [tRel 1; tRel 0;
                                     tConstruct
                                       {|
                                       inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                       inductive_ind := 0 |} 0 [];
                                     tConstruct
                                       {|
                                       inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                       inductive_ind := 0 |} 0 [];
                                     tApp
                                       (tConstruct
                                          {|
                                          inductive_mind := (
                                                 MPfile
                                                 ["VectorDef"; "Vectors";
                                                 "Coq"], "t");
                                          inductive_ind := 0 |} 0 [])
                                       [tRel 1]])), 2);
                            ("consᵗ0",
                            tProd (nNamed "A")
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |})
                              (tProd (nNamed "Aᵗ")
                                 (tProd nAnon (tRel 0)
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |}))
                                 (tProd (nNamed "h") 
                                    (tRel 1)
                                    (tProd (nNamed "hᵗ")
                                       (tApp (tRel 1) [tRel 0])
                                       (tProd (nNamed "n")
                                          (tInd
                                             {|
                                             inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                             inductive_ind := 0 |} [])
                                          (tProd (nNamed "nᵗ")
                                             (tApp
                                                (tInd
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                                 inductive_ind := 0 |} [])
                                                [tRel 0])
                                             (tProd nAnon
                                                (tApp
                                                 (tInd
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["VectorDef"; "Vectors";
                                                 "Coq"], "t");
                                                 inductive_ind := 0 |} [])
                                                 [tRel 5; tRel 1])
                                                (tProd nAnon
                                                 (tApp 
                                                 (tRel 7)
                                                 [
                                                 tRel 6; 
                                                 tRel 5; 
                                                 tRel 2; 
                                                 tRel 1; 
                                                 tRel 0])
                                                 (tApp 
                                                 (tRel 8)
                                                 [
                                                 tRel 7; 
                                                 tRel 6;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                                 inductive_ind := 0 |} 1 [])
                                                 [tRel 3];
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                                 inductive_ind := 0 |} 1 [])
                                                 [tRel 3; tRel 2];
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["VectorDef"; "Vectors";
                                                 "Coq"], "t");
                                                 inductive_ind := 0 |} 1 [])
                                                 [
                                                 tRel 7; 
                                                 tRel 5; 
                                                 tRel 3; 
                                                 tRel 1]])))))))), 8)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level "Coq.Vectors.VectorDef.3"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok (s:=[])
                                        (Level.Level
                                           "Coq.Vectors.VectorDef.3")
                                        LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
Coq.Vectors.VectorDef.t has been translated.
Inductive t (A : Type) : nat -> Type :=
    nil : VectorDef.t A 0
  | cons : A -> forall n : nat, VectorDef.t A n -> VectorDef.t A (S n)

Arguments VectorDef.t _%type_scope _%nat_scope
Arguments VectorDef.nil _%type_scope
Arguments VectorDef.cons _%type_scope _ _%nat_scope
Inductive
tᵗ (A : Type) (Aᵗ : A -> Type)
  : forall H : nat, natᵗ H -> VectorDef.t A H -> Type :=
    nilᵗ : tᵗ A Aᵗ 0 Oᵗ (VectorDef.nil A)
  | consᵗ : forall h : A,
            Aᵗ h ->
            forall (n : nat) (nᵗ : natᵗ n) (H : VectorDef.t A n),
            tᵗ A Aᵗ n nᵗ H ->
            tᵗ A Aᵗ (S n) (Sᵗ n nᵗ) (VectorDef.cons A h n H)

Arguments tᵗ _%type_scope _%function_scope _%nat_scope
Arguments nilᵗ _%type_scope _%function_scope
Arguments consᵗ _%type_scope _%function_scope _ _ _%nat_scope
Inductive
tᵗ0 (A : Type) (Aᵗ : A -> Type)
  : forall H : nat, natᵗ H -> VectorDef.t A H -> Type :=
    nilᵗ0 : tᵗ0 A Aᵗ 0 Oᵗ (VectorDef.nil A)
  | consᵗ0 : forall h : A,
             Aᵗ h ->
             forall (n : nat) (nᵗ : natᵗ n) (H : VectorDef.t A n),
             tᵗ0 A Aᵗ n nᵗ H ->
             tᵗ0 A Aᵗ (S n) (Sᵗ n nᵗ) (VectorDef.cons A h n H)

Arguments tᵗ0 _%type_scope _%function_scope _%nat_scope
Arguments nilᵗ0 _%type_scope _%function_scope
Arguments consᵗ0 _%type_scope _%function_scope _ _ _%nat_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.nat"
"Looking up Coq.Vectors.VectorDef.t"
Complete Identifier: Coq.Vectors.VectorDef.t
Short Identifier: t
"Translate Coq.Vectors.VectorDef.t"
(IndRef
   {|
   inductive_mind := (MPfile ["VectorDef"; "Vectors"; "Coq"], "t");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Aᵗ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "A";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "tᵗ1";
               ind_type := tProd (nNamed "A")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Aᵗ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tInd
                                      {|
                                      inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                      inductive_ind := 0 |} [])
                                   (tProd nAnon
                                      (tApp
                                         (tInd
                                            {|
                                            inductive_mind := (
                                                 MPfile
                                                 ["VectorDef"; "Vectors";
                                                 "Coq"], "t");
                                            inductive_ind := 0 |} [])
                                         [tRel 2; tRel 0])
                                      (tSort
                                         {|
                                         Universe.t_set := {|
                                                 UnivExprSet.this := [
                                                 UnivExpr.npe
                                                 (NoPropLevel.lSet, false);
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.add_ok
                                                 (s:=[UnivExpr.npe
                                                 (NoPropLevel.lSet, false)])
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false))
                                                 (UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false))) |};
                                         Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false))
                                                 {|
                                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                                 Universe.t_ne := eq_refl |} |}))));
               ind_kelim := InType;
               ind_ctors := [("nilᵗ1",
                             tProd (nNamed "A")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Aᵗ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tApp (tRel 2)
                                     [tRel 1; tRel 0;
                                     tConstruct
                                       {|
                                       inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                       inductive_ind := 0 |} 0 [];
                                     tApp
                                       (tConstruct
                                          {|
                                          inductive_mind := (
                                                 MPfile
                                                 ["VectorDef"; "Vectors";
                                                 "Coq"], "t");
                                          inductive_ind := 0 |} 0 [])
                                       [tRel 1]])), 2);
                            ("consᵗ1",
                            tProd (nNamed "A")
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |})
                              (tProd (nNamed "Aᵗ")
                                 (tProd nAnon (tRel 0)
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Vectors.VectorDef.3",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |}))
                                 (tProd (nNamed "h") 
                                    (tRel 1)
                                    (tProd (nNamed "hᵗ")
                                       (tApp (tRel 1) [tRel 0])
                                       (tProd (nNamed "n")
                                          (tInd
                                             {|
                                             inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                             inductive_ind := 0 |} [])
                                          (tProd nAnon
                                             (tApp
                                                (tInd
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["VectorDef"; "Vectors";
                                                 "Coq"], "t");
                                                 inductive_ind := 0 |} [])
                                                [tRel 4; tRel 0])
                                             (tProd nAnon
                                                (tApp 
                                                 (tRel 6)
                                                 [
                                                 tRel 5; 
                                                 tRel 4; 
                                                 tRel 1; 
                                                 tRel 0])
                                                (tApp 
                                                 (tRel 7)
                                                 [
                                                 tRel 6; 
                                                 tRel 5;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                                 inductive_ind := 0 |} 1 [])
                                                 [tRel 2];
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["VectorDef"; "Vectors";
                                                 "Coq"], "t");
                                                 inductive_ind := 0 |} 1 [])
                                                 [
                                                 tRel 6; 
                                                 tRel 4; 
                                                 tRel 2; 
                                                 tRel 1]]))))))), 7)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level "Coq.Vectors.VectorDef.3"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok (s:=[])
                                        (Level.Level
                                           "Coq.Vectors.VectorDef.3")
                                        LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
Coq.Vectors.VectorDef.t has been translated.
Inductive
tᵗ0 (A : Type) (Aᵗ : A -> Type)
  : forall H : nat, natᵗ H -> VectorDef.t A H -> Type :=
    nilᵗ0 : tᵗ0 A Aᵗ 0 Oᵗ (VectorDef.nil A)
  | consᵗ0 : forall h : A,
             Aᵗ h ->
             forall (n : nat) (nᵗ : natᵗ n) (H : VectorDef.t A n),
             tᵗ0 A Aᵗ n nᵗ H ->
             tᵗ0 A Aᵗ (S n) (Sᵗ n nᵗ) (VectorDef.cons A h n H)

Arguments tᵗ0 _%type_scope _%function_scope _%nat_scope
Arguments nilᵗ0 _%type_scope _%function_scope
Arguments consᵗ0 _%type_scope _%function_scope _ _ _%nat_scope
Inductive
tᵗ1 (A : Type) (Aᵗ : A -> Type) : forall H : nat, VectorDef.t A H -> Type :=
    nilᵗ1 : tᵗ1 A Aᵗ 0 (VectorDef.nil A)
  | consᵗ1 : forall h : A,
             Aᵗ h ->
             forall (n : nat) (H : VectorDef.t A n),
             tᵗ1 A Aᵗ n H -> tᵗ1 A Aᵗ (S n) (VectorDef.cons A h n H)

Arguments tᵗ1 _%type_scope _%function_scope _%nat_scope
Arguments nilᵗ1 _%type_scope _%function_scope
Arguments consᵗ1 _%type_scope _%function_scope _ _ _%nat_scope
Inductive sig (A : Type) (P : A -> Prop) : Type :=
    exist : forall x : A, P x -> {x : A | P x}

Arguments sig [A]%type_scope _%type_scope
Arguments exist [A]%type_scope _%function_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Specif.sigT"
Complete Identifier: Coq.Init.Specif.sigT
Short Identifier: sigT
"Translate Coq.Init.Specif.sigT"
(IndRef
   {|
   inductive_mind := (MPfile ["Specif"; "Init"; "Coq"], "sigT");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 4;
ind_params := [{|
               decl_name := nNamed "Pᵗ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 2)
                              (tProd nAnon (tApp (tRel 2) [tRel 0])
                                 (tProd nAnon (tApp (tRel 2) [tRel 1])
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.8", false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.8", false)) |};
                                       Universe.t_ne := eq_refl |}))) |};
              {|
              decl_name := nNamed "P";
              decl_body := None;
              decl_type := tProd nAnon (tRel 1)
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.8", false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.8", false)) |};
                                Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "Aᵗ";
              decl_body := None;
              decl_type := tProd nAnon (tRel 0)
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)) |};
                                Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "A";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "sigTᵗ";
               ind_type := tProd (nNamed "A")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Aᵗ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd (nNamed "P")
                                   (tProd nAnon (tRel 1)
                                      (tSort
                                         {|
                                         Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.8", false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.8", false)) |};
                                         Universe.t_ne := eq_refl |}))
                                   (tProd (nNamed "Pᵗ")
                                      (tProd nAnon 
                                         (tRel 2)
                                         (tProd nAnon
                                            (tApp (tRel 2) [tRel 0])
                                            (tProd nAnon
                                               (tApp (tRel 2) [tRel 1])
                                               (tSort
                                                 {|
                                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.8", false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.8", false)) |};
                                                 Universe.t_ne := eq_refl |}))))
                                      (tProd nAnon
                                         (tApp
                                            (tInd
                                               {|
                                               inductive_mind := (
                                                 MPfile
                                                 ["Specif"; "Init"; "Coq"],
                                                 "sigT");
                                               inductive_ind := 0 |} [])
                                            [tRel 3; tRel 1])
                                         (tSort
                                            {|
                                            Universe.t_set := {|
                                                 UnivExprSet.this := [
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.8", false);
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.add_ok
                                                 (s:=[UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)])
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.8", false))
                                                 (UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false))) |};
                                            Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.8", false))
                                                 {|
                                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)) |};
                                                 Universe.t_ne := eq_refl |} |})))));
               ind_kelim := InType;
               ind_ctors := [("existTᵗ",
                             tProd (nNamed "A")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Aᵗ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.7", false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tProd (nNamed "P")
                                     (tProd nAnon 
                                        (tRel 1)
                                        (tSort
                                           {|
                                           Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.8", false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.8", false)) |};
                                           Universe.t_ne := eq_refl |}))
                                     (tProd (nNamed "Pᵗ")
                                        (tProd nAnon 
                                           (tRel 2)
                                           (tProd nAnon
                                              (tApp (tRel 2) [tRel 0])
                                              (tProd nAnon
                                                 (tApp (tRel 2) [tRel 1])
                                                 (tSort
                                                 {|
                                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.8", false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Specif.8", false)) |};
                                                 Universe.t_ne := eq_refl |}))))
                                        (tProd (nNamed "x") 
                                           (tRel 3)
                                           (tProd 
                                              (nNamed "xᵗ")
                                              (tApp (tRel 3) [tRel 0])
                                              (tProd nAnon
                                                 (tApp (tRel 3) [tRel 1])
                                                 (tProd nAnon
                                                 (tApp 
                                                 (tRel 3)
                                                 [tRel 2; tRel 1; tRel 0])
                                                 (tApp 
                                                 (tRel 8)
                                                 [
                                                 tRel 7; 
                                                 tRel 6; 
                                                 tRel 5; 
                                                 tRel 4;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["Specif"; "Init"; "Coq"],
                                                 "sigT");
                                                 inductive_ind := 0 |} 0 [])
                                                 [
                                                 tRel 7; 
                                                 tRel 5; 
                                                 tRel 3; 
                                                 tRel 1]])))))))), 8)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level "Coq.Init.Specif.8";
                                     Level.Level "Coq.Init.Specif.7"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok
                                        (s:=[Level.Level "Coq.Init.Specif.7"])
                                        (Level.Level "Coq.Init.Specif.8")
                                        (LevelSet.Raw.add_ok (s:=[])
                                           (Level.Level "Coq.Init.Specif.7")
                                           LevelSet.Raw.empty_ok) |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
Coq.Init.Specif.sigT has been translated.
Inductive
sigTᵗ (A : Type) (Aᵗ P : A -> Type) (Pᵗ : forall H : A, Aᵗ H -> P H -> Type)
  : (∑ y, P y) -> Type :=
    existTᵗ : forall (x : A) (xᵗ : Aᵗ x) (H : P x),
              Pᵗ x xᵗ H -> sigTᵗ A Aᵗ P Pᵗ (x; H)

Arguments sigTᵗ _%type_scope (_ _ _)%function_scope
Arguments existTᵗ _%type_scope (_ _ _)%function_scope
Inductive list (A : Type) : Type :=
    nil : list A | cons : A -> list A -> list A

Arguments list _%type_scope
Arguments nil {A}%type_scope, _
Arguments cons {A}%type_scope a l%list_scope : rename
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.list"
Complete Identifier: Coq.Init.Datatypes.list
Short Identifier: list
"Translate Coq.Init.Datatypes.list"
(IndRef
   {|
   inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "list");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Aᵗ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "A";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "listᵗ";
               ind_type := tProd (nNamed "A")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Aᵗ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tApp
                                      (tInd
                                         {|
                                         inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "list");
                                         inductive_ind := 0 |} []) [
                                      tRel 1])
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [
                                                 UnivExpr.npe
                                                 (NoPropLevel.lSet, false);
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.add_ok
                                                 (s:=[UnivExpr.npe
                                                 (NoPropLevel.lSet, false)])
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false))
                                                 (UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false))) |};
                                      Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false))
                                                 {|
                                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                                 Universe.t_ne := eq_refl |} |})));
               ind_kelim := InType;
               ind_ctors := [("nilᵗ2",
                             tProd (nNamed "A")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Aᵗ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tApp (tRel 2)
                                     [tRel 1; tRel 0;
                                     tApp
                                       (tConstruct
                                          {|
                                          inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "list");
                                          inductive_ind := 0 |} 0 [])
                                       [tRel 1]])), 2);
                            ("consᵗ2",
                            tProd (nNamed "A")
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |})
                              (tProd (nNamed "Aᵗ")
                                 (tProd nAnon (tRel 0)
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |}))
                                 (tProd nAnon (tRel 1)
                                    (tProd nAnon (tApp (tRel 1) [tRel 0])
                                       (tProd nAnon
                                          (tApp
                                             (tInd
                                                {|
                                                inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "list");
                                                inductive_ind := 0 |} [])
                                             [tRel 3])
                                          (tProd nAnon
                                             (tApp 
                                                (tRel 5)
                                                [tRel 4; tRel 3; tRel 0])
                                             (tApp 
                                                (tRel 6)
                                                [tRel 5; 
                                                tRel 4;
                                                tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "list");
                                                 inductive_ind := 0 |} 1 [])
                                                 [tRel 5; tRel 3; tRel 1]])))))),
                            6)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level "Coq.Init.Datatypes.54"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok (s:=[])
                                        (Level.Level "Coq.Init.Datatypes.54")
                                        LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
Coq.Init.Datatypes.list has been translated.
Inductive listᵗ (A : Type) (Aᵗ : A -> Type) : list A -> Type :=
    nilᵗ2 : listᵗ A Aᵗ []
  | consᵗ2 : forall H : A,
             Aᵗ H ->
             forall H0 : list A, listᵗ A Aᵗ H0 -> listᵗ A Aᵗ (H :: H0)

Arguments listᵗ _%type_scope _%function_scope _%list_scope
Arguments nilᵗ2 _%type_scope _%function_scope
Arguments consᵗ2 _%type_scope _%function_scope _ _ _%list_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.nat"
"Looking up MetaCoq.Translations.param_test.G"
Complete Identifier: MetaCoq.Translations.param_test.G
Short Identifier: G
"Translate MetaCoq.Translations.param_test.G"
(IndRef
   {|
   inductive_mind := (MPfile ["param_test"; "Translations"; "MetaCoq"], "G");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Xᵗ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.502",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.502",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "X";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.502",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.502",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "Gᵗ";
               ind_type := tProd (nNamed "X")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.502",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.502",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Xᵗ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.502",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.502",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tApp
                                      (tInd
                                         {|
                                         inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "G");
                                         inductive_ind := 0 |} []) [
                                      tRel 1])
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [
                                                 UnivExpr.npe
                                                 (NoPropLevel.lSet, false);
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.502",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.add_ok
                                                 (s:=[UnivExpr.npe
                                                 (NoPropLevel.lSet, false)])
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.502",
                                                 false))
                                                 (UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false))) |};
                                      Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.502",
                                                 false))
                                                 {|
                                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                                 Universe.t_ne := eq_refl |} |})));
               ind_kelim := InType;
               ind_ctors := [("Cᵗ",
                             tProd (nNamed "X")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.502",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.502",
                                                 false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Xᵗ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.502",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.502",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tProd (nNamed "f")
                                     (tProd nAnon
                                        (tInd
                                           {|
                                           inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                           inductive_ind := 0 |} []) 
                                        (tRel 2))
                                     (tProd (nNamed "fᵗ")
                                        (tProd nAnon
                                           (tInd
                                              {|
                                              inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                              inductive_ind := 0 |} [])
                                           (tProd nAnon
                                              (tApp
                                                 (tInd
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                                 inductive_ind := 0 |} [])
                                                 [
                                                 tRel 0])
                                              (tApp 
                                                 (tRel 3)
                                                 [
                                                 tApp (tRel 2) [tRel 1]])))
                                        (tApp (tRel 4)
                                           [tRel 3; 
                                           tRel 2;
                                           tApp
                                             (tConstruct
                                                {|
                                                inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "G");
                                                inductive_ind := 0 |} 0 [])
                                             [tRel 3; tRel 1]])))), 4)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level
                                        "MetaCoq.Translations.param_test.502"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok (s:=[])
                                        (Level.Level
                                           "MetaCoq.Translations.param_test.502")
                                        LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_test.G has been translated.
Inductive Gᵗ (X : Type) (Xᵗ : X -> Type) : G X -> Type :=
    Cᵗ : forall f : nat -> X,
         (forall H : nat, natᵗ H -> Xᵗ (f H)) -> Gᵗ X Xᵗ (C X f)

Arguments Gᵗ _%type_scope _%function_scope
Arguments Cᵗ _%type_scope (_ _ _)%function_scope
"Translate type"
(ConstRef (MPfile ["param_test"; "Translations"; "MetaCoq"], "type"))
(tSort
   {|
   Universe.t_set := {|
                     UnivExprSet.this := [UnivExpr.npe
                                            (NoPropLevel.Level
                                               "MetaCoq.Translations.param_test.507",
                                            false)];
                     UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                            (UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.507",
                                               false)) |};
   Universe.t_ne := eq_refl |})
(Success
   (tLambda (nNamed "X")
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.507",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.507",
                                                 false)) |};
         Universe.t_ne := eq_refl |})
      (tProd nAnon (tRel 0)
         (tSort
            {|
            Universe.t_set := {|
                              UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.507",
                                                 false)];
                              UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.507",
                                                 false)) |};
            Universe.t_ne := eq_refl |}))))
"here"
"typeᵗ"
(tLambda (nNamed "X")
   (tSort
      {|
      Universe.t_set := {|
                        UnivExprSet.this := [UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.507",
                                               false)];
                        UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                               (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.507",
                                                 false)) |};
      Universe.t_ne := eq_refl |})
   (tProd nAnon (tRel 0)
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.507",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_test.507",
                                                 false)) |};
         Universe.t_ne := eq_refl |})))
"doneu"
"type has been translated as typeᵗ"
typeᵗ = fun X : Type => X -> Type
     : Type -> Type

Arguments typeᵗ _%type_scope
natᵗ : typeᵗ nat
     : typeᵗ nat
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.nat"
"Looking up Coq.Vectors.Fin.t"
Complete Identifier: Coq.Vectors.Fin.t
Short Identifier: t
"Translate Coq.Vectors.Fin.t"
(IndRef
   {|
   inductive_mind := (MPfile ["Fin"; "Vectors"; "Coq"], "t");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 0;
ind_params := [];
ind_bodies := [{|
               ind_name := "tᵗ2";
               ind_type := tProd nAnon
                             (tInd
                                {|
                                inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                inductive_ind := 0 |} [])
                             (tProd nAnon
                                (tApp
                                   (tInd
                                      {|
                                      inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                      inductive_ind := 0 |} []) [
                                   tRel 0])
                                (tProd nAnon
                                   (tApp
                                      (tInd
                                         {|
                                         inductive_mind := (
                                                 MPfile
                                                 ["Fin"; "Vectors"; "Coq"],
                                                 "t");
                                         inductive_ind := 0 |} []) [
                                      tRel 1])
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                      Universe.t_ne := eq_refl |})));
               ind_kelim := InType;
               ind_ctors := [("F1ᵗ",
                             tProd (nNamed "n")
                               (tInd
                                  {|
                                  inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                  inductive_ind := 0 |} [])
                               (tProd (nNamed "nᵗ")
                                  (tApp
                                     (tInd
                                        {|
                                        inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                        inductive_ind := 0 |} []) [
                                     tRel 0])
                                  (tApp (tRel 2)
                                     [tApp
                                        (tConstruct
                                           {|
                                           inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                           inductive_ind := 0 |} 1 [])
                                        [tRel 1];
                                     tApp
                                       (tConstruct
                                          {|
                                          inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                          inductive_ind := 0 |} 1 [])
                                       [tRel 1; tRel 0];
                                     tApp
                                       (tConstruct
                                          {|
                                          inductive_mind := (
                                                 MPfile
                                                 ["Fin"; "Vectors"; "Coq"],
                                                 "t");
                                          inductive_ind := 0 |} 0 [])
                                       [tRel 1]])), 2);
                            ("FSᵗ",
                            tProd (nNamed "n")
                              (tInd
                                 {|
                                 inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                 inductive_ind := 0 |} [])
                              (tProd (nNamed "nᵗ")
                                 (tApp
                                    (tInd
                                       {|
                                       inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                       inductive_ind := 0 |} []) [
                                    tRel 0])
                                 (tProd nAnon
                                    (tApp
                                       (tInd
                                          {|
                                          inductive_mind := (
                                                 MPfile
                                                 ["Fin"; "Vectors"; "Coq"],
                                                 "t");
                                          inductive_ind := 0 |} []) [
                                       tRel 1])
                                    (tProd nAnon
                                       (tApp (tRel 3)
                                          [tRel 2; tRel 1; tRel 0])
                                       (tApp (tRel 4)
                                          [tApp
                                             (tConstruct
                                                {|
                                                inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                                inductive_ind := 0 |} 1 [])
                                             [tRel 3];
                                          tApp
                                            (tConstruct
                                               {|
                                               inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                               inductive_ind := 0 |} 1 [])
                                            [tRel 3; tRel 2];
                                          tApp
                                            (tConstruct
                                               {|
                                               inductive_mind := (
                                                 MPfile
                                                 ["Fin"; "Vectors"; "Coq"],
                                                 "t");
                                               inductive_ind := 0 |} 1 [])
                                            [tRel 3; tRel 1]])))), 4)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [];
                    LevelSet.is_ok := LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
Coq.Vectors.Fin.t has been translated.
Inductive tᵗ2 : forall H : nat, natᵗ H -> Fin.t H -> Set :=
    F1ᵗ : forall (n : nat) (nᵗ : natᵗ n), tᵗ2 (S n) (Sᵗ n nᵗ) Fin.F1
  | FSᵗ : forall (n : nat) (nᵗ : natᵗ n) (H : Fin.t n),
          tᵗ2 n nᵗ H -> tᵗ2 (S n) (Sᵗ n nᵗ) (Fin.FS H)

Arguments tᵗ2 _%nat_scope
Arguments F1ᵗ _%nat_scope
Arguments FSᵗ _%nat_scope
"Translate Fin.t"
(IndRef
   {|
   inductive_mind := (MPfile ["Fin"; "Vectors"; "Coq"], "t");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 0;
ind_params := [];
ind_bodies := [{|
               ind_name := "tᵗ3";
               ind_type := tProd nAnon
                             (tInd
                                {|
                                inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                inductive_ind := 0 |} [])
                             (tProd nAnon
                                (tApp
                                   (tInd
                                      {|
                                      inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                      inductive_ind := 0 |} []) [
                                   tRel 0])
                                (tProd nAnon
                                   (tApp
                                      (tInd
                                         {|
                                         inductive_mind := (
                                                 MPfile
                                                 ["Fin"; "Vectors"; "Coq"],
                                                 "t");
                                         inductive_ind := 0 |} []) [
                                      tRel 1])
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                      Universe.t_ne := eq_refl |})));
               ind_kelim := InType;
               ind_ctors := [("F1ᵗ0",
                             tProd (nNamed "n")
                               (tInd
                                  {|
                                  inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                  inductive_ind := 0 |} [])
                               (tProd (nNamed "nᵗ")
                                  (tApp
                                     (tInd
                                        {|
                                        inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                        inductive_ind := 0 |} []) [
                                     tRel 0])
                                  (tApp (tRel 2)
                                     [tApp
                                        (tConstruct
                                           {|
                                           inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                           inductive_ind := 0 |} 1 [])
                                        [tRel 1];
                                     tApp
                                       (tConstruct
                                          {|
                                          inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                          inductive_ind := 0 |} 1 [])
                                       [tRel 1; tRel 0];
                                     tApp
                                       (tConstruct
                                          {|
                                          inductive_mind := (
                                                 MPfile
                                                 ["Fin"; "Vectors"; "Coq"],
                                                 "t");
                                          inductive_ind := 0 |} 0 [])
                                       [tRel 1]])), 2);
                            ("FSᵗ0",
                            tProd (nNamed "n")
                              (tInd
                                 {|
                                 inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                 inductive_ind := 0 |} [])
                              (tProd (nNamed "nᵗ")
                                 (tApp
                                    (tInd
                                       {|
                                       inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                       inductive_ind := 0 |} []) [
                                    tRel 0])
                                 (tProd nAnon
                                    (tApp
                                       (tInd
                                          {|
                                          inductive_mind := (
                                                 MPfile
                                                 ["Fin"; "Vectors"; "Coq"],
                                                 "t");
                                          inductive_ind := 0 |} []) [
                                       tRel 1])
                                    (tProd nAnon
                                       (tApp (tRel 3)
                                          [tRel 2; tRel 1; tRel 0])
                                       (tApp (tRel 4)
                                          [tApp
                                             (tConstruct
                                                {|
                                                inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                                inductive_ind := 0 |} 1 [])
                                             [tRel 3];
                                          tApp
                                            (tConstruct
                                               {|
                                               inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "natᵗ");
                                               inductive_ind := 0 |} 1 [])
                                            [tRel 3; tRel 2];
                                          tApp
                                            (tConstruct
                                               {|
                                               inductive_mind := (
                                                 MPfile
                                                 ["Fin"; "Vectors"; "Coq"],
                                                 "t");
                                               inductive_ind := 0 |} 1 [])
                                            [tRel 3; tRel 1]])))), 4)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [];
                    LevelSet.is_ok := LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
Coq.Vectors.Fin.t has been translated.
Inductive tᵗ3 : forall H : nat, natᵗ H -> Fin.t H -> Set :=
    F1ᵗ0 : forall (n : nat) (nᵗ : natᵗ n), tᵗ3 (S n) (Sᵗ n nᵗ) Fin.F1
  | FSᵗ0 : forall (n : nat) (nᵗ : natᵗ n) (H : Fin.t n),
           tᵗ3 n nᵗ H -> tᵗ3 (S n) (Sᵗ n nᵗ) (Fin.FS H)

Arguments tᵗ3 _%nat_scope
Arguments F1ᵗ0 _%nat_scope
Arguments FSᵗ0 _%nat_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up MetaCoq.Translations.param_test.List"
Complete Identifier: MetaCoq.Translations.param_test.List
Short Identifier: List
"Translate MetaCoq.Translations.param_test.List"
(IndRef
   {|
   inductive_mind := (MPfile ["param_test"; "Translations"; "MetaCoq"],
                     "List");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Xᵗ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "X";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "Listᵗ";
               ind_type := tProd (nNamed "X")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Xᵗ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tApp
                                      (tInd
                                         {|
                                         inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "List");
                                         inductive_ind := 0 |} []) [
                                      tRel 1])
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                      Universe.t_ne := eq_refl |})));
               ind_kelim := InType;
               ind_ctors := [("nilᵗ3",
                             tProd (nNamed "X")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Xᵗ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tApp (tRel 2)
                                     [tRel 1; tRel 0;
                                     tApp
                                       (tConstruct
                                          {|
                                          inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "List");
                                          inductive_ind := 0 |} 0 [])
                                       [tRel 1]])), 2);
                            ("consᵗ3",
                            tProd (nNamed "X")
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                 Universe.t_ne := eq_refl |})
                              (tProd (nNamed "Xᵗ")
                                 (tProd nAnon (tRel 0)
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                       Universe.t_ne := eq_refl |}))
                                 (tProd (nNamed "x") 
                                    (tRel 1)
                                    (tProd (nNamed "xᵗ")
                                       (tApp (tRel 1) [tRel 0])
                                       (tProd (nNamed "xs")
                                          (tApp
                                             (tInd
                                                {|
                                                inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "List");
                                                inductive_ind := 0 |} [])
                                             [tRel 3])
                                          (tProd (nNamed "xsᵗ")
                                             (tApp 
                                                (tRel 5)
                                                [tRel 4; tRel 3; tRel 0])
                                             (tApp 
                                                (tRel 6)
                                                [tRel 5; 
                                                tRel 4;
                                                tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "List");
                                                 inductive_ind := 0 |} 1 [])
                                                 [tRel 5; tRel 3; tRel 1]])))))),
                            6)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [];
                    LevelSet.is_ok := LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_test.List has been translated.
"~~~~~~~~~~~~~~~~~~"
"Looking up MetaCoq.Translations.param_test.List"
"Looking up MetaCoq.Translations.param_test.rose"
Complete Identifier: MetaCoq.Translations.param_test.rose
Short Identifier: rose
"Translate MetaCoq.Translations.param_test.rose"
(IndRef
   {|
   inductive_mind := (MPfile ["param_test"; "Translations"; "MetaCoq"],
                     "rose");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 0;
ind_params := [];
ind_bodies := [{|
               ind_name := "roseᵗ";
               ind_type := tProd nAnon
                             (tInd
                                {|
                                inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "rose");
                                inductive_ind := 0 |} [])
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                Universe.t_ne := eq_refl |});
               ind_kelim := InType;
               ind_ctors := [("nodeᵗ",
                             tProd (nNamed "xs")
                               (tApp
                                  (tInd
                                     {|
                                     inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "List");
                                     inductive_ind := 0 |} [])
                                  [tInd
                                     {|
                                     inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "rose");
                                     inductive_ind := 0 |} []])
                               (tProd (nNamed "xsᵗ")
                                  (tApp
                                     (tInd
                                        {|
                                        inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "Listᵗ");
                                        inductive_ind := 0 |} [])
                                     [tInd
                                        {|
                                        inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "rose");
                                        inductive_ind := 0 |} []; 
                                     tRel 1; tRel 0])
                                  (tApp (tRel 2)
                                     [tApp
                                        (tConstruct
                                           {|
                                           inductive_mind := (
                                                 MPfile
                                                 ["param_test";
                                                 "Translations"; "MetaCoq"],
                                                 "rose");
                                           inductive_ind := 0 |} 0 [])
                                        [tRel 1]])), 2)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [];
                    LevelSet.is_ok := LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_test.rose has been translated.
Inductive roseᵗ : rose -> Set :=
    nodeᵗ : forall xs : List rose, Listᵗ rose roseᵗ xs -> roseᵗ (node xs)
param_test.vo (real: 9.09, user: 8.61, sys: 0.39, mem: 576404 ko)
COQC param_other_test.v
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.prod"
Complete Identifier: Coq.Init.Datatypes.prod
Short Identifier: prod
"Translate Coq.Init.Datatypes.prod"
(IndRef
   {|
   inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "prod");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 4;
ind_params := [{|
               decl_name := nNamed "Bᴱ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "B";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |};
              {|
              decl_name := nNamed "Aᴱ";
              decl_body := None;
              decl_type := tProd nAnon (tRel 0)
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                                Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "A";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "prodᴱ";
               ind_type := tProd (nNamed "A")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Aᴱ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd (nNamed "B")
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |})
                                   (tProd (nNamed "Bᴱ")
                                      (tProd nAnon 
                                         (tRel 0)
                                         (tSort
                                            {|
                                            Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                                            Universe.t_ne := eq_refl |}))
                                      (tProd nAnon
                                         (tApp
                                            (tInd
                                               {|
                                               inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "prod");
                                               inductive_ind := 0 |} [])
                                            [tRel 3; tRel 1])
                                         (tSort
                                            {|
                                            Universe.t_set := {|
                                                 UnivExprSet.this := [
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false);
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.add_ok
                                                 (s:=[UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)])
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false))
                                                 (UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false))) |};
                                            Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false))
                                                 {|
                                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                                                 Universe.t_ne := eq_refl |} |})))));
               ind_kelim := InType;
               ind_ctors := [("pairᴱ0",
                             tProd (nNamed "A")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Aᴱ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tProd (nNamed "B")
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |})
                                     (tProd (nNamed "Bᴱ")
                                        (tProd nAnon 
                                           (tRel 0)
                                           (tSort
                                              {|
                                              Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                                              Universe.t_ne := eq_refl |}))
                                        (tProd nAnon 
                                           (tRel 3)
                                           (tProd nAnon 
                                              (tRel 2)
                                              (tProd nAnon
                                                 (tApp (tRel 4) [tRel 1])
                                                 (tApp 
                                                 (tRel 7)
                                                 [
                                                 tRel 6; 
                                                 tRel 5; 
                                                 tRel 4; 
                                                 tRel 3;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "prod");
                                                 inductive_ind := 0 |} 0 [])
                                                 [
                                                 tRel 6; 
                                                 tRel 4; 
                                                 tRel 2; 
                                                 tRel 1]]))))))), 3);
                            ("pairᴱ1",
                            tProd (nNamed "A")
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |})
                              (tProd (nNamed "Aᴱ")
                                 (tProd nAnon (tRel 0)
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |}))
                                 (tProd (nNamed "B")
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |})
                                    (tProd (nNamed "Bᴱ")
                                       (tProd nAnon 
                                          (tRel 0)
                                          (tSort
                                             {|
                                             Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                                             Universe.t_ne := eq_refl |}))
                                       (tProd nAnon 
                                          (tRel 3)
                                          (tProd nAnon 
                                             (tRel 2)
                                             (tProd nAnon
                                                (tApp (tRel 2) [tRel 0])
                                                (tApp 
                                                 (tRel 7)
                                                 [
                                                 tRel 6; 
                                                 tRel 5; 
                                                 tRel 4; 
                                                 tRel 3;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "prod");
                                                 inductive_ind := 0 |} 0 [])
                                                 [
                                                 tRel 6; 
                                                 tRel 4; 
                                                 tRel 2; 
                                                 tRel 1]]))))))), 3)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level "Coq.Init.Datatypes.24";
                                     Level.Level "Coq.Init.Datatypes.23"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok
                                        (s:=[Level.Level
                                               "Coq.Init.Datatypes.23"])
                                        (Level.Level "Coq.Init.Datatypes.24")
                                        (LevelSet.Raw.add_ok (s:=[])
                                           (Level.Level
                                              "Coq.Init.Datatypes.23")
                                           LevelSet.Raw.empty_ok) |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
Coq.Init.Datatypes.prod has been translated.
(tLambda (nNamed "A")
   (tSort
      {|
      Universe.t_set := {|
                        UnivExprSet.this := [UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                               false)];
                        UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                               (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
      Universe.t_ne := eq_refl |})
   (tLambda (nNamed "Aᴱ")
      (tProd nAnon (tRel 0)
         (tSort
            {|
            Universe.t_set := {|
                              UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                              UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
            Universe.t_ne := eq_refl |}))
      (tLambda (nNamed "B")
         (tSort
            {|
            Universe.t_set := {|
                              UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                              UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
            Universe.t_ne := eq_refl |})
         (tLambda (nNamed "Bᴱ")
            (tProd nAnon (tRel 0)
               (tSort
                  {|
                  Universe.t_set := {|
                                    UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                    UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                  Universe.t_ne := eq_refl |}))
            (tLambda nAnon
               (tApp
                  (tInd
                     {|
                     inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"],
                                       "prod");
                     inductive_ind := 0 |} []) [tRel 3; tRel 1])
               (tApp
                  (tInd
                     {|
                     inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"],
                                       "prod");
                     inductive_ind := 0 |} [])
                  [tApp
                     (tInd
                        {|
                        inductive_mind := (MPfile
                                             ["param_other_test";
                                             "Translations"; "MetaCoq"],
                                          "prodᴱ");
                        inductive_ind := 0 |} [])
                     [tRel 4; tRel 3; tRel 2;
                     tLambda (nNamed "x") (tRel 2)
                       (tInd
                          {|
                          inductive_mind := (MPfile ["Logic"; "Init"; "Coq"],
                                            "False");
                          inductive_ind := 0 |} []); 
                     tRel 0];
                  tApp
                    (tInd
                       {|
                       inductive_mind := (MPfile
                                            ["param_other_test";
                                            "Translations"; "MetaCoq"],
                                         "prodᴱ");
                       inductive_ind := 0 |} [])
                    [tRel 4;
                    tLambda (nNamed "x") (tRel 4)
                      (tInd
                         {|
                         inductive_mind := (MPfile ["Logic"; "Init"; "Coq"],
                                           "False");
                         inductive_ind := 0 |} []); 
                    tRel 2; tRel 1; tRel 0]]))))))
prodᴬᴱ = 
fun (A : Type) (Aᴱ : A -> Type) (B : Type) (Bᴱ : B -> Type) (H : A × B) =>
prodᴱ A Aᴱ B (fun _ : B => False) H × prodᴱ A (fun _ : A => False) B Bᴱ H
     : forall A : Type,
       (A -> Type) -> forall B : Type, (B -> Type) -> A × B -> Type

Arguments prodᴬᴱ _%type_scope _%function_scope _%type_scope _%function_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.prod"
Complete Identifier: Coq.Init.Datatypes.prod
Short Identifier: prod
"Translate Coq.Init.Datatypes.prod"
(IndRef
   {|
   inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "prod");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 4;
ind_params := [{|
               decl_name := nNamed "Bᵗ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "B";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |};
              {|
              decl_name := nNamed "Aᵗ";
              decl_body := None;
              decl_type := tProd nAnon (tRel 0)
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                                Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "A";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "prodᵗ";
               ind_type := tProd (nNamed "A")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Aᵗ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd (nNamed "B")
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |})
                                   (tProd (nNamed "Bᵗ")
                                      (tProd nAnon 
                                         (tRel 0)
                                         (tSort
                                            {|
                                            Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                                            Universe.t_ne := eq_refl |}))
                                      (tProd nAnon
                                         (tApp
                                            (tInd
                                               {|
                                               inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "prod");
                                               inductive_ind := 0 |} [])
                                            [tRel 3; tRel 1])
                                         (tSort
                                            {|
                                            Universe.t_set := {|
                                                 UnivExprSet.this := [
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false);
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.add_ok
                                                 (s:=[UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)])
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false))
                                                 (UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false))) |};
                                            Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false))
                                                 {|
                                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                                                 Universe.t_ne := eq_refl |} |})))));
               ind_kelim := InType;
               ind_ctors := [("pairᵗ",
                             tProd (nNamed "A")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Aᵗ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tProd (nNamed "B")
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |})
                                     (tProd (nNamed "Bᵗ")
                                        (tProd nAnon 
                                           (tRel 0)
                                           (tSort
                                              {|
                                              Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                                              Universe.t_ne := eq_refl |}))
                                        (tProd nAnon 
                                           (tRel 3)
                                           (tProd nAnon
                                              (tApp (tRel 3) [tRel 0])
                                              (tProd nAnon 
                                                 (tRel 3)
                                                 (tProd nAnon
                                                 (tApp (tRel 3) [tRel 0])
                                                 (tApp 
                                                 (tRel 8)
                                                 [
                                                 tRel 7; 
                                                 tRel 6; 
                                                 tRel 5; 
                                                 tRel 4;
                                                 tApp
                                                 (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "prod");
                                                 inductive_ind := 0 |} 0 [])
                                                 [
                                                 tRel 7; 
                                                 tRel 5; 
                                                 tRel 3; 
                                                 tRel 1]])))))))), 8)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level "Coq.Init.Datatypes.24";
                                     Level.Level "Coq.Init.Datatypes.23"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok
                                        (s:=[Level.Level
                                               "Coq.Init.Datatypes.23"])
                                        (Level.Level "Coq.Init.Datatypes.24")
                                        (LevelSet.Raw.add_ok (s:=[])
                                           (Level.Level
                                              "Coq.Init.Datatypes.23")
                                           LevelSet.Raw.empty_ok) |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
Coq.Init.Datatypes.prod has been translated.
(tLambda (nNamed "A")
   (tSort
      {|
      Universe.t_set := {|
                        UnivExprSet.this := [UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                               false)];
                        UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                               (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
      Universe.t_ne := eq_refl |})
   (tLambda (nNamed "Aᴱ")
      (tProd nAnon (tRel 0)
         (tSort
            {|
            Universe.t_set := {|
                              UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)];
                              UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.23",
                                                 false)) |};
            Universe.t_ne := eq_refl |}))
      (tLambda (nNamed "B")
         (tSort
            {|
            Universe.t_set := {|
                              UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                              UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
            Universe.t_ne := eq_refl |})
         (tLambda (nNamed "Bᴱ")
            (tProd nAnon (tRel 0)
               (tSort
                  {|
                  Universe.t_set := {|
                                    UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)];
                                    UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.24",
                                                 false)) |};
                  Universe.t_ne := eq_refl |}))
            (tLambda nAnon
               (tApp
                  (tInd
                     {|
                     inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"],
                                       "prod");
                     inductive_ind := 0 |} []) [tRel 3; tRel 1])
               (tApp
                  (tInd
                     {|
                     inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"],
                                       "sum");
                     inductive_ind := 0 |} [])
                  [tApp
                     (tInd
                        {|
                        inductive_mind := (MPfile
                                             ["param_other_test";
                                             "Translations"; "MetaCoq"],
                                          "prodᵗ");
                        inductive_ind := 0 |} [])
                     [tRel 4; tRel 3; tRel 2;
                     tLambda (nNamed "x") (tRel 2)
                       (tInd
                          {|
                          inductive_mind := (MPfile ["Logic"; "Init"; "Coq"],
                                            "True");
                          inductive_ind := 0 |} []); 
                     tRel 0];
                  tApp
                    (tInd
                       {|
                       inductive_mind := (MPfile
                                            ["param_other_test";
                                            "Translations"; "MetaCoq"],
                                         "prodᵗ");
                       inductive_ind := 0 |} [])
                    [tRel 4;
                    tLambda (nNamed "x") (tRel 4)
                      (tInd
                         {|
                         inductive_mind := (MPfile ["Logic"; "Init"; "Coq"],
                                           "True");
                         inductive_ind := 0 |} []); 
                    tRel 2; tRel 1; tRel 0]]))))))
prodᴱᴬ = 
fun (A : Type) (Aᴱ : A -> Type) (B : Type) (Bᴱ : B -> Type) (H : A × B) =>
(prodᵗ A Aᴱ B (fun _ : B => True) H + prodᵗ A (fun _ : A => True) B Bᴱ H)%type
     : forall A : Type,
       (A -> Type) -> forall B : Type, (B -> Type) -> A × B -> Type

Arguments prodᴱᴬ _%type_scope _%function_scope _%type_scope _%function_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.list"
Complete Identifier: Coq.Init.Datatypes.list
Short Identifier: list
"Translate Coq.Init.Datatypes.list"
(IndRef
   {|
   inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "list");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Aᴱ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "A";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "listᴱ";
               ind_type := tProd (nNamed "A")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Aᴱ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tApp
                                      (tInd
                                         {|
                                         inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "list");
                                         inductive_ind := 0 |} []) [
                                      tRel 1])
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [
                                                 UnivExpr.npe
                                                 (NoPropLevel.lSet, false);
                                                 UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.add_ok
                                                 (s:=[UnivExpr.npe
                                                 (NoPropLevel.lSet, false)])
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false))
                                                 (UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false))) |};
                                      Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false))
                                                 {|
                                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (NoPropLevel.lSet, false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (NoPropLevel.lSet, false)) |};
                                                 Universe.t_ne := eq_refl |} |})));
               ind_kelim := InType;
               ind_ctors := [("consᴱ0",
                             tProd (nNamed "A")
                               (tSort
                                  {|
                                  Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                                  Universe.t_ne := eq_refl |})
                               (tProd (nNamed "Aᴱ")
                                  (tProd nAnon (tRel 0)
                                     (tSort
                                        {|
                                        Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                                        Universe.t_ne := eq_refl |}))
                                  (tProd nAnon (tRel 1)
                                     (tProd nAnon
                                        (tApp
                                           (tInd
                                              {|
                                              inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "list");
                                              inductive_ind := 0 |} [])
                                           [tRel 2])
                                        (tProd nAnon 
                                           (tApp (tRel 2) [tRel 1])
                                           (tApp (tRel 5)
                                              [tRel 4; 
                                              tRel 3;
                                              tApp
                                                (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "list");
                                                 inductive_ind := 0 |} 1 [])
                                                [tRel 4; tRel 2; tRel 1]]))))),
                             3);
                            ("consᴱ1",
                            tProd (nNamed "A")
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |})
                              (tProd (nNamed "Aᴱ")
                                 (tProd nAnon (tRel 0)
                                    (tSort
                                       {|
                                       Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
                                       Universe.t_ne := eq_refl |}))
                                 (tProd nAnon (tRel 1)
                                    (tProd nAnon
                                       (tApp
                                          (tInd
                                             {|
                                             inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "list");
                                             inductive_ind := 0 |} [])
                                          [tRel 2])
                                       (tProd nAnon
                                          (tApp (tRel 4)
                                             [tRel 3; tRel 2; tRel 0])
                                          (tApp (tRel 5)
                                             [tRel 4; 
                                             tRel 3;
                                             tApp
                                               (tConstruct
                                                 {|
                                                 inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "list");
                                                 inductive_ind := 0 |} 1 [])
                                               [tRel 4; tRel 2; tRel 1]]))))),
                            3)];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level "Coq.Init.Datatypes.54"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok (s:=[])
                                        (Level.Level "Coq.Init.Datatypes.54")
                                        LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
Coq.Init.Datatypes.list has been translated.
(tLambda (nNamed "A")
   (tSort
      {|
      Universe.t_set := {|
                        UnivExprSet.this := [UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                               false)];
                        UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                               (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
      Universe.t_ne := eq_refl |})
   (tLambda (nNamed "Aᴱ")
      (tProd nAnon (tRel 0)
         (tSort
            {|
            Universe.t_set := {|
                              UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)];
                              UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "Coq.Init.Datatypes.54",
                                                 false)) |};
            Universe.t_ne := eq_refl |}))
      (tLambda nAnon
         (tApp
            (tInd
               {|
               inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"],
                                 "list");
               inductive_ind := 0 |} []) [tRel 1])
         (tApp
            (tInd
               {|
               inductive_mind := (MPfile
                                    ["param_other_test"; "Translations";
                                    "MetaCoq"], "listᴱ");
               inductive_ind := 0 |} []) [tRel 2; tRel 1; tRel 0]))))
listᴬᴱ = 
fun (A : Type) (Aᴱ : A -> Type) (H : list A) => listᴱ A Aᴱ H
     : forall A : Type, (A -> Type) -> list A -> Type

Arguments listᴬᴱ _%type_scope _%function_scope _%list_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up Coq.Init.Datatypes.nat"
"Looking up MetaCoq.Translations.param_other_test.PNT"
Complete Identifier: MetaCoq.Translations.param_other_test.PNT
Short Identifier: PNT
"Translate MetaCoq.Translations.param_other_test.PNT"
(IndRef
   {|
   inductive_mind := (MPfile ["param_other_test"; "Translations"; "MetaCoq"],
                     "PNT");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 4;
ind_params := [{|
               decl_name := nNamed "d";
               decl_body := None;
               decl_type := tInd
                              {|
                              inductive_mind := (MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                "nat");
                              inductive_ind := 0 |} [] |};
              {|
              decl_name := nNamed "Xᴱ";
              decl_body := None;
              decl_type := tProd nAnon (tRel 0)
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.332",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.332",
                                                 false)) |};
                                Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "X";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.332",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.332",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |};
              {|
              decl_name := nNamed "n";
              decl_body := None;
              decl_type := tInd
                             {|
                             inductive_mind := (MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                               "nat");
                             inductive_ind := 0 |} [] |}];
ind_bodies := [{|
               ind_name := "PNTᴱ";
               ind_type := tProd (nNamed "n")
                             (tInd
                                {|
                                inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                inductive_ind := 0 |} [])
                             (tProd (nNamed "X")
                                (tSort
                                   {|
                                   Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.332",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.332",
                                                 false)) |};
                                   Universe.t_ne := eq_refl |})
                                (tProd (nNamed "Xᴱ")
                                   (tProd nAnon (tRel 0)
                                      (tSort
                                         {|
                                         Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.332",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.332",
                                                 false)) |};
                                         Universe.t_ne := eq_refl |}))
                                   (tProd (nNamed "d")
                                      (tInd
                                         {|
                                         inductive_mind := (
                                                 MPfile
                                                 ["Datatypes"; "Init"; "Coq"],
                                                 "nat");
                                         inductive_ind := 0 |} [])
                                      (tProd nAnon
                                         (tApp
                                            (tInd
                                               {|
                                               inductive_mind := (
                                                 MPfile
                                                 ["param_other_test";
                                                 "Translations"; "MetaCoq"],
                                                 "PNT");
                                               inductive_ind := 0 |} [])
                                            [tRel 3; tRel 2; tRel 0])
                                         (tSort
                                            {|
                                            Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.lProp];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 UnivExpr.lProp |};
                                            Universe.t_ne := eq_refl |})))));
               ind_kelim := InType;
               ind_ctors := [];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level
                                        "MetaCoq.Translations.param_other_test.332"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok (s:=[])
                                        (Level.Level
                                           "MetaCoq.Translations.param_other_test.332")
                                        LevelSet.Raw.empty_ok |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_other_test.PNT has been translated.
(tLambda (nNamed "n")
   (tInd
      {|
      inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "nat");
      inductive_ind := 0 |} [])
   (tLambda (nNamed "X")
      (tSort
         {|
         Universe.t_set := {|
                           UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.332",
                                                 false)];
                           UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.332",
                                                 false)) |};
         Universe.t_ne := eq_refl |})
      (tLambda (nNamed "Xᴱ")
         (tProd nAnon (tRel 0)
            (tSort
               {|
               Universe.t_set := {|
                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.332",
                                                 false)];
                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.332",
                                                 false)) |};
               Universe.t_ne := eq_refl |}))
         (tLambda (nNamed "d")
            (tInd
               {|
               inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "nat");
               inductive_ind := 0 |} [])
            (tLambda nAnon
               (tApp
                  (tInd
                     {|
                     inductive_mind := (MPfile
                                          ["param_other_test";
                                          "Translations"; "MetaCoq"], "PNT");
                     inductive_ind := 0 |} []) [tRel 3; tRel 2; tRel 0])
               (tApp
                  (tInd
                     {|
                     inductive_mind := (MPfile
                                          ["param_other_test";
                                          "Translations"; "MetaCoq"], "PNTᴱ");
                     inductive_ind := 0 |} [])
                  [tRel 4; tRel 3; tRel 2; tRel 1; tRel 0]))))))
PNTᴬᴱ = 
fun (n : nat) (X : Type) (Xᴱ : X -> Type) (d : nat) (H : PNT n X d) =>
PNTᴱ n X Xᴱ d H
     : forall (n : nat) (X : Type),
       (X -> Type) -> forall d : nat, PNT n X d -> Prop

Arguments PNTᴬᴱ _%nat_scope _%type_scope _%function_scope _%nat_scope
"~~~~~~~~~~~~~~~~~~"
"Looking up MetaCoq.Translations.param_other_test.IT"
Complete Identifier: MetaCoq.Translations.param_other_test.IT
Short Identifier: IT
"Translate MetaCoq.Translations.param_other_test.IT"
(IndRef
   {|
   inductive_mind := (MPfile ["param_other_test"; "Translations"; "MetaCoq"],
                     "IT");
   inductive_ind := 0 |})
{|
ind_finite := Finite;
ind_npars := 2;
ind_params := [{|
               decl_name := nNamed "Xᴱ";
               decl_body := None;
               decl_type := tProd nAnon (tRel 0)
                              (tSort
                                 {|
                                 Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.337",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.337",
                                                 false)) |};
                                 Universe.t_ne := eq_refl |}) |};
              {|
              decl_name := nNamed "X";
              decl_body := None;
              decl_type := tSort
                             {|
                             Universe.t_set := {|
                                               UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.337",
                                                 false)];
                                               UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.337",
                                                 false)) |};
                             Universe.t_ne := eq_refl |} |}];
ind_bodies := [{|
               ind_name := "ITᴱ";
               ind_type := tProd (nNamed "X")
                             (tSort
                                {|
                                Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.337",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.337",
                                                 false)) |};
                                Universe.t_ne := eq_refl |})
                             (tProd (nNamed "Xᴱ")
                                (tProd nAnon (tRel 0)
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.337",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.337",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |}))
                                (tProd nAnon
                                   (tSort
                                      {|
                                      Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.338",
                                                 false)];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.338",
                                                 false)) |};
                                      Universe.t_ne := eq_refl |})
                                   (tProd nAnon
                                      (tApp
                                         (tInd
                                            {|
                                            inductive_mind := (
                                                 MPfile
                                                 ["param_other_test";
                                                 "Translations"; "MetaCoq"],
                                                 "IT");
                                            inductive_ind := 0 |} [])
                                         [tRel 2; tRel 0])
                                      (tSort
                                         {|
                                         Universe.t_set := {|
                                                 UnivExprSet.this := [UnivExpr.lProp];
                                                 UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 UnivExpr.lProp |};
                                         Universe.t_ne := eq_refl |}))));
               ind_kelim := InType;
               ind_ctors := [];
               ind_projs := [] |}];
ind_universes := Monomorphic_ctx
                   ({|
                    LevelSet.this := [Level.Level
                                        "MetaCoq.Translations.param_other_test.338";
                                     Level.Level
                                       "MetaCoq.Translations.param_other_test.337"];
                    LevelSet.is_ok := LevelSet.Raw.add_ok
                                        (s:=[Level.Level
                                               "MetaCoq.Translations.param_other_test.337"])
                                        (Level.Level
                                           "MetaCoq.Translations.param_other_test.338")
                                        (LevelSet.Raw.add_ok (s:=[])
                                           (Level.Level
                                              "MetaCoq.Translations.param_other_test.337")
                                           LevelSet.Raw.empty_ok) |},
                   {|
                   ConstraintSet.this := [];
                   ConstraintSet.is_ok := ConstraintSet.Raw.empty_ok |});
ind_variance := None |}
MetaCoq.Translations.param_other_test.IT has been translated.
(tLambda (nNamed "X")
   (tSort
      {|
      Universe.t_set := {|
                        UnivExprSet.this := [UnivExpr.npe
                                               (NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.337",
                                               false)];
                        UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                               (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.337",
                                                 false)) |};
      Universe.t_ne := eq_refl |})
   (tLambda (nNamed "Xᴱ")
      (tProd nAnon (tRel 0)
         (tSort
            {|
            Universe.t_set := {|
                              UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.337",
                                                 false)];
                              UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.337",
                                                 false)) |};
            Universe.t_ne := eq_refl |}))
      (tLambda nAnon
         (tSort
            {|
            Universe.t_set := {|
                              UnivExprSet.this := [UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.338",
                                                 false)];
                              UnivExprSet.is_ok := UnivExprSet.Raw.singleton_ok
                                                 (UnivExpr.npe
                                                 (
                                                 NoPropLevel.Level
                                                 "MetaCoq.Translations.param_other_test.338",
                                                 false)) |};
            Universe.t_ne := eq_refl |})
         (tLambda nAnon
            (tApp
               (tInd
                  {|
                  inductive_mind := (MPfile
                                       ["param_other_test"; "Translations";
                                       "MetaCoq"], "IT");
                  inductive_ind := 0 |} []) [tRel 2; tRel 0])
            (tApp
               (tInd
                  {|
                  inductive_mind := (MPfile
                                       ["param_other_test"; "Translations";
                                       "MetaCoq"], "ITᴱ");
                  inductive_ind := 0 |} []) [tRel 3; tRel 2; tRel 1; tRel 0])))))
ITᴬᴱ = 
fun (X : Type) (Xᴱ : X -> Type) (H : Type) (H0 : IT X H) => ITᴱ X Xᴱ H H0
     : forall X : Type, (X -> Type) -> forall H : Type, IT X H -> Prop

Arguments ITᴬᴱ _%type_scope _%function_scope _%type_scope
param_other_test.vo (real: 6.62, user: 6.19, sys: 0.35, mem: 571132 ko)
COQC showcase.v
(String.String (Ascii.Ascii false true true true true true true false)
   (String.String (Ascii.Ascii false true true true true true true false)
      (String.String (Ascii.Ascii false true true true true true true false)
         (String.String
            (Ascii.Ascii false true true true true true true false)
            (String.String
               (Ascii.Ascii false true true true true true true false)
               (String.String
                  (Ascii.Ascii false true true true true true true false)
                  (String.String
                     (Ascii.Ascii false true true true true true true false)
                     (String.String
                        (Ascii.Ascii false true true true true true true
                           false)
                        (String.String
                           (Ascii.Ascii false true true true true true true
                              false)
                           (String.String
                              (Ascii.Ascii false true true true true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false true true true true true
                                    true false)
                                 (String.String
                                    (Ascii.Ascii false true true true true
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii false true true true true
                                          true true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true true true true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true true true true false)
                                                (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 String.EmptyString))))))))))))))))))
(String.String (Ascii.Ascii false false true true false false true false)
   (String.String (Ascii.Ascii true true true true false true true false)
      (String.String (Ascii.Ascii true true true true false true true false)
         (String.String
            (Ascii.Ascii true true false true false true true false)
            (String.String
               (Ascii.Ascii true false false true false true true false)
               (String.String
                  (Ascii.Ascii false true true true false true true false)
                  (String.String
                     (Ascii.Ascii true true true false false true true false)
                     (String.String
                        (Ascii.Ascii false false false false false true false
                           false)
                        (String.String
                           (Ascii.Ascii true false true false true true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false false false false false
                                    true false false)
                                 (String.String
                                    (Ascii.Ascii true true false false false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true true true true false
                                          true true false)
                                       (String.String
                                          (Ascii.Ascii true false false false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true false true false false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 true false false true false)
                                                (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))))))))))))
Complete Identifier: Coq.Init.Datatypes.nat
Short Identifier: nat
(String.String (Ascii.Ascii false false true false true false true false)
   (String.String (Ascii.Ascii false true false false true true true false)
      (String.String
         (Ascii.Ascii true false false false false true true false)
         (String.String
            (Ascii.Ascii false true true true false true true false)
            (String.String
               (Ascii.Ascii true true false false true true true false)
               (String.String
                  (Ascii.Ascii false false true true false true true false)
                  (String.String
                     (Ascii.Ascii true false false false false true true
                        false)
                     (String.String
                        (Ascii.Ascii false false true false true true true
                           false)
                        (String.String
                           (Ascii.Ascii true false true false false true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false false true
                                 false false)
                              (String.String
                                 (Ascii.Ascii true true false false false
                                    false true false)
                                 (String.String
                                    (Ascii.Ascii true true true true false
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii true false false false
                                          true true true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             false true false false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                true false false true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))))))))))))
(BasicAst.IndRef
   {|
   BasicAst.inductive_mind := (BasicAst.MPfile
                                 (String.String
                                    (Ascii.Ascii false false true false false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true false false false
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii false false true false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                  :: String.String
                                       (Ascii.Ascii true false false true
                                          false false true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             false true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                true false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                String.EmptyString)))
                                     :: String.String
                                          (Ascii.Ascii true true false false
                                             false false true false)
                                          (String.String
                                             (Ascii.Ascii true true true true
                                                false true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false true true true false)
                                                String.EmptyString)) :: nil)%list,
                              String.String
                                (Ascii.Ascii false true true true false true
                                   true false)
                                (String.String
                                   (Ascii.Ascii true false false false false
                                      true true false)
                                   (String.String
                                      (Ascii.Ascii false false true false
                                         true true true false)
                                      String.EmptyString)));
   BasicAst.inductive_ind := 0 |})
{|
Ast.ind_finite := BasicAst.Finite;
Ast.ind_npars := 0;
Ast.ind_params := nil;
Ast.ind_bodies := {|
                  Ast.ind_name := String.String
                                    (Ascii.Ascii false true true true false
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii true false false false
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii false false true false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false true true true)
                                             (String.String
                                                (Ascii.Ascii true false true
                                                 false true true false true)
                                                (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString)))));
                  Ast.ind_type := Ast.tProd BasicAst.nAnon
                                    (Ast.tInd
                                       {|
                                       BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)));
                                       BasicAst.inductive_ind := 0 |} nil)
                                    (Ast.tSort
                                       {|
                                       Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)) |};
                                       Universes.Universe.t_ne := eq_refl |});
                  Ast.ind_kelim := Universes.InType;
                  Ast.ind_ctors := (String.String
                                      (Ascii.Ascii true true true true false
                                         false true false)
                                      (String.String
                                         (Ascii.Ascii true false false false
                                            false true true true)
                                         (String.String
                                            (Ascii.Ascii true false true
                                               false true true false true)
                                            (String.String
                                               (Ascii.Ascii true true true
                                                 false true false false true)
                                               String.EmptyString))),
                                   Ast.tApp (Ast.tRel 0)
                                     (Ast.tConstruct
                                        {|
                                        BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)));
                                        BasicAst.inductive_ind := 0 |} 0 nil
                                      :: nil), 0)
                                   :: (String.String
                                         (Ascii.Ascii true true false false
                                            true false true false)
                                         (String.String
                                            (Ascii.Ascii true false false
                                               false false true true true)
                                            (String.String
                                               (Ascii.Ascii true false true
                                                 false true true false true)
                                               (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString))),
                                      Ast.tProd BasicAst.nAnon
                                        (Ast.tInd
                                           {|
                                           BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)));
                                           BasicAst.inductive_ind := 0 |} nil)
                                        (Ast.tProd BasicAst.nAnon
                                           (Ast.tApp 
                                              (Ast.tRel 1)
                                              (Ast.tRel 0 :: nil))
                                           (Ast.tApp 
                                              (Ast.tRel 2)
                                              (Ast.tApp
                                                 (Ast.tConstruct
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)));
                                                 BasicAst.inductive_ind := 0 |}
                                                 1 nil) 
                                                 (Ast.tRel 1 :: nil) :: nil))),
                                      2) :: nil;
                  Ast.ind_projs := nil |} :: nil;
Ast.ind_universes := Universes.Monomorphic_ctx
                       ({|
                        Universes.LevelSet.this := nil;
                        Universes.LevelSet.is_ok := Universes.LevelSet.Raw.empty_ok |},
                       {|
                       Universes.ConstraintSet.this := nil;
                       Universes.ConstraintSet.is_ok := Universes.ConstraintSet.Raw.empty_ok |});
Ast.ind_variance := None |}
Coq.Init.Datatypes.nat has been translated.
(String.String (Ascii.Ascii false true true true true true true false)
   (String.String (Ascii.Ascii false true true true true true true false)
      (String.String (Ascii.Ascii false true true true true true true false)
         (String.String
            (Ascii.Ascii false true true true true true true false)
            (String.String
               (Ascii.Ascii false true true true true true true false)
               (String.String
                  (Ascii.Ascii false true true true true true true false)
                  (String.String
                     (Ascii.Ascii false true true true true true true false)
                     (String.String
                        (Ascii.Ascii false true true true true true true
                           false)
                        (String.String
                           (Ascii.Ascii false true true true true true true
                              false)
                           (String.String
                              (Ascii.Ascii false true true true true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false true true true true true
                                    true false)
                                 (String.String
                                    (Ascii.Ascii false true true true true
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii false true true true true
                                          true true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true true true true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true true true true false)
                                                (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 String.EmptyString))))))))))))))))))
(String.String (Ascii.Ascii false false true true false false true false)
   (String.String (Ascii.Ascii true true true true false true true false)
      (String.String (Ascii.Ascii true true true true false true true false)
         (String.String
            (Ascii.Ascii true true false true false true true false)
            (String.String
               (Ascii.Ascii true false false true false true true false)
               (String.String
                  (Ascii.Ascii false true true true false true true false)
                  (String.String
                     (Ascii.Ascii true true true false false true true false)
                     (String.String
                        (Ascii.Ascii false false false false false true false
                           false)
                        (String.String
                           (Ascii.Ascii true false true false true true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false false false false false
                                    true false false)
                                 (String.String
                                    (Ascii.Ascii true true false false false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true true true true false
                                          true true false)
                                       (String.String
                                          (Ascii.Ascii true false false false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true false true false false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 true false false true false)
                                                (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))))))))))))
Complete Identifier: Coq.Init.Datatypes.nat
Short Identifier: nat
(String.String (Ascii.Ascii false false true false true false true false)
   (String.String (Ascii.Ascii false true false false true true true false)
      (String.String
         (Ascii.Ascii true false false false false true true false)
         (String.String
            (Ascii.Ascii false true true true false true true false)
            (String.String
               (Ascii.Ascii true true false false true true true false)
               (String.String
                  (Ascii.Ascii false false true true false true true false)
                  (String.String
                     (Ascii.Ascii true false false false false true true
                        false)
                     (String.String
                        (Ascii.Ascii false false true false true true true
                           false)
                        (String.String
                           (Ascii.Ascii true false true false false true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false false true
                                 false false)
                              (String.String
                                 (Ascii.Ascii true true false false false
                                    false true false)
                                 (String.String
                                    (Ascii.Ascii true true true true false
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii true false false false
                                          true true true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             false true false false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                true false false true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))))))))))))
(BasicAst.IndRef
   {|
   BasicAst.inductive_mind := (BasicAst.MPfile
                                 (String.String
                                    (Ascii.Ascii false false true false false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true false false false
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii false false true false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                  :: String.String
                                       (Ascii.Ascii true false false true
                                          false false true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             false true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                true false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                String.EmptyString)))
                                     :: String.String
                                          (Ascii.Ascii true true false false
                                             false false true false)
                                          (String.String
                                             (Ascii.Ascii true true true true
                                                false true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false true true true false)
                                                String.EmptyString)) :: nil)%list,
                              String.String
                                (Ascii.Ascii false true true true false true
                                   true false)
                                (String.String
                                   (Ascii.Ascii true false false false false
                                      true true false)
                                   (String.String
                                      (Ascii.Ascii false false true false
                                         true true true false)
                                      String.EmptyString)));
   BasicAst.inductive_ind := 0 |})
{|
Ast.ind_finite := BasicAst.Finite;
Ast.ind_npars := 0;
Ast.ind_params := nil;
Ast.ind_bodies := {|
                  Ast.ind_name := String.String
                                    (Ascii.Ascii false true true true false
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii true false false false
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii false false true false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false true true true)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true false true)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))));
                  Ast.ind_type := Ast.tProd BasicAst.nAnon
                                    (Ast.tApp
                                       (Ast.tInd
                                          {|
                                          BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)));
                                          BasicAst.inductive_ind := 0 |} nil)
                                       nil)
                                    (Ast.tSort
                                       {|
                                       Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)) |};
                                       Universes.Universe.t_ne := eq_refl |});
                  Ast.ind_kelim := Universes.InType;
                  Ast.ind_ctors := (String.String
                                      (Ascii.Ascii true true false false true
                                         false true false)
                                      (String.String
                                         (Ascii.Ascii true false false false
                                            false true true true)
                                         (String.String
                                            (Ascii.Ascii false false true
                                               false true true false true)
                                            (String.String
                                               (Ascii.Ascii true false false
                                                 false true true false true)
                                               (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true false
                                                 false) String.EmptyString)))),
                                   Ast.tProd BasicAst.nAnon
                                     (Ast.tInd
                                        {|
                                        BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)));
                                        BasicAst.inductive_ind := 0 |} nil)
                                     (Ast.tProd BasicAst.nAnon
                                        (Ast.tApp 
                                           (Ast.tRel 1) 
                                           (Ast.tRel 0 :: nil))
                                        (Ast.tApp 
                                           (Ast.tRel 2)
                                           (Ast.tApp
                                              (Ast.tConstruct
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)));
                                                 BasicAst.inductive_ind := 0 |}
                                                 1 nil) 
                                              (Ast.tRel 1 :: nil) :: nil))),
                                   2) :: nil;
                  Ast.ind_projs := nil |} :: nil;
Ast.ind_universes := Universes.Monomorphic_ctx
                       ({|
                        Universes.LevelSet.this := nil;
                        Universes.LevelSet.is_ok := Universes.LevelSet.Raw.empty_ok |},
                       {|
                       Universes.ConstraintSet.this := nil;
                       Universes.ConstraintSet.is_ok := Universes.ConstraintSet.Raw.empty_ok |});
Ast.ind_variance := None |}
Coq.Init.Datatypes.nat has been translated.
(Ast.tLambda BasicAst.nAnon
   (Ast.tApp
      (Ast.tInd
         {|
         BasicAst.inductive_mind := (BasicAst.MPfile
                                       (String.String
                                          (Ascii.Ascii false false true false
                                             false false true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                        :: String.String
                                             (Ascii.Ascii true false false
                                                true false false true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                           :: String.String
                                                (Ascii.Ascii true true false
                                                 false false false true false)
                                                (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                              :: nil)%list,
                                    String.String
                                      (Ascii.Ascii false true true true false
                                         true true false)
                                      (String.String
                                         (Ascii.Ascii true false false false
                                            false true true false)
                                         (String.String
                                            (Ascii.Ascii false false true
                                               false true true true false)
                                            String.EmptyString)));
         BasicAst.inductive_ind := 0 |} nil) nil)
   (Ast.tInd
      {|
      BasicAst.inductive_mind := (BasicAst.MPfile
                                    (String.String
                                       (Ascii.Ascii false false true true
                                          false false true false)
                                       (String.String
                                          (Ascii.Ascii true true true true
                                             false true true false)
                                          (String.String
                                             (Ascii.Ascii true true true
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 String.EmptyString))))
                                     :: String.String
                                          (Ascii.Ascii true false false true
                                             false false true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true false true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                        :: String.String
                                             (Ascii.Ascii true true false
                                                false false false true false)
                                             (String.String
                                                (Ascii.Ascii true true true
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                           :: nil)%list,
                                 String.String
                                   (Ascii.Ascii false true true false false
                                      false true false)
                                   (String.String
                                      (Ascii.Ascii true false false false
                                         false true true false)
                                      (String.String
                                         (Ascii.Ascii false false true true
                                            false true true false)
                                         (String.String
                                            (Ascii.Ascii true true false
                                               false true true true false)
                                            (String.String
                                               (Ascii.Ascii true false true
                                                 false false true true false)
                                               String.EmptyString)))));
      BasicAst.inductive_ind := 0 |} nil))
(Ast.tLambda BasicAst.nAnon
   (Ast.tApp
      (Ast.tInd
         {|
         BasicAst.inductive_mind := (BasicAst.MPfile
                                       (String.String
                                          (Ascii.Ascii false false true false
                                             false false true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                        :: String.String
                                             (Ascii.Ascii true false false
                                                true false false true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                           :: String.String
                                                (Ascii.Ascii true true false
                                                 false false false true false)
                                                (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                              :: nil)%list,
                                    String.String
                                      (Ascii.Ascii false true true true false
                                         true true false)
                                      (String.String
                                         (Ascii.Ascii true false false false
                                            false true true false)
                                         (String.String
                                            (Ascii.Ascii false false true
                                               false true true true false)
                                            String.EmptyString)));
         BasicAst.inductive_ind := 0 |} nil) nil)
   (Ast.tInd
      {|
      BasicAst.inductive_mind := (BasicAst.MPfile
                                    (String.String
                                       (Ascii.Ascii false false true true
                                          false false true false)
                                       (String.String
                                          (Ascii.Ascii true true true true
                                             false true true false)
                                          (String.String
                                             (Ascii.Ascii true true true
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 String.EmptyString))))
                                     :: String.String
                                          (Ascii.Ascii true false false true
                                             false false true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true false true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                        :: String.String
                                             (Ascii.Ascii true true false
                                                false false false true false)
                                             (String.String
                                                (Ascii.Ascii true true true
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                           :: nil)%list,
                                 String.String
                                   (Ascii.Ascii false false true false true
                                      false true false)
                                   (String.String
                                      (Ascii.Ascii false true false false
                                         true true true false)
                                      (String.String
                                         (Ascii.Ascii true false true false
                                            true true true false)
                                         (String.String
                                            (Ascii.Ascii true false true
                                               false false true true false)
                                            String.EmptyString))));
      BasicAst.inductive_ind := 0 |} nil))
Derived natᵗ=natᴬᴬ, natᴬᴱ, natᴱᴬ, and natᴱ=natᴱᴱ.
Inductive natᵗ : nat -> Set :=
    Oᵗ : natᵗ 0 | Sᵗ : forall H : nat, natᵗ H -> natᵗ (S H)

Arguments natᵗ _%nat_scope
Arguments Sᵗ _%nat_scope
natᴬᴱ = fun _ : nat => True
     : nat -> Prop

Arguments natᴬᴱ _%nat_scope
natᴱᴬ = fun _ : nat => False
     : nat -> Prop

Arguments natᴱᴬ _%nat_scope
Inductive natᴱ : nat -> Set :=  Sᴱ0 : forall H : nat, natᴱ H -> natᴱ (S H)

Arguments natᴱ _%nat_scope
Arguments Sᴱ0 _%nat_scope
(String.String (Ascii.Ascii false true true true true true true false)
   (String.String (Ascii.Ascii false true true true true true true false)
      (String.String (Ascii.Ascii false true true true true true true false)
         (String.String
            (Ascii.Ascii false true true true true true true false)
            (String.String
               (Ascii.Ascii false true true true true true true false)
               (String.String
                  (Ascii.Ascii false true true true true true true false)
                  (String.String
                     (Ascii.Ascii false true true true true true true false)
                     (String.String
                        (Ascii.Ascii false true true true true true true
                           false)
                        (String.String
                           (Ascii.Ascii false true true true true true true
                              false)
                           (String.String
                              (Ascii.Ascii false true true true true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false true true true true true
                                    true false)
                                 (String.String
                                    (Ascii.Ascii false true true true true
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii false true true true true
                                          true true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true true true true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true true true true false)
                                                (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 String.EmptyString))))))))))))))))))
(String.String (Ascii.Ascii false false true true false false true false)
   (String.String (Ascii.Ascii true true true true false true true false)
      (String.String (Ascii.Ascii true true true true false true true false)
         (String.String
            (Ascii.Ascii true true false true false true true false)
            (String.String
               (Ascii.Ascii true false false true false true true false)
               (String.String
                  (Ascii.Ascii false true true true false true true false)
                  (String.String
                     (Ascii.Ascii true true true false false true true false)
                     (String.String
                        (Ascii.Ascii false false false false false true false
                           false)
                        (String.String
                           (Ascii.Ascii true false true false true true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false false false false false
                                    true false false)
                                 (String.String
                                    (Ascii.Ascii true true false false false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true true true true false
                                          true true false)
                                       (String.String
                                          (Ascii.Ascii true false false false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true false true false false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 true false false true false)
                                                (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))))))))))))
Complete Identifier: Coq.Init.Datatypes.list
Short Identifier: list
(String.String (Ascii.Ascii false false true false true false true false)
   (String.String (Ascii.Ascii false true false false true true true false)
      (String.String
         (Ascii.Ascii true false false false false true true false)
         (String.String
            (Ascii.Ascii false true true true false true true false)
            (String.String
               (Ascii.Ascii true true false false true true true false)
               (String.String
                  (Ascii.Ascii false false true true false true true false)
                  (String.String
                     (Ascii.Ascii true false false false false true true
                        false)
                     (String.String
                        (Ascii.Ascii false false true false true true true
                           false)
                        (String.String
                           (Ascii.Ascii true false true false false true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false false true
                                 false false)
                              (String.String
                                 (Ascii.Ascii true true false false false
                                    false true false)
                                 (String.String
                                    (Ascii.Ascii true true true true false
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii true false false false
                                          true true true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             false true false false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                true false false true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))))))))))))
(BasicAst.IndRef
   {|
   BasicAst.inductive_mind := (BasicAst.MPfile
                                 (String.String
                                    (Ascii.Ascii false false true false false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true false false false
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii false false true false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                  :: String.String
                                       (Ascii.Ascii true false false true
                                          false false true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             false true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                true false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                String.EmptyString)))
                                     :: String.String
                                          (Ascii.Ascii true true false false
                                             false false true false)
                                          (String.String
                                             (Ascii.Ascii true true true true
                                                false true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false true true true false)
                                                String.EmptyString)) :: nil)%list,
                              String.String
                                (Ascii.Ascii false false true true false true
                                   true false)
                                (String.String
                                   (Ascii.Ascii true false false true false
                                      true true false)
                                   (String.String
                                      (Ascii.Ascii true true false false true
                                         true true false)
                                      (String.String
                                         (Ascii.Ascii false false true false
                                            true true true false)
                                         String.EmptyString))));
   BasicAst.inductive_ind := 0 |})
{|
Ast.ind_finite := BasicAst.Finite;
Ast.ind_npars := 2;
Ast.ind_params := ({|
                   Ast.decl_name := BasicAst.nNamed
                                      (String.String
                                         (Ascii.Ascii true false false false
                                            false false true false)
                                         (String.String
                                            (Ascii.Ascii true false false
                                               false false true true true)
                                            (String.String
                                               (Ascii.Ascii true false true
                                                 false true true false true)
                                               (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString))));
                   Ast.decl_body := None;
                   Ast.decl_type := Ast.tProd BasicAst.nAnon 
                                      (Ast.tRel 0)
                                      (Ast.tSort
                                         {|
                                         Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))),
                                                 false)) |};
                                         Universes.Universe.t_ne := eq_refl |}) |}
                   :: {|
                      Ast.decl_name := BasicAst.nNamed
                                         (String.String
                                            (Ascii.Ascii true false false
                                               false false false true false)
                                            String.EmptyString);
                      Ast.decl_body := None;
                      Ast.decl_type := Ast.tSort
                                         {|
                                         Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))))))))),
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
                                         Universes.Universe.t_ne := eq_refl |} |}
                      :: nil)%list;
Ast.ind_bodies := {|
                  Ast.ind_name := String.String
                                    (Ascii.Ascii false false true true false
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii true false false true
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii true true false false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false false true
                                                false true true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false false true true true)
                                                (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString))))));
                  Ast.ind_type := Ast.tProd
                                    (BasicAst.nNamed
                                       (String.String
                                          (Ascii.Ascii true false false false
                                             false false true false)
                                          String.EmptyString))
                                    (Ast.tSort
                                       {|
                                       Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
                                       Universes.Universe.t_ne := eq_refl |})
                                    (Ast.tProd
                                       (BasicAst.nNamed
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false false true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false false true true true)
                                                (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString)))))
                                       (Ast.tProd BasicAst.nAnon 
                                          (Ast.tRel 0)
                                          (Ast.tSort
                                             {|
                                             Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false)) |};
                                             Universes.Universe.t_ne := eq_refl |}))
                                       (Ast.tProd BasicAst.nAnon
                                          (Ast.tApp
                                             (Ast.tInd
                                                {|
                                                BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
                                                BasicAst.inductive_ind := 0 |}
                                                nil) 
                                             (Ast.tRel 1 :: nil))
                                          (Ast.tSort
                                             {|
                                             Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)
                                                 :: Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.add_ok
                                                 (s:=(Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil)%list)
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false))
                                                 (Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false))) |};
                                             Universes.Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))))),
                                                 false))
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)) |};
                                                 Universes.Universe.t_ne := eq_refl |} |})));
                  Ast.ind_kelim := Universes.InType;
                  Ast.ind_ctors := (String.String
                                      (Ascii.Ascii false true true true false
                                         true true false)
                                      (String.String
                                         (Ascii.Ascii true false false true
                                            false true true false)
                                         (String.String
                                            (Ascii.Ascii false false true
                                               true false true true false)
                                            (String.String
                                               (Ascii.Ascii true false false
                                                 false false true true true)
                                               (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString))))),
                                   Ast.tProd
                                     (BasicAst.nNamed
                                        (String.String
                                           (Ascii.Ascii true false false
                                              false false false true false)
                                           String.EmptyString))
                                     (Ast.tSort
                                        {|
                                        Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))))),
                                                 false)) |};
                                        Universes.Universe.t_ne := eq_refl |})
                                     (Ast.tProd
                                        (BasicAst.nNamed
                                           (String.String
                                              (Ascii.Ascii true false false
                                                 false false false true false)
                                              (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString)))))
                                        (Ast.tProd BasicAst.nAnon
                                           (Ast.tRel 0)
                                           (Ast.tSort
                                              {|
                                              Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false)) |};
                                              Universes.Universe.t_ne := eq_refl |}))
                                        (Ast.tApp 
                                           (Ast.tRel 2)
                                           (Ast.tRel 1
                                            :: Ast.tRel 0
                                               :: 
                                               Ast.tApp
                                                 (Ast.tConstruct
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 0 nil) 
                                                 (Ast.tRel 1 :: nil) :: nil))),
                                   2)
                                   :: (String.String
                                         (Ascii.Ascii true true false false
                                            false true true false)
                                         (String.String
                                            (Ascii.Ascii true true true true
                                               false true true false)
                                            (String.String
                                               (Ascii.Ascii false true true
                                                 true false true true false)
                                               (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString)))))),
                                      Ast.tProd
                                        (BasicAst.nNamed
                                           (String.String
                                              (Ascii.Ascii true false false
                                                 false false false true false)
                                              String.EmptyString))
                                        (Ast.tSort
                                           {|
                                           Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))))))),
                                                 false)) |};
                                           Universes.Universe.t_ne := eq_refl |})
                                        (Ast.tProd
                                           (BasicAst.nNamed
                                              (String.String
                                                 (Ascii.Ascii true false
                                                 false false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString)))))
                                           (Ast.tProd BasicAst.nAnon
                                              (Ast.tRel 0)
                                              (Ast.tSort
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String (...) (...)))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String (...) (...)))))))))))),
                                                 false)) |};
                                                 Universes.Universe.t_ne := eq_refl |}))
                                           (Ast.tProd BasicAst.nAnon
                                              (Ast.tRel 1)
                                              (Ast.tProd BasicAst.nAnon
                                                 (Ast.tApp 
                                                 (Ast.tRel 1)
                                                 (Ast.tRel 0 :: nil))
                                                 (Ast.tProd BasicAst.nAnon
                                                 (Ast.tApp
                                                 (Ast.tInd
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 nil) 
                                                 (Ast.tRel 3 :: nil))
                                                 (Ast.tProd BasicAst.nAnon
                                                 (Ast.tApp 
                                                 (Ast.tRel 5)
                                                 (Ast.tRel 4
                                                 :: 
                                                 Ast.tRel 3
                                                 :: 
                                                 Ast.tRel 0 :: nil))
                                                 (Ast.tApp 
                                                 (Ast.tRel 6)
                                                 (Ast.tRel 5
                                                 :: 
                                                 Ast.tRel 4
                                                 :: 
                                                 Ast.tApp
                                                 (Ast.tConstruct
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String ... ...))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 1 nil)
                                                 (Ast.tRel 5
                                                 :: 
                                                 Ast.tRel 3
                                                 :: 
                                                 Ast.tRel 1 :: nil) :: nil))))))),
                                      6) :: nil;
                  Ast.ind_projs := nil |} :: nil;
Ast.ind_universes := Universes.Monomorphic_ctx
                       ({|
                        Universes.LevelSet.this := (Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String ... ...)))))))))))))))))))
                                                 :: nil)%list;
                        Universes.LevelSet.is_ok := Universes.LevelSet.Raw.add_ok
                                                 (s:=nil)
                                                 (Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String ... ...))))))))))))))))))))
                                                 Universes.LevelSet.Raw.empty_ok |},
                       {|
                       Universes.ConstraintSet.this := nil;
                       Universes.ConstraintSet.is_ok := Universes.ConstraintSet.Raw.empty_ok |});
Ast.ind_variance := None |}
Coq.Init.Datatypes.list has been translated.
(String.String (Ascii.Ascii false true true true true true true false)
   (String.String (Ascii.Ascii false true true true true true true false)
      (String.String (Ascii.Ascii false true true true true true true false)
         (String.String
            (Ascii.Ascii false true true true true true true false)
            (String.String
               (Ascii.Ascii false true true true true true true false)
               (String.String
                  (Ascii.Ascii false true true true true true true false)
                  (String.String
                     (Ascii.Ascii false true true true true true true false)
                     (String.String
                        (Ascii.Ascii false true true true true true true
                           false)
                        (String.String
                           (Ascii.Ascii false true true true true true true
                              false)
                           (String.String
                              (Ascii.Ascii false true true true true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false true true true true true
                                    true false)
                                 (String.String
                                    (Ascii.Ascii false true true true true
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii false true true true true
                                          true true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true true true true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true true true true false)
                                                (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 String.EmptyString))))))))))))))))))
(String.String (Ascii.Ascii false false true true false false true false)
   (String.String (Ascii.Ascii true true true true false true true false)
      (String.String (Ascii.Ascii true true true true false true true false)
         (String.String
            (Ascii.Ascii true true false true false true true false)
            (String.String
               (Ascii.Ascii true false false true false true true false)
               (String.String
                  (Ascii.Ascii false true true true false true true false)
                  (String.String
                     (Ascii.Ascii true true true false false true true false)
                     (String.String
                        (Ascii.Ascii false false false false false true false
                           false)
                        (String.String
                           (Ascii.Ascii true false true false true true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false false false false false
                                    true false false)
                                 (String.String
                                    (Ascii.Ascii true true false false false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true true true true false
                                          true true false)
                                       (String.String
                                          (Ascii.Ascii true false false false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true false true false false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 true false false true false)
                                                (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))))))))))))
Complete Identifier: Coq.Init.Datatypes.list
Short Identifier: list
(String.String (Ascii.Ascii false false true false true false true false)
   (String.String (Ascii.Ascii false true false false true true true false)
      (String.String
         (Ascii.Ascii true false false false false true true false)
         (String.String
            (Ascii.Ascii false true true true false true true false)
            (String.String
               (Ascii.Ascii true true false false true true true false)
               (String.String
                  (Ascii.Ascii false false true true false true true false)
                  (String.String
                     (Ascii.Ascii true false false false false true true
                        false)
                     (String.String
                        (Ascii.Ascii false false true false true true true
                           false)
                        (String.String
                           (Ascii.Ascii true false true false false true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false false true
                                 false false)
                              (String.String
                                 (Ascii.Ascii true true false false false
                                    false true false)
                                 (String.String
                                    (Ascii.Ascii true true true true false
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii true false false false
                                          true true true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             false true false false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                true false false true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))))))))))))
(BasicAst.IndRef
   {|
   BasicAst.inductive_mind := (BasicAst.MPfile
                                 (String.String
                                    (Ascii.Ascii false false true false false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true false false false
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii false false true false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                  :: String.String
                                       (Ascii.Ascii true false false true
                                          false false true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             false true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                true false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                String.EmptyString)))
                                     :: String.String
                                          (Ascii.Ascii true true false false
                                             false false true false)
                                          (String.String
                                             (Ascii.Ascii true true true true
                                                false true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false true true true false)
                                                String.EmptyString)) :: nil)%list,
                              String.String
                                (Ascii.Ascii false false true true false true
                                   true false)
                                (String.String
                                   (Ascii.Ascii true false false true false
                                      true true false)
                                   (String.String
                                      (Ascii.Ascii true true false false true
                                         true true false)
                                      (String.String
                                         (Ascii.Ascii false false true false
                                            true true true false)
                                         String.EmptyString))));
   BasicAst.inductive_ind := 0 |})
{|
Ast.ind_finite := BasicAst.Finite;
Ast.ind_npars := 2;
Ast.ind_params := ({|
                   Ast.decl_name := BasicAst.nNamed
                                      (String.String
                                         (Ascii.Ascii true false false false
                                            false false true false)
                                         (String.String
                                            (Ascii.Ascii true false false
                                               false false true true true)
                                            (String.String
                                               (Ascii.Ascii false false true
                                                 false true true false true)
                                               (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString))));
                   Ast.decl_body := None;
                   Ast.decl_type := Ast.tProd BasicAst.nAnon 
                                      (Ast.tRel 0)
                                      (Ast.tSort
                                         {|
                                         Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))),
                                                 false)) |};
                                         Universes.Universe.t_ne := eq_refl |}) |}
                   :: {|
                      Ast.decl_name := BasicAst.nNamed
                                         (String.String
                                            (Ascii.Ascii true false false
                                               false false false true false)
                                            String.EmptyString);
                      Ast.decl_body := None;
                      Ast.decl_type := Ast.tSort
                                         {|
                                         Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))))))))),
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
                                         Universes.Universe.t_ne := eq_refl |} |}
                      :: nil)%list;
Ast.ind_bodies := {|
                  Ast.ind_name := String.String
                                    (Ascii.Ascii false false true true false
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii true false false true
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii true true false false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false false true
                                                false true true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false false true true true)
                                                (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString))))));
                  Ast.ind_type := Ast.tProd
                                    (BasicAst.nNamed
                                       (String.String
                                          (Ascii.Ascii true false false false
                                             false false true false)
                                          String.EmptyString))
                                    (Ast.tSort
                                       {|
                                       Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
                                       Universes.Universe.t_ne := eq_refl |})
                                    (Ast.tProd
                                       (BasicAst.nNamed
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false false true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false false true true true)
                                                (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))
                                       (Ast.tProd BasicAst.nAnon 
                                          (Ast.tRel 0)
                                          (Ast.tSort
                                             {|
                                             Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false)) |};
                                             Universes.Universe.t_ne := eq_refl |}))
                                       (Ast.tProd BasicAst.nAnon
                                          (Ast.tApp
                                             (Ast.tInd
                                                {|
                                                BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
                                                BasicAst.inductive_ind := 0 |}
                                                nil) 
                                             (Ast.tRel 1 :: nil))
                                          (Ast.tSort
                                             {|
                                             Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)
                                                 :: Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.add_ok
                                                 (s:=(Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil)%list)
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false))
                                                 (Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false))) |};
                                             Universes.Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))))),
                                                 false))
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)) |};
                                                 Universes.Universe.t_ne := eq_refl |} |})));
                  Ast.ind_kelim := Universes.InType;
                  Ast.ind_ctors := (String.String
                                      (Ascii.Ascii true true false false
                                         false true true false)
                                      (String.String
                                         (Ascii.Ascii true true true true
                                            false true true false)
                                         (String.String
                                            (Ascii.Ascii false true true true
                                               false true true false)
                                            (String.String
                                               (Ascii.Ascii true true false
                                                 false true true true false)
                                               (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true false
                                                 false) String.EmptyString))))))),
                                   Ast.tProd
                                     (BasicAst.nNamed
                                        (String.String
                                           (Ascii.Ascii true false false
                                              false false false true false)
                                           String.EmptyString))
                                     (Ast.tSort
                                        {|
                                        Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))))),
                                                 false)) |};
                                        Universes.Universe.t_ne := eq_refl |})
                                     (Ast.tProd
                                        (BasicAst.nNamed
                                           (String.String
                                              (Ascii.Ascii true false false
                                                 false false false true false)
                                              (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))
                                        (Ast.tProd BasicAst.nAnon
                                           (Ast.tRel 0)
                                           (Ast.tSort
                                              {|
                                              Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false)) |};
                                              Universes.Universe.t_ne := eq_refl |}))
                                        (Ast.tProd BasicAst.nAnon
                                           (Ast.tRel 1)
                                           (Ast.tProd BasicAst.nAnon
                                              (Ast.tApp
                                                 (Ast.tInd
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 nil) 
                                                 (Ast.tRel 2 :: nil))
                                              (Ast.tProd BasicAst.nAnon
                                                 (Ast.tApp 
                                                 (Ast.tRel 2)
                                                 (Ast.tRel 1 :: nil))
                                                 (Ast.tApp 
                                                 (Ast.tRel 5)
                                                 (Ast.tRel 4
                                                 :: 
                                                 Ast.tRel 3
                                                 :: 
                                                 Ast.tApp
                                                 (Ast.tConstruct
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String (...) (...))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 1 nil)
                                                 (Ast.tRel 4
                                                 :: 
                                                 Ast.tRel 2
                                                 :: 
                                                 Ast.tRel 1 :: nil) :: nil)))))),
                                   3)
                                   :: (String.String
                                         (Ascii.Ascii true true false false
                                            false true true false)
                                         (String.String
                                            (Ascii.Ascii true true true true
                                               false true true false)
                                            (String.String
                                               (Ascii.Ascii false true true
                                                 true false true true false)
                                               (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 false) String.EmptyString))))))),
                                      Ast.tProd
                                        (BasicAst.nNamed
                                           (String.String
                                              (Ascii.Ascii true false false
                                                 false false false true false)
                                              String.EmptyString))
                                        (Ast.tSort
                                           {|
                                           Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))))))),
                                                 false)) |};
                                           Universes.Universe.t_ne := eq_refl |})
                                        (Ast.tProd
                                           (BasicAst.nNamed
                                              (String.String
                                                 (Ascii.Ascii true false
                                                 false false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))
                                           (Ast.tProd BasicAst.nAnon
                                              (Ast.tRel 0)
                                              (Ast.tSort
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String (...) (...)))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String (...) (...)))))))))))),
                                                 false)) |};
                                                 Universes.Universe.t_ne := eq_refl |}))
                                           (Ast.tProd BasicAst.nAnon
                                              (Ast.tRel 1)
                                              (Ast.tProd BasicAst.nAnon
                                                 (Ast.tApp
                                                 (Ast.tInd
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 nil) 
                                                 (Ast.tRel 2 :: nil))
                                                 (Ast.tProd BasicAst.nAnon
                                                 (Ast.tApp 
                                                 (Ast.tRel 4)
                                                 (Ast.tRel 3
                                                 :: 
                                                 Ast.tRel 2
                                                 :: 
                                                 Ast.tRel 0 :: nil))
                                                 (Ast.tApp 
                                                 (Ast.tRel 5)
                                                 (Ast.tRel 4
                                                 :: 
                                                 Ast.tRel 3
                                                 :: 
                                                 Ast.tApp
                                                 (Ast.tConstruct
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String ... ...)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 1 nil)
                                                 (Ast.tRel 4
                                                 :: 
                                                 Ast.tRel 2
                                                 :: 
                                                 Ast.tRel 1 :: nil) :: nil)))))),
                                      3) :: nil;
                  Ast.ind_projs := nil |} :: nil;
Ast.ind_universes := Universes.Monomorphic_ctx
                       ({|
                        Universes.LevelSet.this := (Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String ... ...)))))))))))))))))))
                                                 :: nil)%list;
                        Universes.LevelSet.is_ok := Universes.LevelSet.Raw.add_ok
                                                 (s:=nil)
                                                 (Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String ... ...))))))))))))))))))))
                                                 Universes.LevelSet.Raw.empty_ok |},
                       {|
                       Universes.ConstraintSet.this := nil;
                       Universes.ConstraintSet.is_ok := Universes.ConstraintSet.Raw.empty_ok |});
Ast.ind_variance := None |}
Coq.Init.Datatypes.list has been translated.
(Ast.tLambda
   (BasicAst.nNamed
      (String.String
         (Ascii.Ascii true false false false false false true false)
         String.EmptyString))
   (Ast.tSort
      {|
      Universes.Universe.t_set := {|
                                  Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))))),
                                                 false) :: nil)%list;
                                  Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))))),
                                                 false)) |};
      Universes.Universe.t_ne := eq_refl |})
   (Ast.tLambda
      (BasicAst.nNamed
         (String.String
            (Ascii.Ascii true false false false false false true false)
            (String.String
               (Ascii.Ascii true false false false false true true true)
               (String.String
                  (Ascii.Ascii false false true false true true false true)
                  (String.String
                     (Ascii.Ascii true false false false true true false true)
                     String.EmptyString)))))
      (Ast.tProd BasicAst.nAnon (Ast.tRel 0)
         (Ast.tSort
            {|
            Universes.Universe.t_set := {|
                                        Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil)%list;
                                        Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
            Universes.Universe.t_ne := eq_refl |}))
      (Ast.tLambda BasicAst.nAnon
         (Ast.tApp
            (Ast.tInd
               {|
               BasicAst.inductive_mind := (BasicAst.MPfile
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false false false true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                              :: String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                          String.String
                                            (Ascii.Ascii false false true
                                               true false true true false)
                                            (String.String
                                               (Ascii.Ascii true false false
                                                 true false true true false)
                                               (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
               BasicAst.inductive_ind := 0 |} nil) 
            (Ast.tRel 1 :: nil))
         (Ast.tApp
            (Ast.tInd
               {|
               BasicAst.inductive_mind := (BasicAst.MPfile
                                             (String.String
                                                (Ascii.Ascii true true false
                                                 false true true true false)
                                                (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                              :: String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString)))))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                                 :: nil)%list,
                                          String.String
                                            (Ascii.Ascii false false true
                                               true false true true false)
                                            (String.String
                                               (Ascii.Ascii true false false
                                                 true false true true false)
                                               (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString)))))));
               BasicAst.inductive_ind := 0 |} nil)
            (Ast.tRel 2 :: Ast.tRel 1 :: Ast.tRel 0 :: nil)))))
(Ast.tLambda
   (BasicAst.nNamed
      (String.String
         (Ascii.Ascii true false false false false false true false)
         String.EmptyString))
   (Ast.tSort
      {|
      Universes.Universe.t_set := {|
                                  Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))))),
                                                 false) :: nil)%list;
                                  Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))))),
                                                 false)) |};
      Universes.Universe.t_ne := eq_refl |})
   (Ast.tLambda
      (BasicAst.nNamed
         (String.String
            (Ascii.Ascii true false false false false false true false)
            (String.String
               (Ascii.Ascii true false false false false true true true)
               (String.String
                  (Ascii.Ascii false false true false true true false true)
                  (String.String
                     (Ascii.Ascii true false false false true true false true)
                     String.EmptyString)))))
      (Ast.tProd BasicAst.nAnon (Ast.tRel 0)
         (Ast.tSort
            {|
            Universes.Universe.t_set := {|
                                        Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil)%list;
                                        Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
            Universes.Universe.t_ne := eq_refl |}))
      (Ast.tLambda BasicAst.nAnon
         (Ast.tApp
            (Ast.tInd
               {|
               BasicAst.inductive_mind := (BasicAst.MPfile
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false false false true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                              :: String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                          String.String
                                            (Ascii.Ascii false false true
                                               true false true true false)
                                            (String.String
                                               (Ascii.Ascii true false false
                                                 true false true true false)
                                               (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
               BasicAst.inductive_ind := 0 |} nil) 
            (Ast.tRel 1 :: nil))
         (Ast.tApp
            (Ast.tInd
               {|
               BasicAst.inductive_mind := (BasicAst.MPfile
                                             (String.String
                                                (Ascii.Ascii true true false
                                                 false true true true false)
                                                (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                              :: String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString)))))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                                 :: nil)%list,
                                          String.String
                                            (Ascii.Ascii false false true
                                               true false true true false)
                                            (String.String
                                               (Ascii.Ascii true false false
                                                 true false true true false)
                                               (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))));
               BasicAst.inductive_ind := 0 |} nil)
            (Ast.tRel 2 :: Ast.tRel 1 :: Ast.tRel 0 :: nil)))))
Derived listᵗ=listᴬᴬ, listᴬᴱ, listᴱᴬ, and listᴱ=listᴱᴱ.
Inductive listᵗ (A : Type) (Aᵗ : A -> Type) : list A -> Type :=
    nilᵗ : listᵗ A Aᵗ nil
  | consᵗ : forall H : A,
            Aᵗ H -> forall H0 : list A, listᵗ A Aᵗ H0 -> listᵗ A Aᵗ (H :: H0)

Arguments listᵗ _%type_scope _%function_scope _%list_scope
Arguments nilᵗ _%type_scope _%function_scope
Arguments consᵗ _%type_scope _%function_scope _ _ _%list_scope
listᴬᴱ = 
fun (A : Type) (Aᴱ : A -> Type) (H : list A) => listᴱ A Aᴱ H
     : forall A : Type, (A -> Type) -> list A -> Type

Arguments listᴬᴱ _%type_scope _%function_scope _%list_scope
listᴱᴬ = 
fun (A : Type) (Aᴱ : A -> Type) (H : list A) => listᵗ A Aᴱ H
     : forall A : Type, (A -> Type) -> list A -> Type

Arguments listᴱᴬ _%type_scope _%function_scope _%list_scope
Inductive listᴱ (A : Type) (Aᴱ : A -> Type) : list A -> Type :=
    consᴱ0 : forall (H : A) (H0 : list A), Aᴱ H -> listᴱ A Aᴱ (H :: H0)
  | consᴱ1 : forall (H : A) (H0 : list A),
             listᴱ A Aᴱ H0 -> listᴱ A Aᴱ (H :: H0)

Arguments listᴱ _%type_scope _%function_scope _%list_scope
Arguments consᴱ0 _%type_scope _%function_scope _ _%list_scope
Arguments consᴱ1 _%type_scope _%function_scope _ _%list_scope
File "./showcase.v", line 65, characters 0-46:
Warning: Notation "_ <-> _" was already used in scope type_scope.
[notation-overridden,parsing]
(String.String (Ascii.Ascii false true true true true true true false)
   (String.String (Ascii.Ascii false true true true true true true false)
      (String.String (Ascii.Ascii false true true true true true true false)
         (String.String
            (Ascii.Ascii false true true true true true true false)
            (String.String
               (Ascii.Ascii false true true true true true true false)
               (String.String
                  (Ascii.Ascii false true true true true true true false)
                  (String.String
                     (Ascii.Ascii false true true true true true true false)
                     (String.String
                        (Ascii.Ascii false true true true true true true
                           false)
                        (String.String
                           (Ascii.Ascii false true true true true true true
                              false)
                           (String.String
                              (Ascii.Ascii false true true true true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false true true true true true
                                    true false)
                                 (String.String
                                    (Ascii.Ascii false true true true true
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii false true true true true
                                          true true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true true true true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true true true true false)
                                                (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 String.EmptyString))))))))))))))))))
(String.String (Ascii.Ascii false false true true false false true false)
   (String.String (Ascii.Ascii true true true true false true true false)
      (String.String (Ascii.Ascii true true true true false true true false)
         (String.String
            (Ascii.Ascii true true false true false true true false)
            (String.String
               (Ascii.Ascii true false false true false true true false)
               (String.String
                  (Ascii.Ascii false true true true false true true false)
                  (String.String
                     (Ascii.Ascii true true true false false true true false)
                     (String.String
                        (Ascii.Ascii false false false false false true false
                           false)
                        (String.String
                           (Ascii.Ascii true false true false true true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false false false false false
                                    true false false)
                                 (String.String
                                    (Ascii.Ascii true true false false false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true true true true false
                                          true true false)
                                       (String.String
                                          (Ascii.Ascii true false false false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true false true false false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 true false false true false)
                                                (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))))))))))))
Complete Identifier: Coq.Init.Datatypes.prod
Short Identifier: prod
(String.String (Ascii.Ascii false false true false true false true false)
   (String.String (Ascii.Ascii false true false false true true true false)
      (String.String
         (Ascii.Ascii true false false false false true true false)
         (String.String
            (Ascii.Ascii false true true true false true true false)
            (String.String
               (Ascii.Ascii true true false false true true true false)
               (String.String
                  (Ascii.Ascii false false true true false true true false)
                  (String.String
                     (Ascii.Ascii true false false false false true true
                        false)
                     (String.String
                        (Ascii.Ascii false false true false true true true
                           false)
                        (String.String
                           (Ascii.Ascii true false true false false true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false false true
                                 false false)
                              (String.String
                                 (Ascii.Ascii true true false false false
                                    false true false)
                                 (String.String
                                    (Ascii.Ascii true true true true false
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii true false false false
                                          true true true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             false true false false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                true false false true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))))))))))))
(BasicAst.IndRef
   {|
   BasicAst.inductive_mind := (BasicAst.MPfile
                                 (String.String
                                    (Ascii.Ascii false false true false false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true false false false
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii false false true false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                  :: String.String
                                       (Ascii.Ascii true false false true
                                          false false true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             false true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                true false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                String.EmptyString)))
                                     :: String.String
                                          (Ascii.Ascii true true false false
                                             false false true false)
                                          (String.String
                                             (Ascii.Ascii true true true true
                                                false true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false true true true false)
                                                String.EmptyString)) :: nil)%list,
                              String.String
                                (Ascii.Ascii false false false false true
                                   true true false)
                                (String.String
                                   (Ascii.Ascii false true false false true
                                      true true false)
                                   (String.String
                                      (Ascii.Ascii true true true true false
                                         true true false)
                                      (String.String
                                         (Ascii.Ascii false false true false
                                            false true true false)
                                         String.EmptyString))));
   BasicAst.inductive_ind := 0 |})
{|
Ast.ind_finite := BasicAst.Finite;
Ast.ind_npars := 4;
Ast.ind_params := ({|
                   Ast.decl_name := BasicAst.nNamed
                                      (String.String
                                         (Ascii.Ascii false true false false
                                            false false true false)
                                         (String.String
                                            (Ascii.Ascii true false false
                                               false false true true true)
                                            (String.String
                                               (Ascii.Ascii true false true
                                                 false true true false true)
                                               (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString))));
                   Ast.decl_body := None;
                   Ast.decl_type := Ast.tProd BasicAst.nAnon 
                                      (Ast.tRel 0)
                                      (Ast.tSort
                                         {|
                                         Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))),
                                                 false)) |};
                                         Universes.Universe.t_ne := eq_refl |}) |}
                   :: {|
                      Ast.decl_name := BasicAst.nNamed
                                         (String.String
                                            (Ascii.Ascii false true false
                                               false false false true false)
                                            String.EmptyString);
                      Ast.decl_body := None;
                      Ast.decl_type := Ast.tSort
                                         {|
                                         Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))))))))),
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
                                         Universes.Universe.t_ne := eq_refl |} |}
                      :: {|
                         Ast.decl_name := BasicAst.nNamed
                                            (String.String
                                               (Ascii.Ascii true false false
                                                 false false false true false)
                                               (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString))));
                         Ast.decl_body := None;
                         Ast.decl_type := Ast.tProd BasicAst.nAnon
                                            (Ast.tRel 0)
                                            (Ast.tSort
                                               {|
                                               Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))))),
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))))))),
                                                 false)) |};
                                               Universes.Universe.t_ne := eq_refl |}) |}
                         :: {|
                            Ast.decl_name := BasicAst.nNamed
                                               (String.String
                                                 (Ascii.Ascii true false
                                                 false false false false true
                                                 false) String.EmptyString);
                            Ast.decl_body := None;
                            Ast.decl_type := Ast.tSort
                                               {|
                                               Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))),
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))))),
                                                 false)) |};
                                               Universes.Universe.t_ne := eq_refl |} |}
                            :: nil)%list;
Ast.ind_bodies := {|
                  Ast.ind_name := String.String
                                    (Ascii.Ascii false false false false true
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii false true false false
                                          true true true false)
                                       (String.String
                                          (Ascii.Ascii true true true true
                                             false true true false)
                                          (String.String
                                             (Ascii.Ascii false false true
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false false true true true)
                                                (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString))))));
                  Ast.ind_type := Ast.tProd
                                    (BasicAst.nNamed
                                       (String.String
                                          (Ascii.Ascii true false false false
                                             false false true false)
                                          String.EmptyString))
                                    (Ast.tSort
                                       {|
                                       Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
                                       Universes.Universe.t_ne := eq_refl |})
                                    (Ast.tProd
                                       (BasicAst.nNamed
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false false true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false false true true true)
                                                (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString)))))
                                       (Ast.tProd BasicAst.nAnon 
                                          (Ast.tRel 0)
                                          (Ast.tSort
                                             {|
                                             Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false)) |};
                                             Universes.Universe.t_ne := eq_refl |}))
                                       (Ast.tProd
                                          (BasicAst.nNamed
                                             (String.String
                                                (Ascii.Ascii false true false
                                                 false false false true false)
                                                String.EmptyString))
                                          (Ast.tSort
                                             {|
                                             Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false)) |};
                                             Universes.Universe.t_ne := eq_refl |})
                                          (Ast.tProd
                                             (BasicAst.nNamed
                                                (String.String
                                                 (Ascii.Ascii false true
                                                 false false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString)))))
                                             (Ast.tProd BasicAst.nAnon
                                                (Ast.tRel 0)
                                                (Ast.tSort
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String ... ...))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String ... ...))))))))))),
                                                 false)) |};
                                                 Universes.Universe.t_ne := eq_refl |}))
                                             (Ast.tProd BasicAst.nAnon
                                                (Ast.tApp
                                                 (Ast.tInd
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 nil)
                                                 (Ast.tRel 3
                                                 :: 
                                                 Ast.tRel 1 :: nil))
                                                (Ast.tSort
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String ... ...))))))))))),
                                                 false)
                                                 :: Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String (...) (...))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.add_ok
                                                 (s:=(Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String (...) (...))))))))))),
                                                 false) :: nil)%list)
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String ... ...))))))))))),
                                                 false))
                                                 (Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String ... ...)))))))))),
                                                 false))) |};
                                                 Universes.Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false))
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))),
                                                 false)) |};
                                                 Universes.Universe.t_ne := eq_refl |} |})))));
                  Ast.ind_kelim := Universes.InType;
                  Ast.ind_ctors := (String.String
                                      (Ascii.Ascii false false false false
                                         true true true false)
                                      (String.String
                                         (Ascii.Ascii true false false false
                                            false true true false)
                                         (String.String
                                            (Ascii.Ascii true false false
                                               true false true true false)
                                            (String.String
                                               (Ascii.Ascii false true false
                                                 false true true true false)
                                               (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString)))))),
                                   Ast.tProd
                                     (BasicAst.nNamed
                                        (String.String
                                           (Ascii.Ascii true false false
                                              false false false true false)
                                           String.EmptyString))
                                     (Ast.tSort
                                        {|
                                        Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))))),
                                                 false)) |};
                                        Universes.Universe.t_ne := eq_refl |})
                                     (Ast.tProd
                                        (BasicAst.nNamed
                                           (String.String
                                              (Ascii.Ascii true false false
                                                 false false false true false)
                                              (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString)))))
                                        (Ast.tProd BasicAst.nAnon
                                           (Ast.tRel 0)
                                           (Ast.tSort
                                              {|
                                              Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false)) |};
                                              Universes.Universe.t_ne := eq_refl |}))
                                        (Ast.tProd
                                           (BasicAst.nNamed
                                              (String.String
                                                 (Ascii.Ascii false true
                                                 false false false false true
                                                 false) String.EmptyString))
                                           (Ast.tSort
                                              {|
                                              Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false)) |};
                                              Universes.Universe.t_ne := eq_refl |})
                                           (Ast.tProd
                                              (BasicAst.nNamed
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString)))))
                                              (Ast.tProd BasicAst.nAnon
                                                 (Ast.tRel 0)
                                                 (Ast.tSort
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String ... ...)))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String ... ...)))))))))),
                                                 false)) |};
                                                 Universes.Universe.t_ne := eq_refl |}))
                                              (Ast.tProd BasicAst.nAnon
                                                 (Ast.tRel 3)
                                                 (Ast.tProd BasicAst.nAnon
                                                 (Ast.tApp 
                                                 (Ast.tRel 3)
                                                 (Ast.tRel 0 :: nil))
                                                 (Ast.tProd BasicAst.nAnon
                                                 (Ast.tRel 3)
                                                 (Ast.tProd BasicAst.nAnon
                                                 (Ast.tApp 
                                                 (Ast.tRel 3)
                                                 (Ast.tRel 0 :: nil))
                                                 (Ast.tApp 
                                                 (Ast.tRel 8)
                                                 (Ast.tRel 7
                                                 :: 
                                                 Ast.tRel 6
                                                 :: 
                                                 Ast.tRel 5
                                                 :: 
                                                 Ast.tRel 4
                                                 :: 
                                                 Ast.tApp
                                                 (Ast.tConstruct
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String ...
                                                 String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String 
                                                 (...) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 0 nil)
                                                 (Ast.tRel 7
                                                 :: 
                                                 Ast.tRel 5
                                                 :: 
                                                 Ast.tRel 3
                                                 :: 
                                                 Ast.tRel 1 :: nil) :: nil))))))))),
                                   8) :: nil;
                  Ast.ind_projs := nil |} :: nil;
Ast.ind_universes := Universes.Monomorphic_ctx
                       ({|
                        Universes.LevelSet.this := (Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String ... ...)))))))))))))))))))
                                                 :: Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String (...) (...)))))))))))))))))))
                                                 :: nil)%list;
                        Universes.LevelSet.is_ok := Universes.LevelSet.Raw.add_ok
                                                 (s:=(Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String (...) (...)))))))))))))))))))
                                                 :: nil)%list)
                                                 (Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String ... ...))))))))))))))))))))
                                                 (Universes.LevelSet.Raw.add_ok
                                                 (s:=nil)
                                                 (Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String ... ...)))))))))))))))))))
                                                 Universes.LevelSet.Raw.empty_ok) |},
                       {|
                       Universes.ConstraintSet.this := nil;
                       Universes.ConstraintSet.is_ok := Universes.ConstraintSet.Raw.empty_ok |});
Ast.ind_variance := None |}
Coq.Init.Datatypes.prod has been translated.
(String.String (Ascii.Ascii false true true true true true true false)
   (String.String (Ascii.Ascii false true true true true true true false)
      (String.String (Ascii.Ascii false true true true true true true false)
         (String.String
            (Ascii.Ascii false true true true true true true false)
            (String.String
               (Ascii.Ascii false true true true true true true false)
               (String.String
                  (Ascii.Ascii false true true true true true true false)
                  (String.String
                     (Ascii.Ascii false true true true true true true false)
                     (String.String
                        (Ascii.Ascii false true true true true true true
                           false)
                        (String.String
                           (Ascii.Ascii false true true true true true true
                              false)
                           (String.String
                              (Ascii.Ascii false true true true true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false true true true true true
                                    true false)
                                 (String.String
                                    (Ascii.Ascii false true true true true
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii false true true true true
                                          true true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true true true true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true true true true false)
                                                (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 String.EmptyString))))))))))))))))))
(String.String (Ascii.Ascii false false true true false false true false)
   (String.String (Ascii.Ascii true true true true false true true false)
      (String.String (Ascii.Ascii true true true true false true true false)
         (String.String
            (Ascii.Ascii true true false true false true true false)
            (String.String
               (Ascii.Ascii true false false true false true true false)
               (String.String
                  (Ascii.Ascii false true true true false true true false)
                  (String.String
                     (Ascii.Ascii true true true false false true true false)
                     (String.String
                        (Ascii.Ascii false false false false false true false
                           false)
                        (String.String
                           (Ascii.Ascii true false true false true true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false false false false false
                                    true false false)
                                 (String.String
                                    (Ascii.Ascii true true false false false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true true true true false
                                          true true false)
                                       (String.String
                                          (Ascii.Ascii true false false false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true false true false false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 true false false true false)
                                                (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))))))))))))
Complete Identifier: Coq.Init.Datatypes.prod
Short Identifier: prod
(String.String (Ascii.Ascii false false true false true false true false)
   (String.String (Ascii.Ascii false true false false true true true false)
      (String.String
         (Ascii.Ascii true false false false false true true false)
         (String.String
            (Ascii.Ascii false true true true false true true false)
            (String.String
               (Ascii.Ascii true true false false true true true false)
               (String.String
                  (Ascii.Ascii false false true true false true true false)
                  (String.String
                     (Ascii.Ascii true false false false false true true
                        false)
                     (String.String
                        (Ascii.Ascii false false true false true true true
                           false)
                        (String.String
                           (Ascii.Ascii true false true false false true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false false true
                                 false false)
                              (String.String
                                 (Ascii.Ascii true true false false false
                                    false true false)
                                 (String.String
                                    (Ascii.Ascii true true true true false
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii true false false false
                                          true true true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             false true false false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                true false false true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))))))))))))
(BasicAst.IndRef
   {|
   BasicAst.inductive_mind := (BasicAst.MPfile
                                 (String.String
                                    (Ascii.Ascii false false true false false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true false false false
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii false false true false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                  :: String.String
                                       (Ascii.Ascii true false false true
                                          false false true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             false true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                true false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                String.EmptyString)))
                                     :: String.String
                                          (Ascii.Ascii true true false false
                                             false false true false)
                                          (String.String
                                             (Ascii.Ascii true true true true
                                                false true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false true true true false)
                                                String.EmptyString)) :: nil)%list,
                              String.String
                                (Ascii.Ascii false false false false true
                                   true true false)
                                (String.String
                                   (Ascii.Ascii false true false false true
                                      true true false)
                                   (String.String
                                      (Ascii.Ascii true true true true false
                                         true true false)
                                      (String.String
                                         (Ascii.Ascii false false true false
                                            false true true false)
                                         String.EmptyString))));
   BasicAst.inductive_ind := 0 |})
{|
Ast.ind_finite := BasicAst.Finite;
Ast.ind_npars := 4;
Ast.ind_params := ({|
                   Ast.decl_name := BasicAst.nNamed
                                      (String.String
                                         (Ascii.Ascii false true false false
                                            false false true false)
                                         (String.String
                                            (Ascii.Ascii true false false
                                               false false true true true)
                                            (String.String
                                               (Ascii.Ascii false false true
                                                 false true true false true)
                                               (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString))));
                   Ast.decl_body := None;
                   Ast.decl_type := Ast.tProd BasicAst.nAnon 
                                      (Ast.tRel 0)
                                      (Ast.tSort
                                         {|
                                         Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))),
                                                 false)) |};
                                         Universes.Universe.t_ne := eq_refl |}) |}
                   :: {|
                      Ast.decl_name := BasicAst.nNamed
                                         (String.String
                                            (Ascii.Ascii false true false
                                               false false false true false)
                                            String.EmptyString);
                      Ast.decl_body := None;
                      Ast.decl_type := Ast.tSort
                                         {|
                                         Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))))))))),
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
                                         Universes.Universe.t_ne := eq_refl |} |}
                      :: {|
                         Ast.decl_name := BasicAst.nNamed
                                            (String.String
                                               (Ascii.Ascii true false false
                                                 false false false true false)
                                               (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString))));
                         Ast.decl_body := None;
                         Ast.decl_type := Ast.tProd BasicAst.nAnon
                                            (Ast.tRel 0)
                                            (Ast.tSort
                                               {|
                                               Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))))),
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))))))),
                                                 false)) |};
                                               Universes.Universe.t_ne := eq_refl |}) |}
                         :: {|
                            Ast.decl_name := BasicAst.nNamed
                                               (String.String
                                                 (Ascii.Ascii true false
                                                 false false false false true
                                                 false) String.EmptyString);
                            Ast.decl_body := None;
                            Ast.decl_type := Ast.tSort
                                               {|
                                               Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))),
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))))),
                                                 false)) |};
                                               Universes.Universe.t_ne := eq_refl |} |}
                            :: nil)%list;
Ast.ind_bodies := {|
                  Ast.ind_name := String.String
                                    (Ascii.Ascii false false false false true
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii false true false false
                                          true true true false)
                                       (String.String
                                          (Ascii.Ascii true true true true
                                             false true true false)
                                          (String.String
                                             (Ascii.Ascii false false true
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false false true true true)
                                                (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString))))));
                  Ast.ind_type := Ast.tProd
                                    (BasicAst.nNamed
                                       (String.String
                                          (Ascii.Ascii true false false false
                                             false false true false)
                                          String.EmptyString))
                                    (Ast.tSort
                                       {|
                                       Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
                                       Universes.Universe.t_ne := eq_refl |})
                                    (Ast.tProd
                                       (BasicAst.nNamed
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false false true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false false true true true)
                                                (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))
                                       (Ast.tProd BasicAst.nAnon 
                                          (Ast.tRel 0)
                                          (Ast.tSort
                                             {|
                                             Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false)) |};
                                             Universes.Universe.t_ne := eq_refl |}))
                                       (Ast.tProd
                                          (BasicAst.nNamed
                                             (String.String
                                                (Ascii.Ascii false true false
                                                 false false false true false)
                                                String.EmptyString))
                                          (Ast.tSort
                                             {|
                                             Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false)) |};
                                             Universes.Universe.t_ne := eq_refl |})
                                          (Ast.tProd
                                             (BasicAst.nNamed
                                                (String.String
                                                 (Ascii.Ascii false true
                                                 false false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))
                                             (Ast.tProd BasicAst.nAnon
                                                (Ast.tRel 0)
                                                (Ast.tSort
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String ... ...))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String ... ...))))))))))),
                                                 false)) |};
                                                 Universes.Universe.t_ne := eq_refl |}))
                                             (Ast.tProd BasicAst.nAnon
                                                (Ast.tApp
                                                 (Ast.tInd
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 nil)
                                                 (Ast.tRel 3
                                                 :: 
                                                 Ast.tRel 1 :: nil))
                                                (Ast.tSort
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String ... ...))))))))))),
                                                 false)
                                                 :: Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String (...) (...))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.add_ok
                                                 (s:=(Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String (...) (...))))))))))),
                                                 false) :: nil)%list)
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String ... ...))))))))))),
                                                 false))
                                                 (Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String ... ...)))))))))),
                                                 false))) |};
                                                 Universes.Universe.t_ne := Universes.Universe.add_obligation_1
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false))
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))),
                                                 false)) |};
                                                 Universes.Universe.t_ne := eq_refl |} |})))));
                  Ast.ind_kelim := Universes.InType;
                  Ast.ind_ctors := (String.String
                                      (Ascii.Ascii false false false false
                                         true true true false)
                                      (String.String
                                         (Ascii.Ascii true false false false
                                            false true true false)
                                         (String.String
                                            (Ascii.Ascii true false false
                                               true false true true false)
                                            (String.String
                                               (Ascii.Ascii false true false
                                                 false true true true false)
                                               (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true false
                                                 false) String.EmptyString))))))),
                                   Ast.tProd
                                     (BasicAst.nNamed
                                        (String.String
                                           (Ascii.Ascii true false false
                                              false false false true false)
                                           String.EmptyString))
                                     (Ast.tSort
                                        {|
                                        Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))))),
                                                 false)) |};
                                        Universes.Universe.t_ne := eq_refl |})
                                     (Ast.tProd
                                        (BasicAst.nNamed
                                           (String.String
                                              (Ascii.Ascii true false false
                                                 false false false true false)
                                              (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))
                                        (Ast.tProd BasicAst.nAnon
                                           (Ast.tRel 0)
                                           (Ast.tSort
                                              {|
                                              Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false)) |};
                                              Universes.Universe.t_ne := eq_refl |}))
                                        (Ast.tProd
                                           (BasicAst.nNamed
                                              (String.String
                                                 (Ascii.Ascii false true
                                                 false false false false true
                                                 false) String.EmptyString))
                                           (Ast.tSort
                                              {|
                                              Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false)) |};
                                              Universes.Universe.t_ne := eq_refl |})
                                           (Ast.tProd
                                              (BasicAst.nNamed
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))
                                              (Ast.tProd BasicAst.nAnon
                                                 (Ast.tRel 0)
                                                 (Ast.tSort
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String ... ...)))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String ... ...)))))))))),
                                                 false)) |};
                                                 Universes.Universe.t_ne := eq_refl |}))
                                              (Ast.tProd BasicAst.nAnon
                                                 (Ast.tRel 3)
                                                 (Ast.tProd BasicAst.nAnon
                                                 (Ast.tRel 2)
                                                 (Ast.tProd BasicAst.nAnon
                                                 (Ast.tApp 
                                                 (Ast.tRel 4)
                                                 (Ast.tRel 1 :: nil))
                                                 (Ast.tApp 
                                                 (Ast.tRel 7)
                                                 (Ast.tRel 6
                                                 :: 
                                                 Ast.tRel 5
                                                 :: 
                                                 Ast.tRel 4
                                                 :: 
                                                 Ast.tRel 3
                                                 :: 
                                                 Ast.tApp
                                                 (Ast.tConstruct
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...)))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 0 nil)
                                                 (Ast.tRel 6
                                                 :: 
                                                 Ast.tRel 4
                                                 :: 
                                                 Ast.tRel 2
                                                 :: 
                                                 Ast.tRel 1 :: nil) :: nil)))))))),
                                   3)
                                   :: (String.String
                                         (Ascii.Ascii false false false false
                                            true true true false)
                                         (String.String
                                            (Ascii.Ascii true false false
                                               false false true true false)
                                            (String.String
                                               (Ascii.Ascii true false false
                                                 true false true true false)
                                               (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 false) String.EmptyString))))))),
                                      Ast.tProd
                                        (BasicAst.nNamed
                                           (String.String
                                              (Ascii.Ascii true false false
                                                 false false false true false)
                                              String.EmptyString))
                                        (Ast.tSort
                                           {|
                                           Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))))))),
                                                 false)) |};
                                           Universes.Universe.t_ne := eq_refl |})
                                        (Ast.tProd
                                           (BasicAst.nNamed
                                              (String.String
                                                 (Ascii.Ascii true false
                                                 false false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))
                                           (Ast.tProd BasicAst.nAnon
                                              (Ast.tRel 0)
                                              (Ast.tSort
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String (...) (...)))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String (...) (...)))))))))))),
                                                 false)) |};
                                                 Universes.Universe.t_ne := eq_refl |}))
                                           (Ast.tProd
                                              (BasicAst.nNamed
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false false false true
                                                 false) String.EmptyString))
                                              (Ast.tSort
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String (...) (...)))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String (...) (...)))))))))))),
                                                 false)) |};
                                                 Universes.Universe.t_ne := eq_refl |})
                                              (Ast.tProd
                                                 (BasicAst.nNamed
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))
                                                 (Ast.tProd BasicAst.nAnon
                                                 (Ast.tRel 0)
                                                 (Ast.tSort
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String (...) (...)))))))))),
                                                 false)) |};
                                                 Universes.Universe.t_ne := eq_refl |}))
                                                 (Ast.tProd BasicAst.nAnon
                                                 (Ast.tRel 3)
                                                 (Ast.tProd BasicAst.nAnon
                                                 (Ast.tRel 2)
                                                 (Ast.tProd BasicAst.nAnon
                                                 (Ast.tApp 
                                                 (Ast.tRel 2)
                                                 (Ast.tRel 0 :: nil))
                                                 (Ast.tApp 
                                                 (Ast.tRel 7)
                                                 (Ast.tRel 6
                                                 :: 
                                                 Ast.tRel 5
                                                 :: 
                                                 Ast.tRel 4
                                                 :: 
                                                 Ast.tRel 3
                                                 :: 
                                                 Ast.tApp
                                                 (Ast.tConstruct
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String 
                                                 (...) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 0 nil)
                                                 (Ast.tRel 6
                                                 :: 
                                                 Ast.tRel 4
                                                 :: 
                                                 Ast.tRel 2
                                                 :: 
                                                 Ast.tRel 1 :: nil) :: nil)))))))),
                                      3) :: nil;
                  Ast.ind_projs := nil |} :: nil;
Ast.ind_universes := Universes.Monomorphic_ctx
                       ({|
                        Universes.LevelSet.this := (Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String ... ...)))))))))))))))))))
                                                 :: Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String (...) (...)))))))))))))))))))
                                                 :: nil)%list;
                        Universes.LevelSet.is_ok := Universes.LevelSet.Raw.add_ok
                                                 (s:=(Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String (...) (...)))))))))))))))))))
                                                 :: nil)%list)
                                                 (Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String ... ...))))))))))))))))))))
                                                 (Universes.LevelSet.Raw.add_ok
                                                 (s:=nil)
                                                 (Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String ... ...)))))))))))))))))))
                                                 Universes.LevelSet.Raw.empty_ok) |},
                       {|
                       Universes.ConstraintSet.this := nil;
                       Universes.ConstraintSet.is_ok := Universes.ConstraintSet.Raw.empty_ok |});
Ast.ind_variance := None |}
Coq.Init.Datatypes.prod has been translated.
(Ast.tLambda
   (BasicAst.nNamed
      (String.String
         (Ascii.Ascii true false false false false false true false)
         String.EmptyString))
   (Ast.tSort
      {|
      Universes.Universe.t_set := {|
                                  Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))))),
                                                 false) :: nil)%list;
                                  Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))))),
                                                 false)) |};
      Universes.Universe.t_ne := eq_refl |})
   (Ast.tLambda
      (BasicAst.nNamed
         (String.String
            (Ascii.Ascii true false false false false false true false)
            (String.String
               (Ascii.Ascii true false false false false true true true)
               (String.String
                  (Ascii.Ascii false false true false true true false true)
                  (String.String
                     (Ascii.Ascii true false false false true true false true)
                     String.EmptyString)))))
      (Ast.tProd BasicAst.nAnon (Ast.tRel 0)
         (Ast.tSort
            {|
            Universes.Universe.t_set := {|
                                        Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil)%list;
                                        Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
            Universes.Universe.t_ne := eq_refl |}))
      (Ast.tLambda
         (BasicAst.nNamed
            (String.String
               (Ascii.Ascii false true false false false false true false)
               String.EmptyString))
         (Ast.tSort
            {|
            Universes.Universe.t_set := {|
                                        Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil)%list;
                                        Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
            Universes.Universe.t_ne := eq_refl |})
         (Ast.tLambda
            (BasicAst.nNamed
               (String.String
                  (Ascii.Ascii false true false false false false true false)
                  (String.String
                     (Ascii.Ascii true false false false false true true true)
                     (String.String
                        (Ascii.Ascii false false true false true true false
                           true)
                        (String.String
                           (Ascii.Ascii true false false false true true
                              false true) String.EmptyString)))))
            (Ast.tProd BasicAst.nAnon (Ast.tRel 0)
               (Ast.tSort
                  {|
                  Universes.Universe.t_set := {|
                                              Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false) :: nil)%list;
                                              Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false)) |};
                  Universes.Universe.t_ne := eq_refl |}))
            (Ast.tLambda BasicAst.nAnon
               (Ast.tApp
                  (Ast.tInd
                     {|
                     BasicAst.inductive_mind := (BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false true true
                                                 false) String.EmptyString))));
                     BasicAst.inductive_ind := 0 |} nil)
                  (Ast.tRel 3 :: Ast.tRel 1 :: nil))
               (Ast.tApp
                  (Ast.tInd
                     {|
                     BasicAst.inductive_mind := (BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 true false true true false)
                                                 String.EmptyString)));
                     BasicAst.inductive_ind := 0 |} nil)
                  (Ast.tApp
                     (Ast.tInd
                        {|
                        BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String ...
                                                 String.EmptyString)))))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString)))))));
                        BasicAst.inductive_ind := 0 |} nil)
                     (Ast.tRel 4
                      :: Ast.tRel 3
                         :: Ast.tRel 2
                            :: Ast.tLambda
                                 (BasicAst.nNamed
                                    (String.String
                                       (Ascii.Ascii false false false true
                                          true true true false)
                                       String.EmptyString)) 
                                 (Ast.tRel 2)
                                 (Ast.tInd
                                    {|
                                    BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 String.EmptyString))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString))));
                                    BasicAst.inductive_ind := 0 |} nil)
                               :: Ast.tRel 0 :: nil)
                   :: Ast.tApp
                        (Ast.tInd
                           {|
                           BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String (...) (...)))))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true false true)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true false false true)
                                                 String.EmptyString)))))));
                           BasicAst.inductive_ind := 0 |} nil)
                        (Ast.tRel 4
                         :: Ast.tLambda
                              (BasicAst.nNamed
                                 (String.String
                                    (Ascii.Ascii false false false true true
                                       true true false) String.EmptyString))
                              (Ast.tRel 4)
                              (Ast.tInd
                                 {|
                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 String.EmptyString))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString))));
                                 BasicAst.inductive_ind := 0 |} nil)
                            :: Ast.tRel 2 :: Ast.tRel 1 :: Ast.tRel 0 :: nil)
                      :: nil)))))))
(Ast.tLambda
   (BasicAst.nNamed
      (String.String
         (Ascii.Ascii true false false false false false true false)
         String.EmptyString))
   (Ast.tSort
      {|
      Universes.Universe.t_set := {|
                                  Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))))),
                                                 false) :: nil)%list;
                                  Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))))),
                                                 false)) |};
      Universes.Universe.t_ne := eq_refl |})
   (Ast.tLambda
      (BasicAst.nNamed
         (String.String
            (Ascii.Ascii true false false false false false true false)
            (String.String
               (Ascii.Ascii true false false false false true true true)
               (String.String
                  (Ascii.Ascii false false true false true true false true)
                  (String.String
                     (Ascii.Ascii true false false false true true false true)
                     String.EmptyString)))))
      (Ast.tProd BasicAst.nAnon (Ast.tRel 0)
         (Ast.tSort
            {|
            Universes.Universe.t_set := {|
                                        Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil)%list;
                                        Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
            Universes.Universe.t_ne := eq_refl |}))
      (Ast.tLambda
         (BasicAst.nNamed
            (String.String
               (Ascii.Ascii false true false false false false true false)
               String.EmptyString))
         (Ast.tSort
            {|
            Universes.Universe.t_set := {|
                                        Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil)%list;
                                        Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
            Universes.Universe.t_ne := eq_refl |})
         (Ast.tLambda
            (BasicAst.nNamed
               (String.String
                  (Ascii.Ascii false true false false false false true false)
                  (String.String
                     (Ascii.Ascii true false false false false true true true)
                     (String.String
                        (Ascii.Ascii false false true false true true false
                           true)
                        (String.String
                           (Ascii.Ascii true false false false true true
                              false true) String.EmptyString)))))
            (Ast.tProd BasicAst.nAnon (Ast.tRel 0)
               (Ast.tSort
                  {|
                  Universes.Universe.t_set := {|
                                              Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false) :: nil)%list;
                                              Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))))))),
                                                 false)) |};
                  Universes.Universe.t_ne := eq_refl |}))
            (Ast.tLambda BasicAst.nAnon
               (Ast.tApp
                  (Ast.tInd
                     {|
                     BasicAst.inductive_mind := (BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false true true
                                                 false) String.EmptyString))));
                     BasicAst.inductive_ind := 0 |} nil)
                  (Ast.tRel 3 :: Ast.tRel 1 :: nil))
               (Ast.tApp
                  (Ast.tInd
                     {|
                     BasicAst.inductive_mind := (BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false true true
                                                 false) String.EmptyString))));
                     BasicAst.inductive_ind := 0 |} nil)
                  (Ast.tApp
                     (Ast.tInd
                        {|
                        BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String ...
                                                 String.EmptyString)))))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))));
                        BasicAst.inductive_ind := 0 |} nil)
                     (Ast.tRel 4
                      :: Ast.tRel 3
                         :: Ast.tRel 2
                            :: Ast.tLambda
                                 (BasicAst.nNamed
                                    (String.String
                                       (Ascii.Ascii false false false true
                                          true true true false)
                                       String.EmptyString)) 
                                 (Ast.tRel 2)
                                 (Ast.tInd
                                    {|
                                    BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 String.EmptyString))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false true true
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))));
                                    BasicAst.inductive_ind := 0 |} nil)
                               :: Ast.tRel 0 :: nil)
                   :: Ast.tApp
                        (Ast.tInd
                           {|
                           BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String (...) (...)))))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))));
                           BasicAst.inductive_ind := 0 |} nil)
                        (Ast.tRel 4
                         :: Ast.tLambda
                              (BasicAst.nNamed
                                 (String.String
                                    (Ascii.Ascii false false false true true
                                       true true false) String.EmptyString))
                              (Ast.tRel 4)
                              (Ast.tInd
                                 {|
                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 String.EmptyString))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false
                                                 false true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString)))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false true true
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))));
                                 BasicAst.inductive_ind := 0 |} nil)
                            :: Ast.tRel 2 :: Ast.tRel 1 :: Ast.tRel 0 :: nil)
                      :: nil)))))))
Derived prodᵗ=prodᴬᴬ, prodᴬᴱ, prodᴱᴬ, and prodᴱ=prodᴱᴱ.
Inductive
prodᵗ (A : Type) (Aᵗ : A -> Type) (B : Type) (Bᵗ : B -> Type)
  : A * B -> Type :=
    pairᵗ : forall H : A,
            Aᵗ H -> forall H0 : B, Bᵗ H0 -> prodᵗ A Aᵗ B Bᵗ (H, H0)

Arguments prodᵗ _%type_scope _%function_scope _%type_scope _%function_scope
Arguments pairᵗ _%type_scope _%function_scope _%type_scope _%function_scope
prodᴬᴱ = 
fun (A : Type) (Aᴱ : A -> Type) (B : Type) (Bᴱ : B -> Type) (H : A * B) =>
prodᴱ A Aᴱ B (fun _ : B => False) H * prodᴱ A (fun _ : A => False) B Bᴱ H
     : forall A : Type,
       (A -> Type) -> forall B : Type, (B -> Type) -> A * B -> Type

Arguments prodᴬᴱ _%type_scope _%function_scope _%type_scope _%function_scope
prodᴱᴬ = 
fun (A : Type) (Aᴱ : A -> Type) (B : Type) (Bᴱ : B -> Type) (H : A * B) =>
prodᵗ A Aᴱ B (fun _ : B => True) H + prodᵗ A (fun _ : A => True) B Bᴱ H
     : forall A : Type,
       (A -> Type) -> forall B : Type, (B -> Type) -> A * B -> Type

Arguments prodᴱᴬ _%type_scope _%function_scope _%type_scope _%function_scope
Inductive
prodᴱ (A : Type) (Aᴱ : A -> Type) (B : Type) (Bᴱ : B -> Type)
  : A * B -> Type :=
    pairᴱ0 : forall (H : A) (H0 : B), Aᴱ H -> prodᴱ A Aᴱ B Bᴱ (H, H0)
  | pairᴱ1 : forall (H : A) (H0 : B), Bᴱ H0 -> prodᴱ A Aᴱ B Bᴱ (H, H0)

Arguments prodᴱ _%type_scope _%function_scope _%type_scope _%function_scope
Arguments pairᴱ0 _%type_scope _%function_scope _%type_scope _%function_scope
Arguments pairᴱ1 _%type_scope _%function_scope _%type_scope _%function_scope
(String.String (Ascii.Ascii false true true true true true true false)
   (String.String (Ascii.Ascii false true true true true true true false)
      (String.String (Ascii.Ascii false true true true true true true false)
         (String.String
            (Ascii.Ascii false true true true true true true false)
            (String.String
               (Ascii.Ascii false true true true true true true false)
               (String.String
                  (Ascii.Ascii false true true true true true true false)
                  (String.String
                     (Ascii.Ascii false true true true true true true false)
                     (String.String
                        (Ascii.Ascii false true true true true true true
                           false)
                        (String.String
                           (Ascii.Ascii false true true true true true true
                              false)
                           (String.String
                              (Ascii.Ascii false true true true true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false true true true true true
                                    true false)
                                 (String.String
                                    (Ascii.Ascii false true true true true
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii false true true true true
                                          true true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true true true true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true true true true false)
                                                (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 String.EmptyString))))))))))))))))))
(String.String (Ascii.Ascii false false true true false false true false)
   (String.String (Ascii.Ascii true true true true false true true false)
      (String.String (Ascii.Ascii true true true true false true true false)
         (String.String
            (Ascii.Ascii true true false true false true true false)
            (String.String
               (Ascii.Ascii true false false true false true true false)
               (String.String
                  (Ascii.Ascii false true true true false true true false)
                  (String.String
                     (Ascii.Ascii true true true false false true true false)
                     (String.String
                        (Ascii.Ascii false false false false false true false
                           false)
                        (String.String
                           (Ascii.Ascii true false true false true true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false false false false false
                                    true false false)
                                 (String.String
                                    (Ascii.Ascii true false true true false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true false true false
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii false false true false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii true true false
                                                 false false false true false)
                                                (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))))))))))))
Complete Identifier: MetaCoq.Translations.showcase.List
Short Identifier: List
(String.String (Ascii.Ascii false false true false true false true false)
   (String.String (Ascii.Ascii false true false false true true true false)
      (String.String
         (Ascii.Ascii true false false false false true true false)
         (String.String
            (Ascii.Ascii false true true true false true true false)
            (String.String
               (Ascii.Ascii true true false false true true true false)
               (String.String
                  (Ascii.Ascii false false true true false true true false)
                  (String.String
                     (Ascii.Ascii true false false false false true true
                        false)
                     (String.String
                        (Ascii.Ascii false false true false true true true
                           false)
                        (String.String
                           (Ascii.Ascii true false true false false true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false false true
                                 false false)
                              (String.String
                                 (Ascii.Ascii true false true true false
                                    false true false)
                                 (String.String
                                    (Ascii.Ascii true false true false false
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii false false true false
                                          true true true false)
                                       (String.String
                                          (Ascii.Ascii true false false false
                                             false true true false)
                                          (String.String
                                             (Ascii.Ascii true true false
                                                false false false true false)
                                             (String.String
                                                (Ascii.Ascii true true true
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String (...) (...))))))))))))))))))))))))
(BasicAst.IndRef
   {|
   BasicAst.inductive_mind := (BasicAst.MPfile
                                 (String.String
                                    (Ascii.Ascii true true false false true
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii false false false true
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii true true true true
                                             false true true false)
                                          (String.String
                                             (Ascii.Ascii true true true
                                                false true true true false)
                                             (String.String
                                                (Ascii.Ascii true true false
                                                 false false true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                  :: String.String
                                       (Ascii.Ascii false false true false
                                          true false true false)
                                       (String.String
                                          (Ascii.Ascii false true false false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString)))))))))))
                                     :: String.String
                                          (Ascii.Ascii true false true true
                                             false false true false)
                                          (String.String
                                             (Ascii.Ascii true false true
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                        :: nil)%list,
                              String.String
                                (Ascii.Ascii false false true true false
                                   false true false)
                                (String.String
                                   (Ascii.Ascii true false false true false
                                      true true false)
                                   (String.String
                                      (Ascii.Ascii true true false false true
                                         true true false)
                                      (String.String
                                         (Ascii.Ascii false false true false
                                            true true true false)
                                         String.EmptyString))));
   BasicAst.inductive_ind := 0 |})
{|
Ast.ind_finite := BasicAst.Finite;
Ast.ind_npars := 2;
Ast.ind_params := ({|
                   Ast.decl_name := BasicAst.nNamed
                                      (String.String
                                         (Ascii.Ascii false false false true
                                            true false true false)
                                         (String.String
                                            (Ascii.Ascii true false false
                                               false false true true true)
                                            (String.String
                                               (Ascii.Ascii false false true
                                                 false true true false true)
                                               (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString))));
                   Ast.decl_body := None;
                   Ast.decl_type := Ast.tProd BasicAst.nAnon 
                                      (Ast.tRel 0)
                                      (Ast.tSort
                                         {|
                                         Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)) |};
                                         Universes.Universe.t_ne := eq_refl |}) |}
                   :: {|
                      Ast.decl_name := BasicAst.nNamed
                                         (String.String
                                            (Ascii.Ascii false false false
                                               true true false true false)
                                            String.EmptyString);
                      Ast.decl_body := None;
                      Ast.decl_type := Ast.tSort
                                         {|
                                         Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)) |};
                                         Universes.Universe.t_ne := eq_refl |} |}
                      :: nil)%list;
Ast.ind_bodies := {|
                  Ast.ind_name := String.String
                                    (Ascii.Ascii false false true true false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true false false true
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii true true false false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false false true
                                                false true true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false false true true true)
                                                (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString))))));
                  Ast.ind_type := Ast.tProd
                                    (BasicAst.nNamed
                                       (String.String
                                          (Ascii.Ascii false false false true
                                             true false true false)
                                          String.EmptyString))
                                    (Ast.tSort
                                       {|
                                       Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)) |};
                                       Universes.Universe.t_ne := eq_refl |})
                                    (Ast.tProd
                                       (BasicAst.nNamed
                                          (String.String
                                             (Ascii.Ascii false false false
                                                true true false true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false false true true true)
                                                (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))
                                       (Ast.tProd BasicAst.nAnon 
                                          (Ast.tRel 0)
                                          (Ast.tSort
                                             {|
                                             Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)) |};
                                             Universes.Universe.t_ne := eq_refl |}))
                                       (Ast.tProd BasicAst.nAnon
                                          (Ast.tApp
                                             (Ast.tInd
                                                {|
                                                BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString)))))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
                                                BasicAst.inductive_ind := 0 |}
                                                nil) 
                                             (Ast.tRel 1 :: nil))
                                          (Ast.tSort
                                             {|
                                             Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)) |};
                                             Universes.Universe.t_ne := eq_refl |})));
                  Ast.ind_kelim := Universes.InType;
                  Ast.ind_ctors := (String.String
                                      (Ascii.Ascii true true false false
                                         false false true false)
                                      (String.String
                                         (Ascii.Ascii true true true true
                                            false true true false)
                                         (String.String
                                            (Ascii.Ascii false true true true
                                               false true true false)
                                            (String.String
                                               (Ascii.Ascii true true false
                                                 false true true true false)
                                               (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true false
                                                 false) String.EmptyString))))))),
                                   Ast.tProd
                                     (BasicAst.nNamed
                                        (String.String
                                           (Ascii.Ascii false false false
                                              true true false true false)
                                           String.EmptyString))
                                     (Ast.tSort
                                        {|
                                        Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)) |};
                                        Universes.Universe.t_ne := eq_refl |})
                                     (Ast.tProd
                                        (BasicAst.nNamed
                                           (String.String
                                              (Ascii.Ascii false false false
                                                 true true false true false)
                                              (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))
                                        (Ast.tProd BasicAst.nAnon
                                           (Ast.tRel 0)
                                           (Ast.tSort
                                              {|
                                              Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)) |};
                                              Universes.Universe.t_ne := eq_refl |}))
                                        (Ast.tProd
                                           (BasicAst.nNamed
                                              (String.String
                                                 (Ascii.Ascii false false
                                                 false true true true true
                                                 false) String.EmptyString))
                                           (Ast.tRel 1)
                                           (Ast.tProd
                                              (BasicAst.nNamed
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString)))
                                              (Ast.tApp
                                                 (Ast.tInd
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String (...) (...)))))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 nil) 
                                                 (Ast.tRel 2 :: nil))
                                              (Ast.tProd BasicAst.nAnon
                                                 (Ast.tApp 
                                                 (Ast.tRel 2)
                                                 (Ast.tRel 1 :: nil))
                                                 (Ast.tApp 
                                                 (Ast.tRel 5)
                                                 (Ast.tRel 4
                                                 :: 
                                                 Ast.tRel 3
                                                 :: 
                                                 Ast.tApp
                                                 (Ast.tConstruct
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String 
                                                 (...) String.EmptyString)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String 
                                                 (...) String.EmptyString))))))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 1 nil)
                                                 (Ast.tRel 4
                                                 :: 
                                                 Ast.tRel 2
                                                 :: 
                                                 Ast.tRel 1 :: nil) :: nil)))))),
                                   3)
                                   :: (String.String
                                         (Ascii.Ascii true true false false
                                            false false true false)
                                         (String.String
                                            (Ascii.Ascii true true true true
                                               false true true false)
                                            (String.String
                                               (Ascii.Ascii false true true
                                                 true false true true false)
                                               (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 false) String.EmptyString))))))),
                                      Ast.tProd
                                        (BasicAst.nNamed
                                           (String.String
                                              (Ascii.Ascii false false false
                                                 true true false true false)
                                              String.EmptyString))
                                        (Ast.tSort
                                           {|
                                           Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)) |};
                                           Universes.Universe.t_ne := eq_refl |})
                                        (Ast.tProd
                                           (BasicAst.nNamed
                                              (String.String
                                                 (Ascii.Ascii false false
                                                 false true true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))
                                           (Ast.tProd BasicAst.nAnon
                                              (Ast.tRel 0)
                                              (Ast.tSort
                                                 {|
                                                 Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)) |};
                                                 Universes.Universe.t_ne := eq_refl |}))
                                           (Ast.tProd
                                              (BasicAst.nNamed
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true true true true
                                                 false) String.EmptyString))
                                              (Ast.tRel 1)
                                              (Ast.tProd
                                                 (BasicAst.nNamed
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString)))
                                                 (Ast.tApp
                                                 (Ast.tInd
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String ... ...))))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 nil) 
                                                 (Ast.tRel 2 :: nil))
                                                 (Ast.tProd BasicAst.nAnon
                                                 (Ast.tApp 
                                                 (Ast.tRel 4)
                                                 (Ast.tRel 3
                                                 :: 
                                                 Ast.tRel 2
                                                 :: 
                                                 Ast.tRel 0 :: nil))
                                                 (Ast.tApp 
                                                 (Ast.tRel 5)
                                                 (Ast.tRel 4
                                                 :: 
                                                 Ast.tRel 3
                                                 :: 
                                                 Ast.tApp
                                                 (Ast.tConstruct
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String ...
                                                 String.EmptyString)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String (...) (...)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String ...
                                                 String.EmptyString))))))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 1 nil)
                                                 (Ast.tRel 4
                                                 :: 
                                                 Ast.tRel 2
                                                 :: 
                                                 Ast.tRel 1 :: nil) :: nil)))))),
                                      3) :: nil;
                  Ast.ind_projs := nil |} :: nil;
Ast.ind_universes := Universes.Monomorphic_ctx
                       ({|
                        Universes.LevelSet.this := nil;
                        Universes.LevelSet.is_ok := Universes.LevelSet.Raw.empty_ok |},
                       {|
                       Universes.ConstraintSet.this := nil;
                       Universes.ConstraintSet.is_ok := Universes.ConstraintSet.Raw.empty_ok |});
Ast.ind_variance := None |}
MetaCoq.Translations.showcase.List has been translated.
(String.String (Ascii.Ascii false true true true true true true false)
   (String.String (Ascii.Ascii false true true true true true true false)
      (String.String (Ascii.Ascii false true true true true true true false)
         (String.String
            (Ascii.Ascii false true true true true true true false)
            (String.String
               (Ascii.Ascii false true true true true true true false)
               (String.String
                  (Ascii.Ascii false true true true true true true false)
                  (String.String
                     (Ascii.Ascii false true true true true true true false)
                     (String.String
                        (Ascii.Ascii false true true true true true true
                           false)
                        (String.String
                           (Ascii.Ascii false true true true true true true
                              false)
                           (String.String
                              (Ascii.Ascii false true true true true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false true true true true true
                                    true false)
                                 (String.String
                                    (Ascii.Ascii false true true true true
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii false true true true true
                                          true true false)
                                       (String.String
                                          (Ascii.Ascii false true true true
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii false true true
                                                true true true true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true true true true false)
                                                (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true true true true false)
                                                 String.EmptyString))))))))))))))))))
(String.String (Ascii.Ascii false false true true false false true false)
   (String.String (Ascii.Ascii true true true true false true true false)
      (String.String (Ascii.Ascii true true true true false true true false)
         (String.String
            (Ascii.Ascii true true false true false true true false)
            (String.String
               (Ascii.Ascii true false false true false true true false)
               (String.String
                  (Ascii.Ascii false true true true false true true false)
                  (String.String
                     (Ascii.Ascii true true true false false true true false)
                     (String.String
                        (Ascii.Ascii false false false false false true false
                           false)
                        (String.String
                           (Ascii.Ascii true false true false true true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false false false false false
                                    true false false)
                                 (String.String
                                    (Ascii.Ascii true false true true false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true false true false
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii false false true false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii true true false
                                                 false false false true false)
                                                (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))))))))))))
(String.String (Ascii.Ascii false false true true false false true false)
   (String.String (Ascii.Ascii true true true true false true true false)
      (String.String (Ascii.Ascii true true true true false true true false)
         (String.String
            (Ascii.Ascii true true false true false true true false)
            (String.String
               (Ascii.Ascii true false false true false true true false)
               (String.String
                  (Ascii.Ascii false true true true false true true false)
                  (String.String
                     (Ascii.Ascii true true true false false true true false)
                     (String.String
                        (Ascii.Ascii false false false false false true false
                           false)
                        (String.String
                           (Ascii.Ascii true false true false true true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false true true
                                 true false)
                              (String.String
                                 (Ascii.Ascii false false false false false
                                    true false false)
                                 (String.String
                                    (Ascii.Ascii true false true true false
                                       false true false)
                                    (String.String
                                       (Ascii.Ascii true false true false
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii false false true false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii true true false
                                                 false false false true false)
                                                (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String (...) (...))))))))))))))))))))))))
Complete Identifier: MetaCoq.Translations.showcase.rose
Short Identifier: rose
(String.String (Ascii.Ascii false false true false true false true false)
   (String.String (Ascii.Ascii false true false false true true true false)
      (String.String
         (Ascii.Ascii true false false false false true true false)
         (String.String
            (Ascii.Ascii false true true true false true true false)
            (String.String
               (Ascii.Ascii true true false false true true true false)
               (String.String
                  (Ascii.Ascii false false true true false true true false)
                  (String.String
                     (Ascii.Ascii true false false false false true true
                        false)
                     (String.String
                        (Ascii.Ascii false false true false true true true
                           false)
                        (String.String
                           (Ascii.Ascii true false true false false true true
                              false)
                           (String.String
                              (Ascii.Ascii false false false false false true
                                 false false)
                              (String.String
                                 (Ascii.Ascii true false true true false
                                    false true false)
                                 (String.String
                                    (Ascii.Ascii true false true false false
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii false false true false
                                          true true true false)
                                       (String.String
                                          (Ascii.Ascii true false false false
                                             false true true false)
                                          (String.String
                                             (Ascii.Ascii true true false
                                                false false false true false)
                                             (String.String
                                                (Ascii.Ascii true true true
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String (...) (...))))))))))))))))))))))))
(BasicAst.IndRef
   {|
   BasicAst.inductive_mind := (BasicAst.MPfile
                                 (String.String
                                    (Ascii.Ascii true true false false true
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii false false false true
                                          false true true false)
                                       (String.String
                                          (Ascii.Ascii true true true true
                                             false true true false)
                                          (String.String
                                             (Ascii.Ascii true true true
                                                false true true true false)
                                             (String.String
                                                (Ascii.Ascii true true false
                                                 false false true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                  :: String.String
                                       (Ascii.Ascii false false true false
                                          true false true false)
                                       (String.String
                                          (Ascii.Ascii false true false false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii true false false
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii false true true
                                                 true false true true false)
                                                (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString)))))))))))
                                     :: String.String
                                          (Ascii.Ascii true false true true
                                             false false true false)
                                          (String.String
                                             (Ascii.Ascii true false true
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii false false true
                                                 false true true true false)
                                                (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                        :: nil)%list,
                              String.String
                                (Ascii.Ascii false true false false true true
                                   true false)
                                (String.String
                                   (Ascii.Ascii true true true true false
                                      true true false)
                                   (String.String
                                      (Ascii.Ascii true true false false true
                                         true true false)
                                      (String.String
                                         (Ascii.Ascii true false true false
                                            false true true false)
                                         String.EmptyString))));
   BasicAst.inductive_ind := 0 |})
{|
Ast.ind_finite := BasicAst.Finite;
Ast.ind_npars := 2;
Ast.ind_params := ({|
                   Ast.decl_name := BasicAst.nNamed
                                      (String.String
                                         (Ascii.Ascii false false false true
                                            true false true false)
                                         (String.String
                                            (Ascii.Ascii true false false
                                               false false true true true)
                                            (String.String
                                               (Ascii.Ascii false false true
                                                 false true true false true)
                                               (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString))));
                   Ast.decl_body := None;
                   Ast.decl_type := Ast.tProd BasicAst.nAnon 
                                      (Ast.tRel 0)
                                      (Ast.tSort
                                         {|
                                         Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String (...) (...))))))))))))))),
                                                 false)) |};
                                         Universes.Universe.t_ne := eq_refl |}) |}
                   :: {|
                      Ast.decl_name := BasicAst.nNamed
                                         (String.String
                                            (Ascii.Ascii false false false
                                               true true false true false)
                                            String.EmptyString);
                      Ast.decl_body := None;
                      Ast.decl_type := Ast.tSort
                                         {|
                                         Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String (...) (...)))))))))))))))),
                                                 false) :: nil;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
                                         Universes.Universe.t_ne := eq_refl |} |}
                      :: nil)%list;
Ast.ind_bodies := {|
                  Ast.ind_name := String.String
                                    (Ascii.Ascii false true false false true
                                       true true false)
                                    (String.String
                                       (Ascii.Ascii true true true true false
                                          true true false)
                                       (String.String
                                          (Ascii.Ascii true true false false
                                             true true true false)
                                          (String.String
                                             (Ascii.Ascii true false true
                                                false false true true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false false true true true)
                                                (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString))))));
                  Ast.ind_type := Ast.tProd
                                    (BasicAst.nNamed
                                       (String.String
                                          (Ascii.Ascii false false false true
                                             true false true false)
                                          String.EmptyString))
                                    (Ast.tSort
                                       {|
                                       Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String ... ...))))))))))))))),
                                                 false)) |};
                                       Universes.Universe.t_ne := eq_refl |})
                                    (Ast.tProd
                                       (BasicAst.nNamed
                                          (String.String
                                             (Ascii.Ascii false false false
                                                true true false true false)
                                             (String.String
                                                (Ascii.Ascii true false false
                                                 false false true true true)
                                                (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))
                                       (Ast.tProd BasicAst.nAnon 
                                          (Ast.tRel 0)
                                          (Ast.tSort
                                             {|
                                             Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String ... ...))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String ... ...))))))))))))),
                                                 false)) |};
                                             Universes.Universe.t_ne := eq_refl |}))
                                       (Ast.tProd BasicAst.nAnon
                                          (Ast.tApp
                                             (Ast.tInd
                                                {|
                                                BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 String.EmptyString)))))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString))));
                                                BasicAst.inductive_ind := 0 |}
                                                nil) 
                                             (Ast.tRel 1 :: nil))
                                          (Ast.tSort
                                             {|
                                             Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (Universes.NoPropLevel.lSet,
                                                 false)) |};
                                             Universes.Universe.t_ne := eq_refl |})));
                  Ast.ind_kelim := Universes.InType;
                  Ast.ind_ctors := (String.String
                                      (Ascii.Ascii false false true false
                                         true true true false)
                                      (String.String
                                         (Ascii.Ascii false true false false
                                            true true true false)
                                         (String.String
                                            (Ascii.Ascii true false true
                                               false false true true false)
                                            (String.String
                                               (Ascii.Ascii true false true
                                                 false false true true false)
                                               (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false false true true false
                                                 false) String.EmptyString))))))),
                                   Ast.tProd
                                     (BasicAst.nNamed
                                        (String.String
                                           (Ascii.Ascii false false false
                                              true true false true false)
                                           String.EmptyString))
                                     (Ast.tSort
                                        {|
                                        Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String ... ...)))))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String ... ...)))))))))))))),
                                                 false)) |};
                                        Universes.Universe.t_ne := eq_refl |})
                                     (Ast.tProd
                                        (BasicAst.nNamed
                                           (String.String
                                              (Ascii.Ascii false false false
                                                 true true false true false)
                                              (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))
                                        (Ast.tProd BasicAst.nAnon
                                           (Ast.tRel 0)
                                           (Ast.tSort
                                              {|
                                              Universes.Universe.t_set := {|
                                                 Universes.UnivExprSet.this := (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false) :: nil)%list;
                                                 Universes.UnivExprSet.is_ok := Universes.UnivExprSet.Raw.singleton_ok
                                                 (Universes.UnivExpr.npe
                                                 (
                                                 Universes.NoPropLevel.Level
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String ... ...)))))))))))),
                                                 false)) |};
                                              Universes.Universe.t_ne := eq_refl |}))
                                        (Ast.tProd
                                           (BasicAst.nNamed
                                              (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false) String.EmptyString))
                                           (Ast.tApp
                                              (Ast.tInd
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String 
                                                 (...) String.EmptyString)))))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false) String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 nil)
                                              (Ast.tApp
                                                 (Ast.tInd
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String ... ...))))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 nil) 
                                                 (Ast.tRel 1 :: nil) :: nil))
                                           (Ast.tProd BasicAst.nAnon
                                              (Ast.tApp
                                                 (Ast.tInd
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String (...) (...)))))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true true false false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true false
                                                 true)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true false
                                                 true) String.EmptyString)))))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 nil)
                                                 (Ast.tApp
                                                 (Ast.tInd
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String ... ...)))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 nil) 
                                                 (Ast.tRel 2 :: nil)
                                                 :: 
                                                 Ast.tApp 
                                                 (Ast.tRel 3)
                                                 (Ast.tRel 2
                                                 :: 
                                                 Ast.tRel 1 :: nil)
                                                 :: 
                                                 Ast.tRel 0 :: nil))
                                              (Ast.tApp 
                                                 (Ast.tRel 4)
                                                 (Ast.tRel 3
                                                 :: 
                                                 Ast.tRel 2
                                                 :: 
                                                 Ast.tApp
                                                 (Ast.tConstruct
                                                 {|
                                                 BasicAst.inductive_mind := (
                                                 BasicAst.MPfile
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString)))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String ... ...))))))))
                                                 :: 
                                                 String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false) String.EmptyString))))))
                                                 :: nil)%list,
                                                 String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 String.EmptyString))));
                                                 BasicAst.inductive_ind := 0 |}
                                                 0 nil)
                                                 (Ast.tRel 3
                                                 :: 
                                                 Ast.tRel 1 :: nil) :: nil))))),
                                   2) :: nil;
                  Ast.ind_projs := nil |} :: nil;
Ast.ind_universes := Universes.Monomorphic_ctx
                       ({|
                        Universes.LevelSet.this := (Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String ... ...)))))))))))))))))))
                                                 :: nil)%list;
                        Universes.LevelSet.is_ok := Universes.LevelSet.Raw.add_ok
                                                 (s:=nil)
                                                 (Universes.Level.Level
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 true false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true false true
                                                 false false true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false false false true false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true false false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true false true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true
                                                 false false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false true true
                                                 true false true true false)
                                                 (String.String
                                                 (Ascii.Ascii true true false
                                                 false true true true false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false false false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii false false
                                                 true false true true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true false
                                                 false true false true true
                                                 false)
                                                 (String.String
                                                 (Ascii.Ascii true true true
                                                 true false true true false)
                                                 (String.String ... ...))))))))))))))))))))
                                                 Universes.LevelSet.Raw.empty_ok |},
                       {|
                       Universes.ConstraintSet.this := nil;
                       Universes.ConstraintSet.is_ok := Universes.ConstraintSet.Raw.empty_ok |});
Ast.ind_variance := None |}
MetaCoq.Translations.showcase.rose has been translated.
Inductive roseᴱ (X : Type) (Xᴱ : X -> Type) : rose X -> Set :=
    treeᴱ0 : forall h : List (rose X),
             Listᴱ (rose X) (roseᴱ X Xᴱ) h -> roseᴱ X Xᴱ (tree X h)

Arguments roseᴱ _%type_scope _%function_scope
Arguments treeᴱ0 _%type_scope _%function_scope
showcase.vo (real: 7.24, user: 6.75, sys: 0.41, mem: 573272 ko)
make[4]: Für das Ziel „real-all“ ist nichts zu tun.
